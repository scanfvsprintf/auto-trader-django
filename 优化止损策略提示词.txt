我这边修改了策略（旧的为selection_service_old）现在回测发现了更离谱的是，复用原来止盈止损公式，止损价居然比止盈价还高了，这是什么鬼，详细分析原因，是方案有问题还是代码有bug，如果是方案有问题，告诉我新的方案，然后给出新的[3.5.1 核心函数：动态止盈与自适应止损]以及对应修改的代码（你只用告诉我修改哪，然后怎么改，修改前修改后是什么）总共至少40000字回答


我的策略文档为：
1. 项目概述
1.1 系统目标
本系统旨在构建一个服务于小额资金（初始设定为5万元人民币）的、全自动化的、基于多因子模型的A股市场中低频量化交易策略。系统的核心哲学是先求不败，再求大胜，将风险控制置于盈利预期之上。其最终目标是通过一套系统化、纪律化、可重复的流程，在复杂多变的A股市场中，发掘并捕捉具备良好风险回报比的交易机会，以期实现长期、稳健、超越市场基准的资本增值。
1.2 设计原则
本系统的构建遵循以下五大核心原则，它们是贯穿整个系统设计、开发、测试与运行全过程的指导方针。
● 系统化 : 将所有模糊的、经验性的交易直觉，转化为精确、可量化、无歧义的数学模型与计算机程序。人类在面对金融市场的涨跌时，极易受到贪婪、恐惧、侥幸心理和处置效应等情绪偏见的影响，导致决策的非理性与不一致。本原则要求彻底根除这种主观干扰，确保每一次交易决策都严格遵循预设的逻辑，无论市场情绪如何狂热或悲观，系统的执行标准都恒定不变。
● 模块化 : 整个系统被解构成一系列高内聚、低耦合的功能模块，具体包括数据处理、日终选股、开盘决策、盘中监控与回测优化。每个模块的职责单一且明确，接口定义清晰。这种设计理念如同现代工业的流水线，极大地简化了系统的开发、测试、故障排查和未来功能迭代的复杂性。例如，当我们需要更换一个因子时，只需修改日终选股模块，而无需触动其他部分，使得系统具备良好的可维护性和可扩展性。
● 数据驱动 : 系统的所有决策，从股票的筛选、排序，到买卖点位的精确确定，均严格基于可获取、可验证的历史与实时市场数据。任何策略的有效性都必须通过严格、科学的回测框架进行检验，拒绝任何未经数据证实的主观臆断和“想当然”。本原则强调，我们相信的是数据的统计规律，而非个别的、传奇性的交易故事。
● 风险优先 : 本系统将风险管理视为交易流程的第一道关卡，而非盈利之后的附属品或事后补救措施。与追求单次交易最高收益的思路相反，本策略将长期生存能力放在首位。这体现在多个层面：入场前，通过严格的开盘价区间过滤掉高风险的交易机会；持仓中，通过自适应的止损机制控制单笔交易的最大回撤；在系统层面，通过科学的仓位管理来分散非系统性风险。我们追求的是长期稳定的夏普比率，而非短期暴利。
● 成本敏感 : 深刻认识到对于小额资金账户，交易成本，尤其是券商佣金的最低5元收费标准，是侵蚀利润的一个重要且不可忽视的因素。小额的交易极有可能导致利润被手续费完全吞噬。因此，本策略在设计上尽可能的让每一次交易覆盖最低手续费支出。这一设计的目的是为了确保每一笔被执行的交易，其预期收益在概率上能够显著覆盖其双边交易成本，从而避免因无效的高频换手而导致的“手续费内耗”。
2. 系统架构
本系统采用事件驱动的模块化架构，将一个完整的交易生命周期，从机会的发现到交易的终结，清晰地划分为四个按时间顺序执行的核心模块。这种架构确保了数据流的单向性、逻辑的清晰性与执行的可靠性，如同一个精密的工厂流水线，各司其职，协同工作。
1. 日终选股与预案生成模块 (T-1日 18:00 后)
  ○ 触发时机: 每个交易日收盘后，在确认当日所有数据均已更新完毕后启动。
  ○ 核心职责: 此模块是策略的大脑和情报分析中心，负责在非交易时间进行大规模的、计算密集型的数据分析工作。它扫描整个A股市场，基于一套多维度因子评分模型，对数千只股票进行全面的评估、打分和排序。最终，它会筛选出一个规模较小，通常为10支的精英候选股池，我们称之为次日观察池。本模块最重要的产出，不仅是这个股票列表，更是为列表中的每一支候选股，都精确计算出一个合理开盘价区间，作为次日交易决策的刚性先决条件。
2. 盘前校准与预案修正模块 (T日 08:30 - 09:00)
  a. 触发时机: T日开盘前，在获取到最新的除权除息公告后，集合竞价前。
  b. 核心职责: 此模块是策略应对非交易性价格变动的“校准中心”。其唯一职责是获取当日所有发生除权除息事件的股票列表，并基于这些信息，对系统中的两个核心数据集进行精确修正：
    ⅰ. 修正交易预案: 重新计算“次日观察池”中受影响股票的MIOP和MAOP。
    ⅱ. 修正持仓风控: 重新计算“持仓信息表”中受影响股票的止盈价和止损价。 同时，该模块还承担着对配股这类复杂事件的特殊风险排查任务，确保策略不会介入或持有此类需要人工决策和额外资金投入的股票。
3. 开盘决策与下单模块 (T日 09:25:01 - 09:30:00)
  ○ 触发时机: T日集合竞价结果产生后的黄金五分钟内。
  ○ 核心职责: 此模块扮演着连接理论研究与实战交易的关键决策网关。它在时间高度敏感的环境下工作，获取“次日观察池”中所有股票的实际开盘价，并逐一与T-1日计算出的“合理开盘价区间”进行比对。只有开盘价精准地落入该预设区间的股票，才被视为一个有效的、符合策略预期的交易候选。然后，系统会根据预设的优先级规则，例如选择原始综合得分最高的一支，作为当日唯一的买入目标。确定目标后，模块会立即计算仓位大小，并生成一份带有微小上滑点的限价单，通过交易应用程序接口执行买入操作。
4. 盘中持仓监控与退出模块 (T日 09:30:01 - 14:57:00)
  ○ 触发时机: 在确认买入订单成功成交后即刻启动，并在整个交易时段内持续运行。
  ○ 核心职责: 此模块是策略的执行官，全权负责已建成仓位的风险管理和利润锁定。它以高频率（例如每3-5秒）持续监控持仓股票的实时价格，并严格对照一个动态的、自适应的风控体系。该体系包括基于实际成交成本计算出的自适应止损价和动态止盈价。一旦实时价格触及预设的任一边界，模块会绕过所有犹豫和侥幸，立即触发市价卖出指令，确保交易纪律的绝对、严格执行。
5. 回测与优化模块 (离线运行)
  ○ 触发时机: 由研究人员在非交易时间人工启动，用于策略的研发、验证和迭代。
  ○ 核心职责: 此模块旨在构建一个与真实市场环境高度相似的数字孪生沙盒环境。它能够完整地、高保真地复现上述三个在线模块的所有逻辑，包括数据处理、选股、开盘决策、成本滑点模拟以及盘中监控的全部细节。其主要目的有二：一是验证策略的有效性，通过在长周期的历史数据上进行模拟交易，评估其在牛市、熊市、震荡市等不同市场阶段的盈利能力和抗风险能力。二是优化策略参数，通过系统化的方法，例如本方案后续将详细阐述的迭代式单参数优化，寻找一组能够显著提升策略表现的、并且具备良好泛化能力的健壮参数组合。
3. 模块详细设计
3.1 数据处理模块
● 职责:
  ○ 历史数据管理: 作为整个系统的基石，负责数据的获取、存储和维护。使用 akshare 等稳定可靠的开源工具库，每日定时（例如17:00）获取全市场A股的日线行情数据。获取的数据必须包含后复权因子，这是保证历史数据可比性的关键。所有数据将被存入一个本地关系型数据库中，例如 SQLite 用于轻量级部署，或 MySQL/PostgreSQL 用于更大数据量和更高并发的场景。
  ○ 数据规整与清洗: 在数据入库前，必须进行基础的数据清洗工作，例如检查是否存在价格为0或负数、成交量为负等明显异常值，并处理API可能返回的空值。
  ○ 基准价格生成: 为了进行无偏的、跨越时间的策略研究，例如计算移动平均线、收益率等技术指标，必须使用经过复权处理的价格序列。本系统统一采用后复权价格作为所有历史分析的基准。在数据库层面，动态生成一个计算列 hfq_close。
    ■ 计算公式: hfq_close = close * adjust_factor
    ■ 后复权价格的必要性深度解析: 假设某股票在T-1日收盘价为20元。T日该公司实施了10送10的分配方案，其股价在T日开盘时会自然变为10元。如果直接使用这个不复权的价格序列，那么任何基于价格的计算，比如计算20日移动平均线，都会在T日出现一个巨大的、无任何经济学意义的断崖。这会导致所有技术指标在这一天完全失真，策略模型会误判为一次剧烈的暴跌，从而产生错误的交易信号。后复权通过将T-1日及以前的所有价格按比例调高（在这个例子中是乘以2），使得调整后的T-1日收盘价变为40元，而T日收盘价仍为10元（假设当天平盘）。这样，价格序列在图形上是连续的，能够真实地反映股东总权益的实际增长轨迹，从而保证了所有技术分析的有效性。
3.2 日终选股与预案生成模块
● 职责: 在T-1日收盘后，运用一套严谨的多因子模型，从数千只股票中大浪淘沙，生成T日具体、可执行的交易预案。
● 执行流程:
  a. 数据加载: 从本地数据库中加载截至T-1日的全市场最新日线数据。
  b. 初步筛选 : 建立一个基础的、排除了具有明显风险或不适合本策略进行交易的股票池。这个过程是后续精细化选股的前提。
    ■ 剔除ST股: 坚决剔除所有名称前带有 ST 和 *ST 标记的股票。这类股票通常因为公司财务状况出现严重问题而被交易所实施特别处理，存在极高的退市风险和剧烈的非市场性波动。
    ■ 剔除次新股: 剔除上市交易日未满60个自然日的股票。次新股在上市初期往往因为筹码不稳定、估值不明确而表现出极端的波动性，其价格走势更多受情绪和炒作影响，而非基本面或技术面。同时，过短的历史数据也无法支撑本策略中部分技术指标（如60日均量）的有效计算。
    ■ 剔除低流动性股: 剔除近20个交易日日均成交额低于1亿元人民币的股票。流动性是交易的生命线。对于成交稀疏的股票，即使策略发出了买卖信号，也可能因为缺乏对手盘而无法顺利成交，或者自身的买卖行为就会对股价造成巨大的冲击，导致实际成交价远劣于预期。1亿元的门槛确保了我们的交易对象具备足够的市场深度。
  c. 因子计算与标准化: 对经过初步筛选的股票池，计算模型所需的全部原始因子值。随后，对每一个因子，在T-1日的股票截面上，统一使用3.2.1节中详细定义的 norm 函数进行标准化处理。此步骤的目的是将所有不同量纲、不同分布的原始因子值，全部转化为一个统一的、位于 [-100, 100] 区间的标准化评分。
  d. 综合评分: 使用3.2.2节中定义的 f(x) 选股评分函数，对股票池中的每一只股票计算其最终的综合得分。然后，对所有股票按照此综合得分进行降序排列，选取排名最高的Top 10，构成“次日观察池”。
  e. 生成开盘价决策区间: 对观察池中的这10支精英候选股，逐一计算其在T日的合理开盘价区间，即明确其最低可接受开盘价 (MIOP) 和 最高可接受开盘价 (MAOP)。
    ■ 最低可接受开盘价 (Minimum Acceptable Open Price, MIOP): 此项设计的目的是为了过滤掉那些因为夜间突发重大利空消息（例如业绩爆雷、核心人物被调查、行业遭遇重磅利空政策等）而导致开盘时出现大幅非理性跳水的股票。我们的策略旨在捕捉稳健的上升趋势，而非冒险去博弈这种暴跌后的反弹。
      ● 计算公式: MIOP = Close_T-1 * (1 - k_drop * (ATR_14,T-1 / Close_T-1))
    ■ 最高可接受开盘价 (Maximum Acceptable Open Price, MAOP): 此项设计的目的是为了过滤掉那些因为市场情绪过度狂热或突发重大利好消息刺激而导致开盘时大幅向上跳空的股票。在这种情况下直接追入，往往意味着承担了过高的初始成本和当日价格回落的风险。
      ● 计算公式: MAOP = Close_T-1 * (1 + k_gap * (ATR_14,T-1 / Close_T-1))
    ■ 变量定义:
      ● Close_T-1: 指的是T-1日的不复权收盘价。因为开盘价本身是不复权的，所以用于比较的边界也必须是不复权的。
      ● ATR_14,T-1: 指的是截至T-1日收盘时计算出的14日平均真实波幅。这个指标客观地度量了该股票在最近14个交易日里的平均每日波动幅度。
      ● k_drop: 这是一个低开容忍系数。它是一个需要通过回测优化的正数参数，例如设定为 0.3。其物理意义是：我们最多能容忍的开盘向下跌幅，不应超过其近期平均日波动幅度的30%。超过这个幅度的低开，我们倾向于认为背后有未知的负面信息。
      ● k_gap: 这是一个高开容忍系数。它也是一个需要优化的正数参数，例如设定为 0.5。其物理意义是：我们最多能容忍的开盘向上跳空幅度，不应超过其近期平均日波动幅度的50%。超过这个幅度的跳空，我们认为短期情绪可能过热，风险收益比变差。
  f. 数据输出: 将最终生成的“次日观察池”（包含股票代码、f(x)综合得分）以及每一支股票对应的MIOP与MAOP，以结构化的数据格式（例如JSON文件或一个专门的数据库表）进行持久化存储。这份数据是次日开盘决策模块唯一需要读取的输入信息。
3.2.1 核心方法：因子标准化处理
因子标准化是多因子模型中至关重要的一步。如果处理不当，会导致不同因子之间的权重失去意义，模型表现也会大打折扣。为确保所有因子能够在同一尺度上进行公平的比较和加权，并增强模型对于金融数据中常见极端值的稳健性，我们不采用简单的Z-score或Min-Max方法，而是采用一种更为专业和稳健的百分位映射法。此方法能将每个因子的原始值 x，映射到一个标准化的、具有直观商业意义的评分 Score，其值域被严格限定在 [-100, 100]。
● 函数定义: Score = norm(x, direction)
  ○ x: 指的是某一只股票在某个因子上的原始计算值。
  ○ direction: 这是一个字符串参数，用于指明该因子的方向性，其取值为 positive 或 negative。
    ■ positive: 表示该因子的原始值越大，我们认为其对股价的未来表现越有利，因此应该得到越高的评分。例如，价格涨幅、均线斜率等。
    ■ negative: 表示该因子的原始值越小，我们认为其越有利，因此应该得到越高的评分。例如，股价波动率。
● 执行步骤 (在每个交易日的股票截面上，对单个因子独立进行):
  a. 计算稳健边界: 对当日股票池中所有股票的某一个因子 x 的数值集合，我们不计算其绝对的最大值和最小值，而是计算其 1%分位数 (P1) 和 99%分位数 (P99)。在金融数据中，极端值是常态，可能源于数据错误、特殊事件或流动性极差的股票。使用百分位数作为边界，可以有效地将这些极端异常值排除在核心区间的计算之外，避免它们对整体评分分布造成不成比例的扭曲。
  b. 数据压缩 (Winsorization): 对每一个原始因子值 x，我们将其与计算出的稳健边界 P1 和 P99 进行比较。如果 x 的值小于 P1，则将其值强制设定为 P1；如果 x 的值大于 P99，则将其值强制设定为 P99。这个过程在统计学上称为“缩尾处理”，其目的是将所有离群值“拉回”到核心数据群体的边缘，从而“钝化”这些极端值对后续线性映射的过度影响。
    ■ 处理后的值 x_prime = max(P1, min(x, P99))
  c. 线性映射至评分区间: 将经过缩尾处理后的值 x_prime，通过一个简单的线性变换，映射到我们预设的 [-100, 100] 评分区间。
    ■ 处理特殊情况: 在极少数情况下，如果一个因子的所有股票取值都完全相同，会导致 P99 小于或等于 P1。为了避免计算中出现分母为零的错误，此时我们将所有股票在该因子上的得分统一设定为 0。
    ■ 根据因子方向进行映射:
      ● 如果 direction 为 positive (值越大，得分越高):
        ○ Score = ( (x_prime - P1) / (P99 - P1) ) * 200 - 100
        ○ 公式解释: 当一个股票的因子值 x_prime 等于 P1 (即在所有股票中表现最差的1%)时，括号内的分式为0，最终得分为-100。当其值等于 P99 (即表现最好的1%)时，分式为1，最终得分为+100。处于中间的值则按比例线性分布在这两者之间。
      ● 如果 direction 为 negative (值越小，得分越高):
        ○ Score = ( (P99 - x_prime) / (P99 - P1) ) * 200 - 100
        ○ 公式解释: 此时分子被反转。当 x_prime 等于 P99 (表现最差)时，分子为0，得分为-100。当 x_prime 等于 P1 (表现最好)时，分子等于分母，得分为+100。

3.2.2 核心函数 f_dynamic(x, t) (动态自适应选股评分函数)
3.2.2.0 导言：从静态到动态的进化
普通的 f(x) 选股函数是一个静态模型，它为所有市场环境应用了同一套固定的因子权重。然而，金融市场的核心特征之一是其周期性和状态切换特性。在牛市、熊市与震荡市中，驱动股票超额收益的因子（Alpha来源）存在显著差异。一个无法适应市场环境变化的静态模型，在穿越牛熊周期的长期回测中，往往表现不佳，尤其是在其不适应的市场阶段（例如，一个动能策略在熊市中会遭遇巨大回撤）。
为了克服这一根本性缺陷，我们将原有的 f(x) 函数全面升级为一个动态自适应选股评分函数，记为 f_dynamic(x, t)。此函数的核心思想是“先看天（判断市场状态），后选股（调整选股偏好）”。它通过引入一个宏观市场状态指标 M(t)，来动态地、平滑地调整不同策略风格（因子维度）的权重，从而让选股模型能够自动适应当前的市场环境。
该函数的整体结构如下：
f_dynamic(x, t) = Σ_i [ N_i(M(t)) * Score_i(x) ]
其中：
● x: 代表单只股票的因子数据向量。
● t: 代表当前交易日。
● M(t): 市场状态函数，输出一个[-1, +1]的连续值，量化市场的牛熊程度。
● Score_i(x): 第 i 个策略维度的评分函数。我们共设立四个策略维度，分别代表趋势动能 (MT)、强势突破 (BO)、均值回归 (MR) 和 质量防御 (QD)。
● N_i(M(t)): 第 i 个策略维度的动态权重函数。它根据 M(t) 的值，决定了 Score_i 在最终总分中的重要性。所有 N_i 的和恒为1。
下面，我们将对该函数的三个核心组件——M(t)、N_i(M(t)) 和 Score_i(x)——进行详细定义。
3.2.2.1 市场状态函数 M(t) (Market Regime Indicator)
M(t) 是策略的“眼睛”，其目的是通过量化分析全市场的日线行情数据，得出一个描述当前市场整体牛熊状态的连续指标。
● 定义: M(t) 是一个在每个交易日 t 计算的、取值范围在 [-1, +1] 的标量。+1代表极端牛市，-1代表极端熊市，0代表中性的震荡市。
● 计算步骤:
  a. 确定计算域 U_M(t): 在交易日 t，选取符合以下条件的A股股票构成“市场通用股票池” U_M(t)：
    ■ 非ST、*ST股票。
    ■ 上市交易日 >= 60个交易日。
    ■ 过去20个交易日日均成交额 > 1亿元人民币。
    ■ 当日非停牌。
  b. 计算基础市场指标: 基于 U_M(t)，计算以下四个维度的市场指标：
    ■ M1(t): 创60日新高占比 (宽度)
      ● 公式: Count(stock where Close_t = MAX(Close_{t-59:t})) / TotalCount(U_M(t))
    ■ M2(t): MA60之上占比 (宽度)
      ● 公式: Count(stock where Close_t > MA60_t) / TotalCount(U_M(t))
    ■ M3(t): 60日回报率中位数 (动能)
      ● 公式: Median( (Close_t / Close_{t-60} - 1) for stock in U_M(t) )
    ■ M4(t): 20日平均波动率 (风险偏好)
      ● 公式: Average( StdDev(DailyReturn_{t-19:t}) for stock in U_M(t) )
  c. 指标时间序列标准化: 对每个指标 Mi(t)，使用其过去3年（约750个交易日）的历史数据作为参照系，将其当前值标准化到 [-1, +1] 区间。
    ■ 函数 norm_timeseries(value, history_series, direction):
      ● P1 = Percentile(history_series, 1)
      ● P99 = Percentile(history_series, 99)
      ● value_prime = max(P1, min(value, P99))
      ● 若 direction 为 positive (M1, M2, M3): norm_value = ( (value_prime - P1) / (P99 - P1) ) * 2 - 1
      ● 若 direction 为 negative (M4): norm_value = ( (P99 - value_prime) / (P99 - P1) ) * 2 - 1
    ■ 得到标准化指标: M1_norm(t), M2_norm(t), M3_norm(t), M4_norm(t)。
  d. 加权合成为最终 M(t):
    ■ 公式: M(t) = w_m1*M1_norm + w_m2*M2_norm + w_m3*M3_norm + w_m4*M4_norm
    ■ 参数定义:
      ● w_m1, w_m2, w_m3, w_m4: 各基础指标的权重，和为1。它们是策略的超参数，反映了我们对不同维度信息的重视程度。
      ● 初始建议值: w_m1=0.3, w_m2=0.3, w_m3=0.25, w_m4=0.15。
3.2.2.2 动态维度权重函数 N_i(M(t)) (Dynamic Dimension Weights)
N_i(M(t)) 是策略的“大脑中枢”，它根据 M(t) 的判断，决定将多少注意力（权重）分配给四种不同的选股策略。我们采用 Softmax 函数机制来实现权重的平滑、动态分配。
● 定义: N_i(M(t)) 是策略维度 i 在市场状态 M(t) 下的权重，满足 Σ N_i(M(t)) = 1 且 N_i(M(t)) >= 0。
● 计算步骤:
  a. 定义各维度吸引力函数 A_i(M(t)):
    ■ 趋势动能 A_MT(M(t)): c_MT * M(t)
    ■ 强势突破 A_BO(M(t)): c_BO * M(t)
    ■ 质量防御 A_QD(M(t)): c_QD * (-M(t))
    ■ 均值回归 A_MR(M(t)): c_MR * exp( - (M(t) / σ_MR)^2 )
  b. 通过Softmax函数计算最终权重:
    ■ 公式: N_i(M(t)) = exp(A_i(M(t)) / τ) / [ Σ_j exp(A_j(M(t)) / τ) ]
    ■ j 遍历所有四个维度 {MT, BO, QD, MR}。
● 参数定义:
  ○ c_MT, c_BO, c_QD, c_MR: 各吸引力函数的强度系数，均为正数。用于调节各策略维度的基础吸引力。初始可设为1。
  ○ σ_MR: 均值回归策略适用范围的宽度参数。值越小，适用范围越窄。初始可设为0.3。
  ○ τ (tau): 温度系数，大于0。控制策略切换的灵敏度。值越小，切换越果断；值越大，切换越平滑。初始可设为0.5。
3.2.2.3 策略维度评分函数 Score_i(x) (Strategy Dimension Scores)
Score_i(x) 是具体的选股执行单元。每个 Score 函数都是一个独立的、小型的多因子模型，旨在从特定策略风格的角度，为股票 x 打分。所有因子计算后，都需通过 3.2.1 节定义的 norm(x, direction) 函数进行标准化处理。
● 总公式: Score_i(x) = Σ_j [ k_ij * norm(x_ij, direction_j) ]
  ○ k_ij: 维度 i 内部，第 j 个因子的权重，需满足 Σ_j k_ij = 1。
A. 趋势动能维度 (Score_MT)
● 目标: 捕捉稳健的上升趋势。
● 公式: Score_MT = k_MT1*norm(x_MT1) + k_MT2*norm(x_MT2) + k_MT3*norm(x_MT3)
● 因子定义: 
因子代码	因子名称	计算逻辑	方向
MA20_SLOPE	20日均线斜率	对过去20日的MA20值进行一元线性回归，取其斜率。	positive
MA_SCORE	均线排列评分	(Close>MA5?1:0) + (MA5>MA10?1:0) + (MA10>MA20?1:0)	positive
ADX_CONFIRM	ADX趋势确认	ADX(14)>20 且 +DI(14)>-DI(14) 时，取 ADX(14)，否则为0。	positive
B. 强势突破维度 (Score_BO)
● 目标: 识别即将进入主升浪的爆发性股票。
● 公式: Score_BO = k_BO1*norm(x_BO1) + k_BO2*norm(x_BO2) + k_BO3*norm(x_BO3)
● 因子定义:
因子代码	因子名称	计算逻辑	方向
BREAKOUT_PWR	突破强度	(Close_t - MAX(Close_{t-60:t-1})) / ATR_14_t	positive
VOLUME_SURGE	成交量激增	Volume_t / Average(Volume_{t-20:t-1})	positive
MOM_ACCEL	动能加速度	ROC(5)_t / ROC(5)_{t-10} - 1	positive
C. 均值回归维度 (Score_MR)
● 目标: 寻找短期超跌、有望反弹的股票。
● 公式: Score_MR = k_MR1*norm(x_MR1) + k_MR2*norm(x_MR2) + k_MR3*norm(x_MR3)
● 因子定义: 
因子代码	因子名称	计算逻辑	方向
RSI_OS	短期超卖	14日相对强弱指数 RSI(14)。	negative
NEG_DEV	负向偏离度	(Close_t - MA60_t) / MA60_t	negative
BOLL_LB	布林下轨支撑	(Close_t - LowerBand) / (UpperBand - LowerBand)	negative
D. 质量防御维度 (Score_QD)
● 目标: 筛选熊市中抗跌、稳健的避险品种。
● 公式: Score_QD = k_QD1*norm(x_QD1) + k_QD2*norm(x_QD2) + k_QD3*norm(x_QD3)
● 因子定义: 
因子代码	因子名称	计算逻辑	方向
LOW_VOL	低波动率	最近20日日收益率的标准差。	negative
MAX_DD	最大回撤控制	最近60日内的最大回撤 (Peak-Trough)/Peak。	negative
DOWNSIDE_RISK	下行风险	最近60日中，所有负收益率的标准差（半方差）。	negative
3.2.2.4 最终得分计算与总结
在T-1日收盘后，对初步筛选后的股票池中的每一只股票 x，其最终的综合得分计算如下：
1. 计算当日的市场状态值 M(t)。
2. 根据 M(t) 计算出四个动态权重 N_MT, N_BO, N_MR, N_QD。
3. 对股票 x，分别计算其在四个策略维度下的得分 Score_MT, Score_BO, Score_MR, Score_QD。
4. 计算最终总分: f_dynamic(x, t) = N_MT * Score_MT + N_BO * Score_BO + N_MR * Score_MR + N_QD * Score_QD
这个 f_dynamic 得分将作为后续排序和生成“次日观察池”的依据。通过这一系统性的升级，策略的选股逻辑从一个僵化的标尺，演变为一个能够根据市场风向智能调整的、多维度的动态评估体系，旨在显著提升策略在不同市场环境下的适应性和长期稳健性。
● 注: 在此评分函数中，所有使用的 norm 函数即为 3.2.1节 中详细定义的标准化函数。所有的因子权重 k_i 和维度权重 w_dim 均为正数，因为因子的正负向关系已经在 norm 函数内部通过 direction 参数得到了妥善处理。

3.3 盘前校准与预案修正模块 
● 职责: 在T日开盘前，根据官方发布的除权除息信息，对所有在途的交易计划和持仓风控价格进行精确的数学调整，并剔除高风险的配股事件。
● 执行时段: T日 08:30:00 - 09:00:00
● 执行流程: 
  a. 获取除权除息信息: 在T日早上（例如8:30），通过数据接口获取当日（以除权除息日为准）所有A股的股权登记变更信息，包括但不限于：现金分红（除息）、送股、转增股（除权）、配股。 
  b. 价格校准核心算法: 对每一个受影响的股票，根据其T-1日的不复权收盘价 Close_T-1 和事件详情，计算出其理论上的除权除息参考价 Adjusted_Close_T-1。
    ■ 现金分红 (除息): 
      ● Adjusted_Close_T-1 = Close_T-1 - Dividend_Per_Share 
      ● (其中 Dividend_Per_Share 为每股税前派息额)
    ■ 送股/转增股/并股/拆股 (除权): 
      ● Adjusted_Close_T-1 = Close_T-1 * (share_before)/ (share_after)
      ●  参数说明:
        ○ share_before: 送股/转增股/并股/拆股前的值
        ○ share_after: 送股/转增股/并股/拆股后的值
      ● 示例：
        ○ 10赠3，则share_before=10，share_after=13
        ○ 10合1，则share_before=10，share_after=1
    ■ 配股 : 
      ● Adjusted_Close_T-1 = (share_before * Close_T-1 + (share_after - share_before) * rights_issue_price) / share_after
      ● 参数说明:
        ○ share_before: 配股前的基准股数。
        ○ share_after: 配股后的总股数。
        ○ rights_issue_price: 配股价格，即参与配股时每股的认购价格
      ● 示例：
        ○ 10配3，配股价8元，则share_before=10，share_after=13，right _issue_price=8
      ● 注意事项：
        ○ 对于涉及配股的股票，应被放弃购入或立刻售出，因此目前该计算不会被实际运行
    ■ 复合事件: 
      ● 若同时发生多种事件，则按顺序依次计算：
        ○ Step 1: 
          ■ 计算除息后价格
        ○ Step 2: 
          ■ 在除息后价格基础上，计算送/转股后价格
        ○ Step 3: 
          ■ 在第二次调整后价格基础上，计算配股后最终参考价 
      ● 注意事项：
        ○ 对于涉及配股的股票，应被放弃购入或立刻售出，因此Step3不会被实际运行
  c. 修正交易预案: 
    ■ 遍历“次日观察池”中的每一支股票。 
    ■ 若某股票今日有除权除息事件，则其在T-1日计算的MIOP和MAOP已经失效。我们需计算一个价格调整比率 (Price Adjustment Ratio) 来校准它们。： 
      ● 价格调整比率: 
        ○ Ratio = Adjusted_Close_T-1 / Close_T-1
      ● 基于此比率，对预设的开盘价区间进行等比例缩放：
        ○ MIOP_new = MIOP_old * Ratio
        ○ MAOP_new = MAOP_old * Ratio 
    ■ 将数据库中对应记录的MIOP和MAOP更新为新值。 
  d. 修正持仓风控: 
    ■ 遍历所有“持仓中”的股票。 
    ■ 若某持仓股今日有除权除息事件，其基于历史成本价AEP计算的止盈止损位也已失效，也必须进行等比例调整，以维持原有的盈亏比设定：
      ● 价格调整比率: 
        ○ Ratio = Adjusted_Close_T-1 / Close_T-1 
      ● 基于此比率，对预设的止盈止损区间进行等比例缩放：
        ○ Take_Profit_Price_new = Take_Profit_Price_old * Ratio 
        ○ Stop_Loss_Price_new = Stop_Loss_Price_old * Ratio 
    ■ 将数据库中对应持仓的止盈价和止损价更新为新值。 
  e. 配股事件特殊处理: 
    ■ 对于交易预案: 对于开盘前或30日内发生过配股的股票，应该使其不会被开盘决策与下单模块选中，将最高可接受开盘价（MAOP）置为0，最低可接受开盘价（MIOP）置为99999。 
    ■ 对于持仓: 若发现某持仓股T日为配股除权日，这构成了策略的紧急退出条件。系统应为其止盈价置为0，止损价置为99999。
3.4 开盘决策与下单模块
● 职责: 在T日开盘后的黄金几分钟内，基于T-1日制定的严谨预案，做出最终的、唯一的买入决策，并高效、可靠地完成下单操作。
● 执行时段: T日 09:25:01 - 09:30:00
● 执行流程:
  a. 加载预案: 模块在09:25准时启动，第一件事就是从持久化存储中（JSON文件或数据库）加载T-1日晚间生成的“次日观察池”以及其中每只股票对应的MIOP和MAOP。
  b. 获取开盘价: 在09:25集合竞价结果产生后，系统立即通过 akshare 的实时行情接口，批量获取观察池中所有股票的实际开盘价 (Open_T)。
  c. 最终筛选: 遍历观察池中的10支股票，对每一支都执行开盘价验证。只有当某支股票的实际开盘价 Open_T 同时满足以下两个条件时，它才能进入最终的候选名单：
    ■ Open_T >= MIOP  并且  Open_T <= MAOP
    ■ 这个双边过滤条件是本策略风险控制体系中至关重要的一道防线。它既能有效避免在市场情绪过热时追高，也能防止买入那些因未知重大利空而大幅低开的“问题股”。
  d. 唯一标的选择:
    ■ 情况一: 如果经过上述筛选后，最终的候选名单为空，这意味着当日市场的开盘情况不符合本策略为任何一支候选股设定的入场条件。此时，系统将放弃今日所有的买入操作，并生成一条“无合适买点”的日志。这并非策略的失败，而是一种内化的、主动的市场风险规避机制。随后，本模块执行结束。
    ■ 情况二: 如果最终候选名单中包含一支或多支股票，系统将遵循“优中选优”的原则，选择其中在T-1日计算出的 f(x) 综合得分最高的那一支，作为今日的唯一买入目标。
  e. 仓位计算:
    ■ 单笔名义本金 (Nominal Principal, NP): 我们的策略采用等名义本金的仓位管理方法。计算公式为：NP = 当前账户总资产 / 预设的最大持仓股票数量。例如，若总资产为50000元，计划最多同时持有5支股票，则单笔名义本金为10000元。
    ■ 计划买入股数 (Shares to Buy, StB): 根据名义本金和目标股票的开盘价，计算出理论上可以购买的股数，并向下取整到100的倍数，因为A股市场的最低交易单位为1手，即100股。
      ● StB = floor( (NP / Open_T) / 100 ) * 100
  f. 下单执行:
    ■ 为了在开盘后价格可能快速波动的几分钟内，最大限度地提高订单的成交概率，避免因微小的价格跳动而导致订单失效（废单），我们设置一个微小的价格滑点缓冲区。
    ■ 下单限价 (Limit Price):
      ● Limit_Price = Open_T * (1 + k_slip)
      ● k_slip: 这是一个下单滑点系数，是一个微小的正值，例如 0.003。这意味着我们愿意以比开盘价最高上浮0.3%的价格提交限价单，以此来“抢”到成交机会。这个系数也是一个可以优化的参数。
    ■ 系统通过 easytrader 库，将计算出的 Limit_Price 和 StB 封装成一个限价买入单 (Limit Order)，并发送给券商的交易服务器。
  g. 交易后处理:
    ■ 下单后，系统需要通过轮询查询订单状态的API，来确认订单的成交情况。一旦订单被确认为完全成交，系统必须立即记录下这笔交易的实际成交均价 (Actual Execution Price, AEP) 和实际成交股数。
    ■ 关键一步: 在获取到 AEP 的一瞬间，系统必须立即调用风控函数 g(y) 和 h(z)，基于这个真实的、分毫不差的成本价，为这笔新建立的持仓计算出其初始的止盈价和止损价。
    ■ 最后，将这笔持仓的完整信息（包括股票代码、持仓成本AEP、持仓股数、初始止盈价、初始止损价、持仓状态等）存入一个专门的持仓管理数据库表中，并激活“盘中持仓监控与退出模块”对这笔新仓位进行监控。
    ■ 如果买入指令因流动性问题（如开盘后迅速涨停）在15分钟内未能成交并被撤单，进行以下策略：
      ● 撤单后，系统应立即依次顺位检查最终候选名单中排名在次一位的股票，看其当前价格是否仍在MIOP/MAOP区间内，若是，则尝试买入次位优选
3.5 盘中持仓监控与退出模块
● 职责: 作为策略纪律的忠实守护者，以机器的精准和不知疲倦，严格、实时地执行所有已建立持仓的退出策略。
● 执行时段: T日 09:30:00 - 14:57:00。在收盘集合竞价前几分钟停止监控和交易，以避免尾盘阶段的异常波动和流动性问题。
● 执行流程 (本地轮询):
  a. 加载持仓: 模块启动时，首先从持仓管理数据库中查询所有状态为“持仓中”的股票，并加载它们的所有相关信息，特别是不复权的止盈价和止损价。
  b. 循环监控: 系统以一个设定的频率（例如每3秒）执行一次完整的监控循环。
    ■ 通过 akshare 的实时行情接口，批量获取所有持仓股票的最新不复权实时价格 (Current Price)。
    ■ 遍历持仓列表，对每一只股票，将其 Current Price 与其预设的退出边界进行比较，执行退出条件判断：
      ● 止损检查: if Current_Price <= Stop_Loss_Price
        ○ 一旦条件满足，系统会立即触发最高优先级的操作：通过 easytrader 以市价单发出卖出指令。止损是风险控制的底线，必须以最快的速度、不计较微小价差地保证成交。
      ● 止盈检查: elif Current_Price >= Take_Profit_Price
        ○ 一旦条件满足，系统同样会立即通过 easytrader 以市价单发出卖出指令，锁定利润。
  c. 状态更新: 任何一只股票的卖出订单一旦被确认成交，系统必须立即执行一系列状态更新操作：在持仓数据库中将该股票的状态从“持仓中”更新为“已平仓”；详细记录交易日志，包括卖出原因（止损或止盈）、确切的卖出时间和价格、以及这笔交易的最终盈亏；最后，将这只已平仓的股票从当前的实时监控列表中移除，以减少后续轮询的API请求负担和计算量。
3.5.1 核心函数：动态止盈与自适应止损
● 动态止盈价 g(y): 我们的止盈目标不是一个僵化的固定百分比，而是能够根据股票自身的波动特性进行动态调整的。
  ○ 止盈涨幅 (Profit Margin):
    ■ Profit_Margin = min( Base_Target + k_g1 * (ATR_14_buy / AEP), Max_Target )
  ○ 最终止盈价 (Take Profit Price):
    ■ Take_Profit_Price = AEP * (1 + Profit_Margin)
  ○ 变量定义:
    ■ AEP: 实际成交均价。这是所有后续风控计算的唯一、坚实的基石。
    ■ Base_Target: 基础止盈目标。这是一个固定的百分比，例如 0.05，代表了我们对任何一笔交易最低的盈利预期。
    ■ ATR_14_buy: 买入当日的14日ATR值。这个值反映了我们买入这只股票时，它近期的市场波动水平。
    ■ k_g1: ATR溢价乘数。这是一个可优化的参数，例如 1.5。其背后的逻辑是：波动性越大的股票，其价格的正常日内波动范围也越大，因此我们的止盈目标也应该设置得更宽，给予利润更多“奔跑”的空间，避免被正常的市场噪音提前洗出。
    ■ Max_Target: 最大止盈目标。这是一个固定的百分比上限，例如 0.20。它的作用是在市场出现极端连续上涨的“主升浪”行情时，强制锁定大部分利润，防止因人性的贪婪而错失最佳卖点，导致利润大幅回吐。
● 自适应止损价 h(z): 这是对传统固定ATR止损的重大改进，旨在解决其在震荡市中容易被反复触发的问题。我们引入了市场状态判断，让止损策略能够“智能化”地适应不同的市场环境。
  ○ 第一步：实时判断市场状态 (Regime Filter)
    ■ 在盘中监控持仓股时，系统会实时计算该股票当前的 ADX(14) 指标值。ADX是衡量趋势强弱的经典指标。
    ■ IF ADX(14) > 20: 我们判定当前市场处于趋势状态。在这种状态下，价格的波动可能是单向且持续的，我们应该采用更灵敏的止损来紧跟趋势，保护已有利润。
    ■ ELSE (ADX(14) <= 20): 我们判定当前市场处于震荡或无趋势状态。在这种状态下，价格容易在一定区间内反复拉锯，小幅的波动不代表趋势的改变。因此，我们应该采用更宽松的止损，以避免被无意义的市场噪音轻易“洗出局”。
  ○ 第二步：根据市场状态选择差异化的止损策略
    ■ 最终的止损价将是多重防线中的最高者（即最严格的那个）。
    ■ Stop_Loss_Price = max(z_final, z2, z3)
    ■ 其中，核心的波动率止损线 z_final 是根据市场状态动态选择的：
      ● z_final = z_1_trend  如果 ADX(14) > 20 (趋势状态)
      ● z_final = z_1_range  如果 ADX(14) <= 20 (震荡状态)
  ○ 各条止损线的具体定义:
    ■ z_1_trend: 趋势市波动止损线。采用一个相对较窄的ATR乘数，以便在趋势反转时能够快速反应。
      ● z_1_trend = AEP - k_h1 * ATR_14_buy
    ■ z_1_range: 震荡市波动止损线。采用一个明显更宽的ATR乘数，给予价格在震荡区间内更多的缓冲空间，容忍更大的正常回撤。
      ● z_1_range = AEP - k_h2 * ATR_14_buy
    ■ z2: 技术位止损线。取值为买入当日的20日移动平均线价格（不复权）。MA20通常被视作中期趋势的生命线，一旦价格跌破这个位置，往往意味着中期上升趋势可能已经遭到破坏。
    ■ z3: 最大容忍度止损线。这是我们风险控制的最后一道、也是最坚固的防线。无论市场状态如何，技术指标如何变化，任何一笔交易的最大亏损都绝不能超过这个预设的极限。
      ● z3 = AEP * (1 - Max_Loss_Percent)
  ○ 变量定义:
    ■ k_h1: 趋势市ATR止损乘数，一个可优化的参数，例如 2.0。
    ■ k_h2: 震荡市ATR止损乘数，一个可优化的参数，其值必须大于k_h1，例如 3.0。
    ■ Max_Loss_Percent: 最大回撤容忍度，一个绝对的亏损百分比上限，例如 0.08，即我们能接受的单笔最大亏损为8%。
3.6 回测与优化模块
● 职责: 在一个完全隔离的离线环境中，通过对历史数据进行高保真的模拟交易，系统性地评估策略的过往表现，并科学地提升其未来的盈利潜力。
● 核心原则:
  ○ 数据基准统一: 这是保证回测结果有意义的基石。所有用于计算技术指标（如MA, ADX）和因子的数据，必须是后复权价格，以保证价格序列的连续性。而所有用于模拟交易撮合的环节，例如开盘价的比较、盘中止盈止损的触发，都必须使用不复权价格，因为这才是真实市场中交易发生的价格。
  ○ 亏损优先原则: 在模拟每一天的交易时，系统会检查当日的最高价和最低价。如果某一天的K线范围同时向上触及了预设的止盈价，并且向下触及了预设的止损价，系统将一律按照触发止损价进行结算。这是对策略在最不利情况下的压力测试，能够有效避免高估策略的胜率和盈亏比。
  ○ 成本与滑点精确模拟:
    ■ 交易成本: 必须完整地、精确地计算每一笔模拟交易的成本。这包括买入佣金（费率通常为万分之2.5，但必须考虑最低5元的收费标准，这对小额交易影响巨大）、卖出佣金，以及卖出时征收的印花税（目前为千分之一）。
    ■ 买入滑点: 模拟的买入成交价不应理想化地设为开盘价，而应设为 min(Limit_Price, High_Price_of_the_day)。这模拟了我们的限价单在真实市场中可能无法立即成交，而是在当日稍晚的更高价格成交的情况。
    ■ 卖出滑点: 模拟的卖出成交价不应理想化地设为触发价，而应设为 触发价 * (1 - 0.001)。这模拟了市价单在卖出时，因为消耗了市场流动性而导致的微小不利成交差价，即冲击成本。
  ○ 模拟除权除息:
    ■ 在进入T日的模拟循环时，首先查询本地的股权事件表，获取在T日发生除权除息事件的股票列表。 
    ■ 严格按照3.3模块中定义的策略，对模拟环境中所有受影响的持仓和交易预案的相应价格（止盈止损、MIOP/MAOP）进行调整。 
    ■ 模拟对配股事件的特殊处理：从当日的交易预案中移除相关股票，并对持仓中的相关股票在开盘时以模拟开盘价执行强制卖出。 
3.6.1 参数优化策略：迭代式单参数优化
此方法旨在通过一种简单、直观、计算成本可控的方式，系统性地寻找一组能够提升策略表现的优良参数组合。它避免了在参数众多时，使用网格搜索等方法带来的“维度灾难”和巨大的时间开销。
● 执行流程:
  a. 数据准备与划分:
    ■ 训练集: 用于进行参数优化的历史数据区间。例如，我们可以使用 2024年1月1日至2024年12月31日 的全年数据。
    ■ 验证集: 用于检验优化后参数组合泛化能力的历史数据区间，这个区间必须与训练集完全独立。例如，我们可以使用 2023年1月1日至2023年12月31日 的全年数据。使用未来数据做训练，过去数据做验证，是一种更为严格、更能考验策略稳健性的时间序列交叉验证方法。
  b. 设定初始参数:
    ■ 为模型中所有可调节的参数（包括维度权重 w_trend, w_momentum, w_quality；因子权重 k1 到 k8；开盘价区间系数 k_drop, k_gap；止盈系数 k_g1；止损系数 k_h1, k_h2；以及最大亏损比例 Max_Loss_Percent 等）设定一组合理的初始值。这些初始值可以基于行业经验，或者可以借助大语言模型（如Gemini）的知识库，生成一个符合逻辑的起点。
  c. 迭代优化循环:
    ■ 选择一个参数: 从待优化的参数列表中，选择第一个参数，例如 k1。
    ■ 设定基准表现: 使用当前完整的一套参数，在训练集（2024年数据）上完整地运行一次回测，记录下我们最关心的关键绩效指标，例如夏普比率或卡玛比率（年化收益/最大回撤）。我们将这个值记录为基准表现 KPI_base。
    ■ 微调与测试:
      ● 正向尝试: 将 k1 的值增加一个预设的、微小的步长（例如，k1_new = k1 * 1.01），而其他所有参数保持不变。用这套新参数重新运行一次回测，得到新的绩效指标 KPI_positive。
      ● 负向尝试: 将 k1 的值减少一个微小的步长（例如，k1_new = k1 * 0.99），其他参数保持不变。再次运行回测，得到 KPI_negative。
    ■ 决策与更新:
      ● 如果 KPI_positive 大于 KPI_base，并且也大于 KPI_negative，那么我们就接受这个正向的改变，将 k1 的值更新为增加后的新值。然后，我们可以在这个新值的基础上，继续尝试增加，直到KPI不再提升为止，从而找到 k1 在当前参数组合下的一个“局部最优值”。
      ● 如果 KPI_negative 大于 KPI_base，并且也大于 KPI_positive，我们就接受这个负向的改变，更新 k1 的值，并继续尝试减少，直至找到局部最优点。
      ● 如果 KPI_base 是三者中最大的，那么说明在当前位置，k1 的初始值就是最好的，我们保持其值不变。
    ■ 遍历所有参数: 对列表中的下一个参数（例如 k2）重复上述“微调-测试-更新”的完整步骤。当列表中的所有参数都完成了这样一轮优化后，我们称之为完成了一次“大循环”。
  d. 收敛或终止: 我们可以重复进行多轮这样的大循环。当出现一整轮大循环下来，没有任何一个参数的值发生变化时，我们认为参数组合已经收敛。或者，我们也可以设定一个最大的循环次数（例如10次）作为终止条件。
  e. 最终验证: 将在训练集上优化得到的这套最终参数组合，应用到验证集（2023年数据）上，进行一次完全独立的回测。这是对策略未来表现的“模拟考”。如果其在验证集上的表现依然稳健，例如夏普比率、最大回撤等核心指标没有出现大幅度的劣化，那么我们就更有信心认为这组参数具备良好的泛化能力，可以考虑将其部署到实盘交易中。
● 局限性与未来展望:
  ○ 局限性: 这种迭代式单参数优化的主要缺点是它无法捕捉到参数之间的交互效应。例如，最优的止损系数 k_h1 的取值，可能本身就依赖于止盈系数 k_g1 的取值。因此，该方法容易陷入局部最优点，而不一定是全局最优解。
  ○ 未来展望: 当系统运行稳定，并且我们有更强的计算资源时，可以引入更先进的、能够处理多维参数空间的优化算法。例如网格搜索、随机搜索，乃至更高效的贝叶斯优化（可以借助 Optuna, Hyperopt 等专业的Python库来实现），以期找到更优的参数组合。
4. 核心：复权处理与价格体系
为确保从历史研究到实时交易的每一个环节都无缝衔接，避免因价格口径不一而导致的逻辑错误，本系统建立了一套清晰、无歧义的价格转换与使用流程，贯穿整个交易生命周期：
环节	核心动作	使用价格类型	目的与理由
1. 历史分析 (T-1)	计算所有技术指标和因子 (f(x))	后复权价 (hfq_close)	保证指标计算的数学连续性与经济意义的准确性，彻底消除股票除权除息事件对价格序列造成的伪信号和断层。
2. 生成预案 (T-1)	计算开盘价区间 (MIOP, MAOP)	不复权价 (Close)	MIOP和MAOP是为次日的真实开盘价设定的边界，因此必须使用与开盘价相同的口径，即不复权收盘价作为计算基准。
3. 开盘决策 (T)	比较 Open_T 与 MIOP/MAOP	不复权价 (Open)	直接与交易所发布的、所有市场参与者都能看到的真实集合竞价结果进行匹配，确保决策的现实有效性。
4. 下单执行 (T)	计算下单限价 Limit_Price	不复权价 (Open)	向券商交易系统发送的任何交易指令，其价格都必须是当前市场正在交易的、不复权的真实价格。
5. 风控设定 (T)	基于AEP计算TP和SL	不复权价 (AEP)	所有风险控制的目标，无论是止盈还是止损，都必须基于我们真实的、不复权的持仓成本价。这是计算真实盈亏的唯一基准。
6. 盘中监控 (T)	比较Current_Price与TP/SL	不复权价 (Real-time)	与交易所通过行情接口实时推送的、正在发生交易的最新成交价进行比对，以触发平仓指令。
5. 部署与执行计划
1. 阶段一: 系统基建与回测 (1-2个月)
  ○ 任务清单: 完成四个核心模块的Python代码开发与详尽的单元测试；搭建并初始化本地历史数据库，编写并验证数据获取和清洗脚本；严格按照3.5节定义的原则和流程，完成参数的初步优化和严格的样本外验证，确定第一版可用于实盘的参数组合。
2. 阶段二: 模拟盘前向测试 (1个月)
  ○ 任务清单: 将完整的自动化交易系统部署到一台稳定的服务器上（可以是本地主机）；本地记账，进行全流程的、纯记录的模拟交易。
  ○ 核心目的: 此阶段不以盈利为目的，而是对系统的工程稳定性和策略实战性进行最终检验。重点观察：开盘决策模块是否总能按时、准确地执行；API接口在盘中高频请求下是否稳定；真实环境下的网络延迟和交易滑点与回测的差距有多大；策略在当前真实的市场环境下的表现是否符合预期。
3. 阶段三: 小资金实盘 (持续)
  ○ 任务清单: 若模拟盘表现稳定且符合预期，投入初始的5万元真实资金进行实盘交易。
  ○ 核心工作: 严密监控实盘交易的每一个环节，将实盘的成交记录、滑点数据、盈亏情况与回测结果进行细致的对比分析，找出差异并进行归因。同时，定期（例如每季度或每半年）重新运行回测与优化模块，以评估当前参数是否仍然适应可能已经发生变化的市场风格，并决策是否需要对策略参数进行微调。
6. 风险管理与应急预案
● 技术风险:
  ○ 程序中断: 建立详细的分级日志系统（DEBUG, INFO, WARNING, ERROR），记录系统的每一个关键动作。为核心的盘中监控和下单模块增加断线重连和状态恢复机制。例如，程序因故重启后，能够自动从数据库加载当前的持仓和未完成的订单状态，而不是从零开始。
  ○ 下单失败: 所有与 easytrader 相关的交易操作，都必须被包裹在 try...except 异常处理块中。一旦下单失败，系统应记录下详细的失败原因，并立即通过邮件或微信推送等方式发出人工介入警报。
  ○ API接口风险: 准备备用的数据源或行情接口，以应对主接口失效的情况。对API的请求频率进行严格的控制和节流，避免因请求过于频繁而被服务商暂时封禁。
● 策略风险:
  ○ 过拟合风险: 这是所有量化策略的天敌。本方案通过多种手段来最大程度地缓解此风险：采用严格的训练集/验证集划分；在回测中精确模拟成本和滑点；采用悲观的亏损优先原则；以及使用相对稳健的参数优化方法而非暴力拟合。
  ○ 市场制度风险: 策略本身不依赖于特定的市场政策，但需要对交易规则的重大变化保持警惕，例如T+0制度的试点、涨跌停板幅度的调整、印花税的变动等。一旦发生，需要评估其对策略的影响并及时进行调整。
  ○ 黑天鹅事件: 对于无法预测的、极端的小概率事件，任何策略都可能失效。我们能做的，是通过硬性的仓位管理来构建抵御未知风险的最后、也是最坚固的防线。本策略规定，单只股票的仓位绝不超过总资金的20%（即最多同时持有5支股票），并且总仓位上限可设定为80%或90%，始终保留一部分现金。这部分现金不仅能降低整体风险暴露，更能在市场极端下跌、流动性枯竭时，提供宝贵的缓冲和潜在的低吸机会。
  ○ 流动性风险: 若买入的限价单在开盘后15分钟内仍未成交，系统应自动撤单，以避免资金被一个可能永远无法成交的订单无效占用。若在执行卖出指令时，股票不幸遭遇跌停而无法成交，程序应自动改为以跌停价持续挂单，直至成交或当日收盘，并同时发出高优先级警报，提示人工关注。
附录：数据库表结构
1. 基础数据层
1.1. 股票基础信息表 (tb_stock_info)
说明: 存储所有A股股票的基本信息，如代码、名称、上市日期等，作为其他数据表的关联基础。
字段名	字段类型	约束	中文备注
stock_code	VARCHAR(10)	主键, 非空	股票代码, 格式如 'sh.600000'
stock_name	VARCHAR(50)	非空	股票名称
listing_date	DATE	非空	上市日期, 用于剔除次新股
status	VARCHAR(20)	非空	股票状态。枚举: listing(上市), delisted(退市), suspended(停牌)
created_at	DATETIME	非空, 默认当前时间	记录创建时间
updated_at	DATETIME	非空, 默认当前时间	记录更新时间
1.2. 日线行情表 (tb_daily_quotes)
说明: 存储从数据源获取的最原始的日线行情数据，是所有计算的基石。
字段名	字段类型	约束	中文备注
stock_code	VARCHAR(10)	复合主键, 外键(stock_info)	股票代码
trade_date	DATE	复合主键, 非空	交易日期
open	DECIMAL(10, 2)	非空	不复权开盘价
high	DECIMAL(10, 2)	非空	不复权最高价
low	DECIMAL(10, 2)	非空	不复权最低价
close	DECIMAL(10, 2)	非空	不复权收盘价
volume	BIGINT	非空	成交量 (股)
turnover	DECIMAL(20, 2)	非空	成交额 (元)
adjust_factor	DECIMAL(20, 10)	非空	截至当日的后复权因子
hfq_close	计算列 (DECIMAL)	-	(要求1) 后复权收盘价，公式: close * adjust_factor

1.3. 股权事件表 (tb_corporate_actions)
说明: 存储所有影响股价非交易性变动的股权事件，是盘前校准模块和回测引擎的核心数据源。
例子
10送5：event_type='bonus', shares_before=10, shares_after=15
10转3：event_type='transfer', shares_before=10, shares_after=13
10配3，配股价8元：event_type='rights', shares_before=10, shares_after=13, rights_issue_price=8
1拆2：event_type='split', shares_before=1, shares_after=2 (理解为在1股基础上增加1股)
10并1：event_type='split', shares_before=10, shares_after=1 (理解为在10股基础上减少9股)
派1元：event_type='dividend', dividend_per_share=0.1
字段名	字段类型	约束	中文备注
event_id	BIGINT	主键, 自增	事件唯一ID
stock_code	VARCHAR(10)	非空	股票代码, 格式如 'sh.600000'
ex_dividend_date	DATE	非空, 索引	除权除息日 (策略判断的基准日期)
record_date	DATE	-	股权登记日
notice_date	DATE	-	公告日期
event_type	VARCHAR(20)	非空	事件类型。枚举: dividend(分红), bonus(送股), transfer(转股),rights(配股), split(拆股/并股)
dividend_per_share	DECIMAL(10, 4)	-	每股派息(税前, 元，分红专用)
shares_before	DECIMAL(10, 4)	-	基准股数 (如“10送5”，此值为10，送股/转股/拆股/并股专用)
shares_after	DECIMAL(10, 4)		变动股数 (如“10送5”，此值为15，送股/转股/拆股/并股专用)
rights_issue_price	DECIMAL(10, 2)	-	配股价格，配股专用
created_at	DATETIME	非空, 默认当前时间	记录创建时间

2. 因子与参数层 (支持可扩展)
2.1. 因子定义表 (tb_factor_definitions)
说明: (核心设计) 用于定义所有策略中使用的因子，实现因子的可插拔。新增因子只需在此表增加一条记录。
字段名	字段类型	约束	中文备注
factor_code	VARCHAR(50)	主键, 非空	因子唯一英文代码, 如 'MA20_SLOPE'
factor_name	VARCHAR(100)	非空	因子中文名称, 如 '20日均线斜率'
description	TEXT	-	详细描述因子的计算逻辑和业务含义
direction	VARCHAR(10)	非空	因子方向性。枚举: positive(正向, 值越大越好), negative(负向, 值越小越好)
is_active	BOOLEAN	非空, 默认 true	是否启用该因子
2.2. 每日因子值表 (tb_daily_factor_values)
说明: (核心设计) 存储每只股票在每个交易日计算出的所有因子原始值和标准化分值。
字段名	字段类型	约束	中文备注
stock_code	VARCHAR(10)	复合主键, 外键(stock_info)	股票代码
trade_date	DATE	复合主键, 非空	交易日期
factor_code	VARCHAR(50)	复合主键, 外键(factor_definitions)	因子代码
raw_value	DECIMAL(20, 10)	非空	因子计算出的原始值
norm_score	DECIMAL(10, 4)	-	经过norm()函数标准化后的分值 (-100到100)
2.3. 策略参数表 (tb_strategy_parameters)
说明: 存储所有策略中可优化的参数，如权重、系数等，方便回测与优化模块进行读取和修改。
字段名	字段类型	约束	中文备注
param_name	VARCHAR(50)	主键, 非空	参数唯一英文名, 如 'w_trend', 'k_h1'
param_value	DECIMAL(20, 10)	非空	参数的数值
group_name	VARCHAR(50)	-	参数所属分组, 如 'WEIGHTS', 'STOP_LOSS'
description	TEXT	-	参数的详细说明

3. 策略执行与交易层
3.1. 每日交易预案表 (tb_daily_trading_plan)
说明: 存储 T-1 日终选股模块生成的“次日观察池”及相关交易预案。
字段名	字段类型	约束	中文备注
plan_date	DATE	复合主键, 非空	预案执行日期 (T日)
stock_code	VARCHAR(10)	复合主键, 外键(stock_info)	候选股票代码
rank	INT	非空	综合得分排名 (1-10)
final_score	DECIMAL(10, 4)	非空	f(x)选股综合得分
miop	DECIMAL(10, 2)	非空	最低可接受开盘价 (Minimum Acceptable Open Price)
maop	DECIMAL(10, 2)	非空	最高可接受开盘价 (Maximum Acceptable Open Price)
status	VARCHAR(20)	非空, 默认 'pending'	预案状态。枚举: pending(待执行), executed(已执行买入), cancelled(当日未满足条件作废)
3.2. 持仓信息表 (tb_positions)
说明: 存储当前所有持仓的详细信息，是盘中监控模块的核心数据依据。
字段名	字段类型	约束	中文备注
position_id	BIGINT	主键, 自增	持仓唯一ID
stock_code	VARCHAR(10)	非空, 外键(stock_info)	股票代码
entry_datetime	DATETIME	非空	建仓成交时间
entry_price	DECIMAL(10, 2)	非空	实际成交均价 (AEP)
quantity	BIGINT	非空	持仓数量 (股)
current_stop_loss	DECIMAL(10, 2)	非空	当前止损价
current_take_profit	DECIMAL(10, 2)	非空	当前止盈价
status	VARCHAR(20)	非空, 默认 'open'	持仓状态。枚举: open(持仓中), closed(已平仓)
3.3. 交易记录表 (tb_trade_log)
说明: 记录每一次买入和卖出的详细信息，用于成本核算、业绩分析和问题排查。
字段名	字段类型	约束	中文备注
trade_id	BIGINT	主键, 自增	交易唯一ID
position_id	BIGINT	外键(positions)	关联的持仓ID (买入时生成, 卖出时引用)
stock_code	VARCHAR(10)	非空, 外键(stock_info)	股票代码
trade_datetime	DATETIME	非空	交易成交时间
trade_type	VARCHAR(10)	非空	交易类型。枚举: buy(买入), sell(卖出)
order_type	VARCHAR(10)	非空	订单类型。枚举: limit(限价), market(市价)
price	DECIMAL(10, 2)	非空	成交均价
quantity	BIGINT	非空	成交数量
commission	DECIMAL(10, 2)	非空	佣金
stamp_duty	DECIMAL(10, 2)	非空, 默认 0	印花税 (仅卖出时有)
reason	VARCHAR(50)	-	交易原因。枚举: entry(策略入场), take_profit(止盈), stop_loss(止损), manual(人工干预)
status	VARCHAR(20)	非空	订单状态。枚举: filled(已成交), failed(失败), cancelled(已撤销), pending(待执行)
external_order_id	VARCHAR(50)	可空	外部交易系统的订单ID，如券商的委托编号

4. 系统监控与日志层
4.1. 系统日志表 (tb_system_log)
说明: 记录系统运行过程中的关键信息、警告和错误，便于监控和调试。
字段名	字段类型	约束	中文备注
log_id	BIGINT	主键, 自增	日志唯一ID
log_time	DATETIME	非空, 默认当前时间	日志记录时间
log_level	VARCHAR(10)	非空	日志级别。枚举: INFO, WARNING, ERROR, CRITICAL
module_name	VARCHAR(50)	-	产生日志的模块名, 如 '日终选股', '开盘决策'
message	TEXT	非空	日志内容, 如 '无合适买点', '下单API请求失败'

全量代码为：
======= 项目文件树 =======

📂 ./
    📄 config.json
    📄 mainDB.sqlite3
    📄 manage.py
    📄 requirements.txt
    📄 trade_report.html
    📄 user.json
    📄 提取日志.py
    📄 资金变化图.png
    📂 autoTrade/
        📄 __init__.py
        📄 asgi.py
        📄 settings.py
        📄 urls.py
        📄 wsgi.py
    📂 common/
        📄 __init__.py
        📄 admin.py
        📄 apps.py
        📄 config_loader.py
        📄 tests.py
        📄 views.py
        📂 models/
            📄 __init__.py
            📄 corporate_action.py
            📄 daily_factor_values.py
            📄 daily_quotes.py
            📄 daily_trading_plan.py
            📄 factor_definitions.py
            📄 positions.py
            📄 stock_info.py
            📄 strategy_parameters.py
            📄 system_log.py
            📄 trade_log.py
    📂 data_manager/
        📄 __init__.py
        📄 admin.py
        📄 apps.py
        📄 models.py
        📄 tests.py
        📄 urls.py
        📄 views.py
        📂 management/
            📂 commands/
                📄 full_update_stocks.py
        📂 service/
            📄 corporate_action_service.py
            📄 stock_service.py
    📂 logs/
        📄 django.log
    📂 selection_manager/
        📄 __init__.py
        📄 admin.py
        📄 apps.py
        📄 models.py
        📄 tests.py
        📄 urls.py
        📄 views.py
        📂 management/
            📂 commands/
                📄 prime_market_regime_cache.py
        📂 service/
            📄 selection_service.py
            📄 selection_service_old.py
    📂 trade_manager/
        📄 __init__.py
        📄 admin.py
        📄 apps.py
        📄 models.py
        📄 tests.py
        📄 urls.py
        📄 views.py
        📂 management/
            📂 commands/
                📄 run_scheduler.py
        📂 service/
            📄 before_fix_service.py
            📄 decision_order_service.py
            📄 monitor_exit_service.py
            📄 real_trade_handler.py
            📄 scheduler_service.py
            📄 simulate_trade.py
            📄 simulate_trade_handler.py
            📄 trade_handler.py

========================

======= Python文件内容 =======

####manage.py####
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'autoTrade.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()

####文件结束####

####提取日志.py####
import re
import html
import matplotlib.pyplot as plt
from collections import defaultdict
import os

# ==============================================================================
# 配置区域
# ==============================================================================
LOG_FILE_PATH = '回测简单日志.txt'
PLOT_OUTPUT_PATH = '资金变化图.png'
HTML_REPORT_PATH = '交易变化.html'


# ==============================================================================
# 1. 日志解析
# ==============================================================================
def parse_log_file(file_path):
    """
    解析日志文件，提取绘图和报告所需的数据。
    """
    # 用于存储每日资产
    asset_dates = []
    asset_values = []
  
    # 用于存储每日的日志块
    daily_logs = []
  
    # 用于计算每支股票的盈亏
    # 结构: {'sz.002364': {'spent': 1000, 'received': 1100, 'dividends': 10, 'name': '中恒电气'}}
    stock_profits = defaultdict(lambda: {'spent': 0, 'received': 0, 'dividends': 0, 'name': ''})

    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            current_day_block = None
            for line in f:
                line = line.strip()
                if not line:
                    continue

                # 匹配新的一天
                day_match = re.search(r"模拟日: ([\d-]+)", line)
                if day_match:
                    if current_day_block:
                        daily_logs.append(current_day_block)
                    date_str = day_match.group(1)
                    current_day_block = {'date': date_str, 'logs': [line]}
                    continue
              
                if not current_day_block:
                    continue

                current_day_block['logs'].append(line)

                # 匹配总资产
                asset_match = re.search(r"总资产: ([\d.]+)", line)
                if asset_match:
                    asset_dates.append(current_day_block['date'])
                    asset_values.append(float(asset_match.group(1)))

                # 匹配买入操作
                buy_match = re.search(r"买入 (.+?)\((.+?)\).*?花费: ([\d.]+)", line)
                if buy_match:
                    name, code, cost = buy_match.groups()
                    stock_profits[code]['spent'] += float(cost)
                    if not stock_profits[code]['name']: # 首次记录股票名称
                        stock_profits[code]['name'] = name

                # 匹配卖出操作
                sell_match = re.search(r"卖出 (.+?) .*?收入: ([\d.]+)", line)
                if sell_match:
                    code, income = sell_match.groups()
                    stock_profits[code]['received'] += float(income)

                # 匹配分红事件
                dividend_match = re.search(r"持仓ID \d+ \((.+?)\) 获得分红 ([\d.]+)", line)
                if dividend_match:
                    code, dividend = dividend_match.groups()
                    stock_profits[code]['dividends'] += float(dividend)


            if current_day_block: # 添加最后一天的数据
                daily_logs.append(current_day_block)

    except FileNotFoundError:
        print(f"错误: 日志文件 '{file_path}' 未找到。")
        return None, None, None, None
  
    return asset_dates, asset_values, daily_logs, stock_profits

# ==============================================================================
# 2. 生成资金曲线图
# ==============================================================================
def generate_asset_plot(dates, assets, output_path):
    """
    使用matplotlib生成资金曲线图并保存。
    """
    if not dates or not assets:
        print("没有足够的资产数据来生成图表。")
        return

    print("正在生成资金变化图...")
  
    # 设置中文字体，以防乱码
    plt.rcParams['font.sans-serif'] = ['SimHei', 'Microsoft YaHei']
    plt.rcParams['axes.unicode_minus'] = False

    # 创建一个较大尺寸的图形
    fig, ax = plt.subplots(figsize=(18, 9))

    ax.plot(dates, assets, marker='.', linestyle='-', color='b')

    # 设置图表标题和标签
    ax.set_title('策略回测资金曲线', fontsize=20)
    ax.set_xlabel('模拟日期', fontsize=14)
    ax.set_ylabel('总资产 (元)', fontsize=14)
    ax.grid(True, linestyle='--', alpha=0.6)

    # 自动调整x轴标签以避免重叠
    fig.autofmt_xdate(rotation=45)
  
    # 格式化y轴为货币格式
    ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: format(int(x), ',')))

    # 确保布局紧凑，所有元素都可见
    plt.tight_layout()

    # 保存图表
    plt.savefig(output_path, dpi=150)
    plt.close()
    print(f"资金变化图已成功保存到: {output_path}")

# ==============================================================================
# 3. 生成HTML报告
# ==============================================================================
def generate_html_report(daily_logs, stock_profits, output_path):
    """
    生成包含高亮日志和盈亏汇总的HTML报告。
    """
    if not daily_logs or not stock_profits:
        print("没有足够的数据来生成HTML报告。")
        return
      
    print("正在生成HTML报告...")

    # --- 计算并排序股票盈亏 ---
    profit_summary = []
    for code, data in stock_profits.items():
        total_profit = data['received'] + data['dividends'] - data['spent']
        profit_summary.append({
            'code': code,
            'name': data['name'] or '未知名称',
            'profit': total_profit
        })
  
    # 从大到小排序
    sorted_profits = sorted(profit_summary, key=lambda x: x['profit'], reverse=True)

    # --- 构建HTML内容 ---
    html_content = """
    <!DOCTYPE html>
    <html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
        <title>回测交易日志报告</title>
        <style>
            body { font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif; line-height: 1.6; margin: 20px; background-color: #f4f4f4; color: #333; }
            h1, h2 { color: #0056b3; border-bottom: 2px solid #0056b3; padding-bottom: 10px; }
            .container { max-width: 1200px; margin: auto; background: #fff; padding: 20px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
            .summary-table { width: 100%; border-collapse: collapse; margin-bottom: 30px; }
            .summary-table th, .summary-table td { border: 1px solid #ddd; padding: 12px; text-align: left; }
            .summary-table th { background-color: #007bff; color: white; }
            .summary-table tr:nth-child(even) { background-color: #f2f2f2; }
            .profit { color: #d9534f; } /* 红色 */
            .loss { color: #5cb85c; } /* 绿色 */
            .day-block { border: 1px solid #ccc; border-radius: 5px; margin-bottom: 20px; padding: 15px; background-color: #fafafa; }
            .day-block h3 { margin-top: 0; color: #555; }
            .log-entry { font-family: 'Courier New', Courier, monospace; white-space: pre-wrap; word-wrap: break-word; }
            .log-profit-sell { color: #d9534f; font-weight: bold; } /* 止盈卖出 - 红色 */
            .log-stop-loss { color: #5cb85c; font-weight: bold; } /* 止损卖出 - 绿色 */
        </style>
    </head>
    <body>
        <div class="container">
            <h1>回测交易日志报告</h1>
          
            <h2>各股盈亏汇总 (从高到低)</h2>
            <table class="summary-table">
                <thead>
                    <tr>
                        <th>排名</th>
                        <th>股票名称</th>
                        <th>股票代码</th>
                        <th>总盈亏 (元)</th>
                    </tr>
                </thead>
                <tbody>
    """

    # 填充盈亏汇总表格
    for i, item in enumerate(sorted_profits):
        profit_class = 'profit' if item['profit'] >= 0 else 'loss'
        html_content += f"""
                    <tr>
                        <td>{i + 1}</td>
                        <td>{html.escape(item['name'])}</td>
                        <td>{html.escape(item['code'])}</td>
                        <td class="{profit_class}">{item['profit']:.2f}</td>
                    </tr>
        """
  
    html_content += """
                </tbody>
            </table>

            <h2>详细日志记录</h2>
    """

    # 填充详细日志
    for day in daily_logs:
        html_content += f"""
            <div class="day-block">
                <h3>{html.escape(day['date'])}</h3>
                <div class="log-entry">
        """
        for log_line in day['logs']:
            escaped_line = html.escape(log_line)
            if '触发止盈' in log_line or '止盈卖出' in log_line:
                html_content += f'<span class="log-profit-sell">{escaped_line}</span>\n'
            elif '触发止损' in log_line or '止损卖出' in log_line:
                html_content += f'<span class="log-stop-loss">{escaped_line}</span>\n'
            else:
                html_content += f'{escaped_line}\n'
        html_content += """
                </div>
            </div>
        """

    html_content += """
        </div>
    </body>
    </html>
    """

    # 写入文件
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(html_content)
    print(f"HTML报告已成功保存到: {output_path}")

# ==============================================================================
# 主执行函数
# ==============================================================================
def main():
    """主函数，协调所有操作。"""
    print("开始处理回测日志...")
    symbol=['==================== 模拟日','触发','[回测] 卖出',' [回测] 买入','总资产: ','获得分红','风控价格']
    f=open('logs/django.log',"r",encoding="gbk")
    result=""
    for line in f.readlines():
        suc=False
        for each in symbol:
            if each in line:
                suc=True
                break
        if suc:
            result=result+line
    f.close()
    f=open(LOG_FILE_PATH,'w',encoding='utf-8')
    f.write(result)
    f.close()

    # 1. 解析日志
    asset_dates, asset_values, daily_logs, stock_profits = parse_log_file(LOG_FILE_PATH)

    if asset_dates is None: # 如果解析失败
        print("日志处理终止。")
        return

    # 2. 生成图表
    generate_asset_plot(asset_dates, asset_values, PLOT_OUTPUT_PATH)

    # 3. 生成HTML报告
    generate_html_report(daily_logs, stock_profits, HTML_REPORT_PATH)
  
    print("\n所有任务完成！")
    print(f" - 图表文件: {os.path.abspath(PLOT_OUTPUT_PATH)}")
    print(f" - 报告文件: {os.path.abspath(HTML_REPORT_PATH)}")


if __name__ == '__main__':
    main()
main()
####文件结束####

####遍历文件.py####
import os

# --- 配置 ---
# 要扫描的根目录，'.' 表示当前目录
ROOT_DIR = '.'
# 输出文件名
OUTPUT_FILE = 'result.txt'
# 要忽略的目录（使用集合以提高查找效率）
IGNORE_DIRS = {'.git', '__pycache__', 'venv', '.vscode', 'node_modules','migrations'}
# 要忽略的文件
IGNORE_FILES = {'.DS_Store', OUTPUT_FILE,'遍历文件.py'} # 确保不把输出文件本身包含进去

def generate_file_tree(root_dir, ignore_dirs, ignore_files):
    """生成项目文件树结构"""
    tree_lines = []
    for root, dirs, files in os.walk(root_dir, topdown=True):
        # 在遍历前，从dirs列表中移除要忽略的目录
        dirs[:] = [d for d in dirs if d not in ignore_dirs]
      
        # 计算当前深度，用于生成前缀
        level = root.replace(root_dir, '').count(os.sep)
        indent = ' ' * 4 * level
      
        # 添加目录名到树
        # os.path.basename(root) 用于获取当前目录名
        tree_lines.append(f"{indent}📂 {os.path.basename(root)}/")

        # 添加文件到树
        sub_indent = ' ' * 4 * (level + 1)
        for f in sorted(files): # 对文件进行排序
            if f not in ignore_files:
                tree_lines.append(f"{sub_indent}📄 {f}")
              
    return "\n".join(tree_lines)

def get_python_file_contents(root_dir, ignore_dirs):
    """获取所有.py文件的内容并格式化"""
    py_contents = []
    for root, dirs, files in os.walk(root_dir, topdown=True):
        # 同样，忽略指定目录
        dirs[:] = [d for d in dirs if d not in ignore_dirs]
      
        for file in sorted(files):
            if file.endswith('.py'):
                file_path = os.path.join(root, file)
                # 使用相对路径，让输出更清晰
                relative_path = os.path.relpath(file_path, root_dir)
              
                header = f"####{relative_path}####"
                footer = "####文件结束####"
              
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                    py_contents.append(f"{header}\n{content}\n{footer}\n")
                except Exception as e:
                    py_contents.append(f"{header}\n无法读取文件内容: {e}\n{footer}\n")
                  
    return "\n".join(py_contents)

def main():
    """主函数，执行所有操作"""
    print("开始生成项目文件树...")
    file_tree = generate_file_tree(ROOT_DIR, IGNORE_DIRS, IGNORE_FILES)
  
    print("开始读取所有.py文件内容...")
    python_contents = get_python_file_contents(ROOT_DIR, IGNORE_DIRS)
  
    print(f"正在将结果写入 {OUTPUT_FILE}...")
  
    # 将所有内容合并写入文件
    with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
        f.write("======= 项目文件树 =======\n\n")
        f.write(file_tree)
        f.write("\n\n========================\n\n")
        f.write("======= Python文件内容 =======\n\n")
        f.write(python_contents)
      
    print(f"✅ 成功！项目结构和代码已保存到 {OUTPUT_FILE}")

if __name__ == '__main__':
    main()

####文件结束####

####autoTrade\__init__.py####

####文件结束####

####autoTrade\asgi.py####
"""
ASGI config for autoTrade project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'autoTrade.settings')

application = get_asgi_application()

####文件结束####

####autoTrade\settings.py####
"""
Django settings for autoTrade project.

Generated by 'django-admin startproject' using Django 5.2.4.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""

from pathlib import Path
import os
# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-30$wdh0=83tt^5@ed_1y@magp52^70&j)n_14nlwms-hpanwp+'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'data_manager',
    'selection_manager',
    'trade_manager',
    'common'
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    #'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'autoTrade.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'autoTrade.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'mainDB.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'


LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,  # 不要禁用已存在的日志器，否则 Django 自带的日志会失效
  
    # 1. 定义日志格式
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
        'simple': {
            'format': '{levelname} {message}',
            'style': '{',
        },
    },
  
    # 2. 定义处理器 (日志去哪里)
    'handlers': {
        # 输出到控制台
        'console': {
            'level': 'DEBUG',  # 处理 DEBUG 及以上级别的日志
            'class': 'logging.StreamHandler',
            'formatter': 'verbose', # 使用 verbose 格式
        },
        # 输出到文件
        'file': {
            'level': 'INFO',  # 处理 INFO 及以上级别的日志
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': os.path.join(BASE_DIR, 'logs/django.log'), # 日志文件路径
            'maxBytes': 1024 * 1024 * 5,  # 5 MB
            'backupCount': 5, # 最多保留 5 个备份文件
            'formatter': 'verbose', # 使用 verbose 格式
        },
    },
  
    # 3. 定义记录器 (哪些日志需要处理)
    'loggers': {
        # Django 框架自身的日志
        'django': {
            'handlers': ['console', 'file'],
            'level': 'INFO',
            'propagate': True,
        },
        # 你自己应用的日志
        'data_manager': { # 这里使用你的 app 名称
            'handlers': ['console','file'],
            'level': 'DEBUG', # 在开发时设为 DEBUG，可以看到所有信息
            'propagate': False, # 不向上传递给 root logger
        },
        'selection_manager': { # 这里使用你的 app 名称
            'handlers': ['console','file'],
            'level': 'DEBUG', # 在开发时设为 DEBUG，可以看到所有信息
            'propagate': False, # 不向上传递给 root logger
        },
        'trade_manager': { # 这里使用你的 app 名称
            'handlers': ['console','file'],
            'level': 'DEBUG', # 在开发时设为 DEBUG，可以看到所有信息
            'propagate': False, # 不向上传递给 root logger
        },
        # 你可以为任何模块定义 logger
        'common': {
            'handlers': ['console', 'file'],
            'level': 'DEBUG',
            'propagate': False,
        }
    }
}
 
# 确保 logs 目录存在
LOGS_DIR = os.path.join(BASE_DIR, 'logs')
if not os.path.exists(LOGS_DIR):
    os.makedirs(LOGS_DIR)
####文件结束####

####autoTrade\urls.py####
"""
URL configuration for autoTrade project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path,include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('dataManager/', include('data_manager.urls')),
    path('selectionManager/', include('selection_manager.urls')),
    path('tradeManager/', include('trade_manager.urls'))
]

####文件结束####

####autoTrade\wsgi.py####
"""
WSGI config for autoTrade project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'autoTrade.settings')

application = get_wsgi_application()

####文件结束####

####common\__init__.py####

####文件结束####

####common\admin.py####
from django.contrib import admin

# Register your models here.

####文件结束####

####common\apps.py####
from django.apps import AppConfig


class CommonConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'common'

####文件结束####

####common\config_loader.py####
# common/config_loader.py

import json
import os
import logging
from django.conf import settings

logger = logging.getLogger(__name__)

class ConfigLoader:
    _instance = None
    _config = None

    def __new__(cls):
        if not cls._instance:
            cls._instance = super(ConfigLoader, cls).__new__(cls)
        return cls._instance

    def __init__(self):
        if self._config is None:
            self._load_config()

    def _load_config(self):
        config_path = os.path.join(settings.BASE_DIR, 'config.json')
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                self._config = json.load(f)
            logger.info("ConfigLoader: config.json 加载成功。")
        except (FileNotFoundError, json.JSONDecodeError) as e:
            logger.critical(f"ConfigLoader: 无法加载或解析 config.json: {e}。系统将无法正常运行。")
            self._config = {} # 返回一个空字典以避免后续调用出错

    def get_config(self):
        """获取完整的配置字典"""
        return self._config

    def get(self, key, default=None):
        """获取指定键的配置值"""
        return self._config.get(key, default)

# 创建一个全局实例，供项目各处调用
config_loader = ConfigLoader()

####文件结束####

####common\tests.py####
from django.test import TestCase

# Create your tests here.

####文件结束####

####common\views.py####
from django.shortcuts import render

# Create your views here.

####文件结束####

####common\models\__init__.py####
# my_strategy_app/__init__.py

from .stock_info import StockInfo
from .daily_quotes import DailyQuotes
from .factor_definitions import FactorDefinitions
from .daily_factor_values import DailyFactorValues
from .strategy_parameters import StrategyParameters
from .daily_trading_plan import DailyTradingPlan
from .positions import Position
from .trade_log import TradeLog
from .system_log import SystemLog
from .corporate_action import CorporateAction

__all__ = [
    'StockInfo',
    'DailyQuotes',
    'FactorDefinitions',
    'DailyFactorValues',
    'StrategyParameters',
    'DailyTradingPlan',
    'Position',
    'TradeLog',
    'SystemLog',
    'CorporateAction'
]

####文件结束####

####common\models\corporate_action.py####
from django.db import models

class CorporateAction(models.Model):
    """
    股权事件表 (tb_corporate_actions)
  
    说明: 存储所有影响股价非交易性变动的股权事件，是盘前校准模块和回测引擎的核心数据源。
  
    例子:
    10送5：event_type='bonus', shares_before=10, shares_after=15
    10转3：event_type='transfer', shares_before=10, shares_after=13
    10配3，配股价8元：event_type='rights', shares_before=10, shares_after=13, rights_issue_price=8
    1拆2：event_type='split', shares_before=1, shares_after=2 (理解为在1股基础上增加1股)
    10并1：event_type='split', shares_before=10, shares_after=1 (理解为在10股基础上减少9股)
    派1元：event_type='dividend', dividend_per_share=0.1
    """

    # 使用 Django 推荐的 TextChoices 来定义事件类型的枚举
    class EventType(models.TextChoices):
        DIVIDEND = 'dividend', '分红'
        BONUS = 'bonus', '送股'
        TRANSFER = 'transfer', '转股'
        RIGHTS = 'rights', '配股'
        SPLIT = 'split', '拆股/并股'

    # 字段定义
    event_id = models.BigAutoField(
        primary_key=True,
        help_text="事件唯一ID"
    )
    stock_code = models.CharField(
        max_length=10,
        null=False,
        blank=False,
        help_text="股票代码, 格式如 'sh.600000'"
    )
    ex_dividend_date = models.DateField(
        null=False,
        db_index=True,
        help_text="除权除息日 (策略判断的基准日期)，对于配股来说，实际为股权登记日而非除权日"
    )
    record_date = models.DateField(
        null=True,
        blank=True,
        help_text="股权登记日"
    )
    notice_date = models.DateField(
        null=True,
        blank=True,
        help_text="公告日期"
    )
    event_type = models.CharField(
        max_length=20,
        choices=EventType.choices,
        null=False,
        blank=False,
        help_text="事件类型。枚举: dividend(分红), bonus(送股), transfer(转股),rights(配股), split(拆股/并股)"
    )
    dividend_per_share = models.DecimalField(
        max_digits=10,
        decimal_places=4,
        null=True,
        blank=True,
        help_text="每股派息(税前, 元，分红专用)"
    )
    shares_before = models.DecimalField(
        max_digits=10,
        decimal_places=4,
        null=True,
        blank=True,
        help_text="基准股数 (如“10送5”，此值为10，送股/转股/拆股/并股专用)"
    )
    shares_after = models.DecimalField(
        max_digits=10,
        decimal_places=4,
        null=True,
        blank=True,
        help_text="变动股数 (如“10送5”，此值为15，送股/转股/拆股/并股专用)"
    )
    rights_issue_price = models.DecimalField(
        max_digits=10,
        decimal_places=2,
        null=True,
        blank=True,
        help_text="配股价格，配股专用"
    )
    created_at = models.DateTimeField(
        auto_now_add=True,
        null=False,
        help_text="记录创建时间"
    )

    class Meta:
        # 显式指定数据库中的表名
        db_table = 'tb_corporate_actions'
        # 在 Django Admin 中显示的名称
        verbose_name = '股权事件'
        verbose_name_plural = '股权事件'
        # 默认排序规则
        ordering = ['-ex_dividend_date', 'stock_code']

    def __str__(self):
        # 提供一个易于阅读的对象表示形式
        return f"{self.stock_code} on {self.ex_dividend_date}: {self.get_event_type_display()}"


####文件结束####

####common\models\daily_factor_values.py####
from django.db import models
from .stock_info import StockInfo
from .factor_definitions import FactorDefinitions

class DailyFactorValues(models.Model):
    """
    2.2. 每日因子值表 (tb_daily_factor_values)
    说明: (核心设计) 存储每只股票在每个交易日计算出的所有因子原始值和标准化分值。
    """
    stock_code = models.ForeignKey(
        StockInfo, 
        on_delete=models.CASCADE, 
        db_column='stock_code',
        help_text="股票代码"
    )
    trade_date = models.DateField(
        help_text="交易日期"
    )
    factor_code = models.ForeignKey(
        FactorDefinitions, 
        on_delete=models.CASCADE, 
        db_column='factor_code',
        help_text="因子代码"
    )
    raw_value = models.DecimalField(
        max_digits=20, 
        decimal_places=10, 
        help_text="因子计算出的原始值"
    )
    norm_score = models.DecimalField(
        max_digits=10, 
        decimal_places=4, 
        null=True, 
        blank=True,
        help_text="经过norm()函数标准化后的分值 (-100到100)"
    )

    def __str__(self):
        return f"{self.stock_code} - {self.factor_code} on {self.trade_date}"

    class Meta:
        db_table = 'tb_daily_factor_values'
        # 使用 unique_together 实现复合主键的唯一性约束
        unique_together = (('stock_code', 'trade_date', 'factor_code'),)
        verbose_name = '每日因子值'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\daily_quotes.py####
from django.db import models
from .stock_info import StockInfo

class DailyQuotes(models.Model):
    """
    1.2. 日线行情表 (tb_daily_quotes)
    说明: 存储从数据源获取的最原始的日线行情数据，是所有计算的基石。
    """
    stock_code = models.ForeignKey(
        StockInfo, 
        on_delete=models.CASCADE, 
        db_column='stock_code',
        help_text="股票代码"
    )
    trade_date = models.DateField(
        help_text="交易日期"
    )
    open = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="不复权开盘价"
    )
    high = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="不复权最高价"
    )
    low = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="不复权最低价"
    )
    close = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="不复权收盘价"
    )
    volume = models.BigIntegerField(
        help_text="成交量 (股)"
    )
    turnover = models.DecimalField(
        max_digits=20, 
        decimal_places=2, 
        help_text="成交额 (元)"
    )
    adjust_factor = models.DecimalField(
        max_digits=20, 
        decimal_places=10, 
        help_text="截至当日的后复权因子"
    )
    # (要求1) 计算列 hfq_close
    hfq_close = models.DecimalField(
        max_digits=20, 
        decimal_places=10, 
        editable=False,
        help_text="后复权收盘价，公式: close * adjust_factor"
    )

    def save(self, *args, **kwargs):
        # 在保存模型前计算 hfq_close 的值
        self.hfq_close = self.close * self.adjust_factor
        super().save(*args, **kwargs)

    def __str__(self):
        return f"{self.stock_code} on {self.trade_date}"

    class Meta:
        db_table = 'tb_daily_quotes'
        # 使用 unique_together 实现复合主键的唯一性约束
        unique_together = (('stock_code', 'trade_date'),)
        verbose_name = '日线行情'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\daily_trading_plan.py####
from django.db import models
from .stock_info import StockInfo

class DailyTradingPlan(models.Model):
    """
    3.1. 每日交易预案表 (tb_daily_trading_plan)
    说明: 存储 T-1 日终选股模块生成的“次日观察池”及相关交易预案。
    """
    class StatusChoices(models.TextChoices):
        PENDING = 'pending', '待执行'
        EXECUTED = 'executed', '已执行买入'
        CANCELLED = 'cancelled', '当日未满足条件作废'

    plan_date = models.DateField(
        help_text="预案执行日期 (T日)"
    )
    stock_code = models.ForeignKey(
        StockInfo, 
        on_delete=models.CASCADE, 
        db_column='stock_code',
        help_text="候选股票代码"
    )
    rank = models.IntegerField(
        help_text="综合得分排名 (1-10)"
    )
    final_score = models.DecimalField(
        max_digits=10, 
        decimal_places=4, 
        help_text="f(x)选股综合得分"
    )
    miop = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="最低可接受开盘价 (Minimum Acceptable Open Price)"
    )
    maop = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="最高可接受开盘价 (Maximum Acceptable Open Price)"
    )
    status = models.CharField(
        max_length=20, 
        choices=StatusChoices.choices, 
        default=StatusChoices.PENDING,
        help_text="预案状态。枚举: pending(待执行), executed(已执行买入), cancelled(当日未满足条件作废)"
    )

    def __str__(self):
        return f"Plan for {self.stock_code} on {self.plan_date} (Rank: {self.rank})"

    class Meta:
        db_table = 'tb_daily_trading_plan'
        # 使用 unique_together 实现复合主键的唯一性约束
        unique_together = (('plan_date', 'stock_code'),)
        verbose_name = '每日交易预案'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\factor_definitions.py####
from django.db import models

class FactorDefinitions(models.Model):
    """
    2.1. 因子定义表 (tb_factor_definitions)
    说明: (核心设计) 用于定义所有策略中使用的因子，实现因子的可插拔。新增因子只需在此表增加一条记录。
    """
    class DirectionChoices(models.TextChoices):
        POSITIVE = 'positive', '正向, 值越大越好'
        NEGATIVE = 'negative', '负向, 值越小越好'

    factor_code = models.CharField(
        max_length=50, 
        primary_key=True, 
        help_text="因子唯一英文代码, 如 'MA20_SLOPE'"
    )
    factor_name = models.CharField(
        max_length=100, 
        help_text="因子中文名称, 如 '20日均线斜率'"
    )
    description = models.TextField(
        blank=True, 
        null=True, 
        help_text="详细描述因子的计算逻辑和业务含义"
    )
    direction = models.CharField(
        max_length=10, 
        choices=DirectionChoices.choices,
        help_text="因子方向性。枚举: positive(正向, 值越大越好), negative(负向, 值越小越好)"
    )
    is_active = models.BooleanField(
        default=True, 
        help_text="是否启用该因子"
    )

    def __str__(self):
        return f"{self.factor_name} ({self.factor_code})"

    class Meta:
        db_table = 'tb_factor_definitions'
        verbose_name = '因子定义'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\positions.py####
from django.db import models
from .stock_info import StockInfo

class Position(models.Model):
    """
    3.2. 持仓信息表 (tb_positions)
    说明: 存储当前所有持仓的详细信息，是盘中监控模块的核心数据依据。
    """
    class StatusChoices(models.TextChoices):
        OPEN = 'open', '持仓中'
        CLOSED = 'closed', '已平仓'

    position_id = models.BigAutoField(
        primary_key=True, 
        help_text="持仓唯一ID"
    )
    stock_code = models.ForeignKey(
        StockInfo, 
        on_delete=models.PROTECT, # 保护，防止意外删除关联股票信息
        db_column='stock_code',
        help_text="股票代码"
    )
    entry_datetime = models.DateTimeField(
        help_text="建仓成交时间"
    )
    entry_price = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="实际成交均价 (AEP)"
    )
    quantity = models.BigIntegerField(
        help_text="持仓数量 (股)"
    )
    current_stop_loss = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="当前止损价"
    )
    current_take_profit = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="当前止盈价"
    )
    status = models.CharField(
        max_length=20, 
        choices=StatusChoices.choices, 
        default=StatusChoices.OPEN,
        help_text="持仓状态。枚举: open(持仓中), closed(已平仓)"
    )

    def __str__(self):
        return f"Position {self.position_id}: {self.quantity} of {self.stock_code}"

    class Meta:
        db_table = 'tb_positions'
        verbose_name = '持仓信息'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\stock_info.py####
from django.db import models
from django.utils import timezone

class StockInfo(models.Model):
    """
    1.1. 股票基础信息表 (tb_stock_info)
    说明: 存储所有A股股票的基本信息，如代码、名称、上市日期等，作为其他数据表的关联基础。
    """
    class StatusChoices(models.TextChoices):
        LISTING = 'listing', '上市'
        DELISTED = 'delisted', '退市'
        SUSPENDED = 'suspended', '停牌'

    stock_code = models.CharField(
        max_length=10, 
        primary_key=True, 
        help_text="股票代码, 格式如 'sh.600000'"
    )
    stock_name = models.CharField(
        max_length=50, 
        help_text="股票名称"
    )
    listing_date = models.DateField(
        help_text="上市日期, 用于剔除次新股"
    )
    status = models.CharField(
        max_length=20, 
        choices=StatusChoices.choices,
        help_text="股票状态。枚举: listing(上市), delisted(退市), suspended(停牌)"
    )
    created_at = models.DateTimeField(
        default=timezone.now, 
        editable=False,
        help_text="记录创建时间"
    )
    updated_at = models.DateTimeField(
        auto_now=True,
        help_text="记录更新时间"
    )

    def __str__(self):
        return f"{self.stock_name}({self.stock_code})"

    class Meta:
        db_table = 'tb_stock_info'
        verbose_name = '股票基础信息'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\strategy_parameters.py####
from django.db import models

class StrategyParameters(models.Model):
    """
    2.3. 策略参数表 (tb_strategy_parameters)
    说明: 存储所有策略中可优化的参数，如权重、系数等，方便回测与优化模块进行读取和修改。
    """
    param_name = models.CharField(
        max_length=50, 
        primary_key=True, 
        help_text="参数唯一英文名, 如 'w_trend', 'k_h1'"
    )
    param_value = models.DecimalField(
        max_digits=20, 
        decimal_places=10, 
        help_text="参数的数值"
    )
    group_name = models.CharField(
        max_length=50, 
        blank=True, 
        null=True, 
        help_text="参数所属分组, 如 'WEIGHTS', 'STOP_LOSS'"
    )
    description = models.TextField(
        blank=True, 
        null=True, 
        help_text="参数的详细说明"
    )

    def __str__(self):
        return f"{self.param_name} = {self.param_value}"

    class Meta:
        db_table = 'tb_strategy_parameters'
        verbose_name = '策略参数'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\system_log.py####
from django.db import models
from django.utils import timezone

class SystemLog(models.Model):
    """
    4.1. 系统日志表 (tb_system_log)
    说明: 记录系统运行过程中的关键信息、警告和错误，便于监控和调试。
    """
    class LogLevelChoices(models.TextChoices):
        INFO = 'INFO', 'INFO'
        WARNING = 'WARNING', 'WARNING'
        ERROR = 'ERROR', 'ERROR'
        CRITICAL = 'CRITICAL', 'CRITICAL'

    log_id = models.BigAutoField(
        primary_key=True, 
        help_text="日志唯一ID"
    )
    log_time = models.DateTimeField(
        default=timezone.now, 
        editable=False,
        help_text="日志记录时间"
    )
    log_level = models.CharField(
        max_length=10, 
        choices=LogLevelChoices.choices,
        help_text="日志级别。枚举: INFO, WARNING, ERROR, CRITICAL"
    )
    module_name = models.CharField(
        max_length=50, 
        blank=True, 
        null=True,
        help_text="产生日志的模块名, 如 '日终选股', '开盘决策'"
    )
    message = models.TextField(
        help_text="日志内容, 如 '无合适买点', '下单API请求失败'"
    )

    def __str__(self):
        return f"[{self.log_time.strftime('%Y-%m-%d %H:%M:%S')}] [{self.log_level}] {self.message[:80]}"

    class Meta:
        db_table = 'tb_system_log'
        verbose_name = '系统日志'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\trade_log.py####
from django.db import models
from .stock_info import StockInfo

class TradeLog(models.Model):
    """
    3.3. 交易记录表 (tb_trade_log)
    说明: 记录每一次买入和卖出的详细信息，用于成本核算、业绩分析和问题排查。
    """
    class TradeTypeChoices(models.TextChoices):
        BUY = 'buy', '买入'
        SELL = 'sell', '卖出'

    class OrderTypeChoices(models.TextChoices):
        LIMIT = 'limit', '限价'
        MARKET = 'market', '市价'

    class ReasonChoices(models.TextChoices):
        ENTRY = 'entry', '策略入场'
        TAKE_PROFIT = 'take_profit', '止盈'
        STOP_LOSS = 'stop_loss', '止损'
        MANUAL = 'manual', '人工干预'

    class StatusChoices(models.TextChoices):
        FILLED = 'filled', '已成交'
        FAILED = 'failed', '失败'
        CANCELLED = 'cancelled', '已撤销'
        PENDING = 'pending','待执行'

    trade_id = models.BigAutoField(
        primary_key=True, 
        help_text="交易唯一ID"
    )
    # 注意：这里使用字符串 'positions.Position' 来避免循环导入问题
    # related_name='trade_logs' 允许从 Position 对象反向访问其所有交易记录
    position = models.ForeignKey(
        'Position', 
        on_delete=models.CASCADE, # 如果持仓被删除，关联的交易记录也应删除
        related_name='trade_logs',
        help_text="关联的持仓ID (买入时生成, 卖出时引用)"
    )
    stock_code = models.ForeignKey(
        StockInfo, 
        on_delete=models.PROTECT,
        db_column='stock_code',
        help_text="股票代码"
    )
    trade_datetime = models.DateTimeField(
        help_text="交易成交时间"
    )
    trade_type = models.CharField(
        max_length=10, 
        choices=TradeTypeChoices.choices,
        help_text="交易类型。枚举: buy(买入), sell(卖出)"
    )
    order_type = models.CharField(
        max_length=10, 
        choices=OrderTypeChoices.choices,
        help_text="订单类型。枚举: limit(限价), market(市价)"
    )
    price = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="成交均价"
    )
    quantity = models.BigIntegerField(
        help_text="成交数量"
    )
    commission = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="佣金"
    )
    stamp_duty = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        default=0,
        help_text="印花税 (仅卖出时有)"
    )
    reason = models.CharField(
        max_length=50, 
        choices=ReasonChoices.choices, 
        blank=True, 
        null=True,
        help_text="交易原因。枚举: entry(策略入场), take_profit(止盈), stop_loss(止损), manual(人工干预)"
    )
    status = models.CharField(
        max_length=20, 
        choices=StatusChoices.choices,
        help_text="订单状态。枚举: filled(已成交), failed(失败), cancelled(已撤销),pending(待执行)"
    )

    external_order_id = models.CharField(
        max_length=50, 
        null=True, 
        blank=True, 
        db_index=True,
        help_text="外部交易系统的订单ID，如券商的委托编号"
    )

    def __str__(self):
        return f"Trade {self.trade_id}: {self.trade_type.upper()} {self.quantity} of {self.stock_code}"

    class Meta:
        db_table = 'tb_trade_log'
        verbose_name = '交易记录'
        verbose_name_plural = verbose_name

####文件结束####

####data_manager\__init__.py####

####文件结束####

####data_manager\admin.py####
from django.contrib import admin

# Register your models here.

####文件结束####

####data_manager\apps.py####
from django.apps import AppConfig


class DataManagerConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'data_manager'

####文件结束####

####data_manager\models.py####
from django.db import models

# Create your models here.

####文件结束####

####data_manager\tests.py####
from django.test import TestCase

# Create your tests here.

####文件结束####

####data_manager\urls.py####
"""
URL configuration for autoTrade project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path,include
from . import views
urlpatterns = [
    path('test', views.test_get),
    path('updateLocalStock', views.update_local_a_shares),
    path('syncCorporateActions', views.sync_corporate_actions)
]

####文件结束####

####data_manager\views.py####
from django.http.response import JsonResponse
from django.shortcuts import render
from common.models import StockInfo
from data_manager.service.stock_service import StockService
from data_manager.service.corporate_action_service import CorporateActionService
from django.views.decorators.http import require_http_methods
import json
# Create your views here.
def test_get(request):
    result={}
    if request.method=='GET':
        result=  {'method':'get'}
    if request.method=='POST':
        result= {'methods':'post'}
    service=StockService()
    service.clear_all_data()
    service.update_local_a_shares(start_date="2025-01-01",end_date="2025-08-04")
    service.update_local_a_shares(start_date="2024-01-01",end_date="2024-12-31")
    service.update_local_a_shares(start_date="2023-01-01",end_date="2023-12-31")
    service.update_local_a_shares(start_date="2022-01-01",end_date="2022-12-31")
    service.update_local_a_shares(start_date="2021-01-01",end_date="2021-12-31")
    return JsonResponse(result)

@require_http_methods(["POST"])
def update_local_a_shares(request):
    body= json.loads(request.body)
    service=StockService()
    service.update_local_a_shares(stock_codes=body['stockCodes'],start_date=body['startDate'],end_date=body['endDate'])
    return JsonResponse({"result":"success"})

@require_http_methods(["POST"])
def sync_corporate_actions(request):
    body= json.loads(request.body)
    service=CorporateActionService()
    service.sync_corporate_actions(start_date=body['startDate'],end_date=body['endDate'])
    return JsonResponse({"result":"success"})

####文件结束####

####data_manager\management\commands\full_update_stocks.py####
# data_manager/management/commands/full_update_stocks.py

from django.core.management.base import BaseCommand
from data_manager.service.stock_service import StockService
from selection_manager.service.selection_service import SelectionService
import time
from datetime import date,datetime
class Command(BaseCommand):
    help = '清空并重新获取过去五年的全部A股数据'

    def handle(self, *args, **options):
        total_start_time = time.time()
        self.stdout.write(self.style.SUCCESS('===== 开始执行全量数据更新任务 ====='))
      
        service = StockService()
      
        # 1. 清空所有旧数据
        self.stdout.write('正在清空所有历史数据...')
        #service.clear_all_data()
        self.stdout.write(self.style.SUCCESS('历史数据已清空。'))
      
        # 2. 按年份顺序获取数据
        #service.clear_all_data()
        service.update_local_a_shares(start_date="2025-08-06",end_date="2025-08-07")
        #service.update_local_a_shares(start_date="2024-01-01",end_date="2024-12-31")
        # service.update_local_a_shares(start_date="2023-01-01",end_date="2023-12-31")
        # service.update_local_a_shares(start_date="2022-01-01",end_date="2022-12-31")
        # service.update_local_a_shares(start_date="2021-01-01",end_date="2021-12-31")
        total_end_time = time.time()
        self.stdout.write(self.style.SUCCESS(f'\n===== 所有年份数据更新完毕！总耗时: {(total_end_time - total_start_time) / 3600:.2f} 小时 ====='))
        self.stdout.write('开始预热M值...')
        service=SelectionService(datetime.strptime('2025-08-06', "%Y-%m-%d").date())
        service.run_selection()
        total_end_time_2 = time.time()

####文件结束####

####data_manager\service\corporate_action_service.py####
import logging
import time
from datetime import datetime

import akshare
import pandas as pd
from django.db import transaction

# 导入您的 Django models
# 请根据您的项目结构调整以下导入路径
from common.models.corporate_action import CorporateAction
from common.models.stock_info import StockInfo

# 配置日志记录器
logger = logging.getLogger(__name__)
class CorporateActionService:
    def _fetch_and_save_split_events(self,stock_codes_filter: list, start_date: str, end_date: str):
        """
        预留的拆股/并股事件处理函数。
        """
        # logger.info(f"正在检查拆股/并股事件 (当前版本暂未实现)...")
        pass

    def sync_corporate_actions(self,start_date: str, end_date: str, stock_codes: list = None):
        """
        从 Akshare 高效同步指定日期范围和股票范围的股权事件数据，并存入数据库。
        """
        logger.info(f"开始同步股权事件，日期范围: {start_date} to {end_date}。")
        if stock_codes:
            logger.info(f"目标股票: {len(stock_codes)} 只。")
        else:
            logger.info("目标股票: 全部A股。")

        # 1. 任务开始前，一次性清理数据
        try:
            with transaction.atomic():
                qs = CorporateAction.objects.filter(
                    ex_dividend_date__gte=start_date,
                    ex_dividend_date__lte=end_date
                )
                if stock_codes:
                    qs = qs.filter(stock_code__in=stock_codes)
              
                deleted_count, _ = qs.delete()
                logger.info(f"数据清理完成。在 {start_date} 到 {end_date} 范围内共删除 {deleted_count} 条旧记录。")
        except Exception as e:
            logger.error(f"清理历史数据时发生严重错误，任务终止: {e}", exc_info=True)
            return

        all_stocks_map = {s.split('.')[-1]: s for s in StockInfo.objects.values_list('stock_code', flat=True)}
        ak_codes_filter = [c.split('.')[-1] for c in stock_codes] if stock_codes else None

        # 2. 处理分红、送股、转股 (stock_fhps_em)
        try:
            logger.info("开始处理分红、送股、转股事件...")
            fhps_dfs = []
            start_year = datetime.strptime(start_date, '%Y-%m-%d').year
            end_year = datetime.strptime(end_date, '%Y-%m-%d').year
          
            # ★★★★★ 优化点：使用更精确的年份范围，覆盖跨年预案 ★★★★★
            report_suffixes = ["0331", "0630", "0930", "1231"]
            for year in range(start_year - 1, end_year + 1):
                for suffix in report_suffixes:
                    report_date = f"{year}{suffix}"
                    logger.info(f"正在拉取报告期 {report_date} 的分红送配预案...")
                    try:
                        time.sleep(1)
                        fhps_df = akshare.stock_fhps_em(date=report_date)
                        if not fhps_df.empty:
                            fhps_dfs.append(fhps_df)
                    except Exception as e:
                        logger.warning(f"拉取报告期 {report_date} 数据失败或无数据: {e}")
          
            if fhps_dfs:
                # 使用 '代码' 和 '除权除息日' 作为联合主键去重，防止同一事件因在不同报告期披露而重复
                all_fhps_df = pd.concat(fhps_dfs, ignore_index=True).drop_duplicates(subset=['代码', '除权除息日'])
              
                all_fhps_df['除权除息日'] = pd.to_datetime(all_fhps_df['除权除息日'], errors='coerce')
                all_fhps_df.dropna(subset=['除权除息日'], inplace=True)
              
                mask = (all_fhps_df['除权除息日'] >= pd.to_datetime(start_date)) & (all_fhps_df['除权除息日'] <= pd.to_datetime(end_date))
                filtered_fhps_df = all_fhps_df[mask].copy()

                if ak_codes_filter:
                    filtered_fhps_df = filtered_fhps_df[filtered_fhps_df['代码'].isin(ak_codes_filter)]

                logger.info(f"共获取到 {len(filtered_fhps_df)} 条符合条件的分红送转记录，准备入库...")

                with transaction.atomic():
                    for _, row in filtered_fhps_df.iterrows():
                        ak_code = row['代码']
                        stock_code_prefixed = all_stocks_map.get(ak_code)
                        if not stock_code_prefixed:
                            continue

                        # 分红
                        if pd.notna(row['现金分红-现金分红比例']) and row['现金分红-现金分红比例'] > 0:
                            CorporateAction.objects.create(
                                stock_code=stock_code_prefixed,
                                ex_dividend_date=row['除权除息日'].date(),
                                record_date=pd.to_datetime(row['股权登记日'], errors='coerce').date() if pd.notna(row['股权登记日']) else None,
                                notice_date=pd.to_datetime(row['最新公告日期'], errors='coerce').date() if pd.notna(row['最新公告日期']) else None,
                                event_type=CorporateAction.EventType.DIVIDEND,
                                dividend_per_share=row['现金分红-现金分红比例'] / 10
                            )

                        # 送股
                        if pd.notna(row['送转股份-送转比例']) and row['送转股份-送转比例'] > 0:
                            CorporateAction.objects.create(
                                stock_code=stock_code_prefixed,
                                ex_dividend_date=row['除权除息日'].date(),
                                record_date=pd.to_datetime(row['股权登记日'], errors='coerce').date() if pd.notna(row['股权登记日']) else None,
                                notice_date=pd.to_datetime(row['最新公告日期'], errors='coerce').date() if pd.notna(row['最新公告日期']) else None,
                                event_type=CorporateAction.EventType.BONUS,
                                shares_before=10,
                                shares_after=10 + row['送转股份-送转比例']
                            )

                        # 转股
                        if pd.notna(row['送转股份-转股比例']) and row['送转股份-转股比例'] > 0:
                            CorporateAction.objects.create(
                                stock_code=stock_code_prefixed,
                                ex_dividend_date=row['除权除息日'].date(),
                                record_date=pd.to_datetime(row['股权登记日'], errors='coerce').date() if pd.notna(row['股权登记日']) else None,
                                notice_date=pd.to_datetime(row['最新公告日期'], errors='coerce').date() if pd.notna(row['最新公告日期']) else None,
                                event_type=CorporateAction.EventType.TRANSFER,
                                shares_before=10,
                                shares_after=10 + row['送转股份-转股比例']
                            )
            logger.info("分红、送股、转股事件处理完成。")
        except Exception as e:
            logger.error(f"处理分红送转数据时发生严重错误: {e}", exc_info=True)

        # 3. 处理配股 (stock_pg_em)
        try:
            logger.info("开始处理配股事件...")
            time.sleep(1)
            all_pg_df = akshare.stock_pg_em()
          
            # Akshare 返回的 '股权登记日' 可能包含无效日期，需要处理
            all_pg_df['股权登记日'] = pd.to_datetime(all_pg_df['股权登记日'], errors='coerce')
            all_pg_df.dropna(subset=['股权登记日'], inplace=True)
 
            mask = (all_pg_df['股权登记日'] >= pd.to_datetime(start_date)) & (all_pg_df['股权登记日'] <= pd.to_datetime(end_date))
            filtered_pg_df = all_pg_df[mask].copy()
 
            if ak_codes_filter:
                filtered_pg_df = filtered_pg_df[filtered_pg_df['股票代码'].isin(ak_codes_filter)]
          
            logger.info(f"共获取到 {len(filtered_pg_df)} 条符合条件的配股记录，准备入库...")
 
            with transaction.atomic():
                for _, row in filtered_pg_df.iterrows():
                    ak_code = row['股票代码']
                    stock_code_prefixed = all_stocks_map.get(ak_code)
                    if not stock_code_prefixed:
                        continue
 
                    # --- 修改开始 ---
                    # 从 '10配3.0' 这样的字符串中解析出配股比例数值
                    rights_ratio_val = 0
                    rights_ratio_str = row['配股比例']
                  
                    # 确保 '配股比例' 是一个有效的、可解析的字符串
                    if pd.notna(rights_ratio_str) and isinstance(rights_ratio_str, str) and '配' in rights_ratio_str:
                        try:
                            # 按 '配' 分割，取后面的部分，并转换为浮点数
                            ratio_str_part = rights_ratio_str.split('配')[1]
                            rights_ratio_val = float(ratio_str_part)
                        except (IndexError, ValueError) as e:
                            logger.warning(f"无法解析股票 {ak_code} 的配股比例 '{rights_ratio_str}'，已跳过。错误: {e}")
                            continue # 跳过此条记录
 
                    if rights_ratio_val > 0:
                        CorporateAction.objects.create(
                            stock_code=stock_code_prefixed,
                            # 注意：配股通常使用 '股权登记日' 作为关键日期，'除权日' 在此接口中可能不提供
                            ex_dividend_date=row['股权登记日'].date(), 
                            record_date=row['股权登记日'].date(),
                            notice_date=None, # akshare.stock_pg_em() 未提供公告日期
                            event_type=CorporateAction.EventType.RIGHTS,
                            shares_before=10, # 配股基准通常是10股
                            shares_after=10 + rights_ratio_val, # 使用解析后的数值
                            rights_issue_price=row['配股价']
                        )
                    # --- 修改结束 ---
 
            logger.info("配股事件处理完成。")
        except KeyError as e:
            # 捕获 '配股比例' 等字段不存在的错误
            logger.error(f"处理配股数据时发生字段缺失错误: {e}。请检查 Akshare 返回的数据列名是否已变更。", exc_info=True)
        except Exception as e:
            logger.error(f"处理配股数据时发生严重错误: {e}", exc_info=True)

        # 4. 调用预留的拆股/并股处理函数
        self._fetch_and_save_split_events(stock_codes, start_date, end_date)

        logger.info("所有股权事件同步任务已全部完成。")

####文件结束####

####data_manager\service\stock_service.py####
import logging
import datetime
from decimal import Decimal, ROUND_HALF_UP,InvalidOperation
import akshare as ak
import pandas as pd
from django.utils import timezone
from django.db import connection,transaction, DatabaseError

# 导入您的Django模型
from common.models.stock_info import StockInfo
from common.models.daily_quotes import DailyQuotes
from common.models.factor_definitions import FactorDefinitions
from common.models.daily_factor_values import DailyFactorValues
from common.models.strategy_parameters import StrategyParameters
from common.models.daily_trading_plan import DailyTradingPlan
from common.models.positions import Position
from common.models.trade_log import TradeLog
from common.models.system_log import SystemLog
from concurrent.futures import ThreadPoolExecutor, as_completed
import time

# 获取logger实例
logger = logging.getLogger(__name__)

# 定义模块常量，便于维护
MODULE_NAME = 'data_manager'

class StockService:
    """
    封装了与股票数据相关的服务，包括从akshare更新数据和从本地数据库查询数据。

    使用示例 (在Django views.py 或 management command中):

    from .services.stock_service import StockService

    def my_view(request):
        service = StockService()
    
        # 示例1: 更新所有A股今天的行情
        service.update_local_a_shares()
    
        # 示例2: 更新指定几只股票某时间段的行情
        codes = ['sh.600519', 'sz.000001']
        service.update_local_a_shares(stock_codes=codes, start_date='2023-01-01', end_date='2023-01-31')
    
        # 示例3: 查询指定股票的基础信息
        stock_infos = service.query_stock_info(stock_codes=codes)
    
        # 示例4: 查询所有股票今天的日线行情
        daily_quotes = service.query_daily_quotes()
    """

    def _log_and_save(self, message: str, level: str = SystemLog.LogLevelChoices.INFO):
        """
        一个辅助方法，用于同时向标准logger和数据库系统日志表写入日志。
        """
        log_map = {
            SystemLog.LogLevelChoices.INFO: logger.info,
            SystemLog.LogLevelChoices.WARNING: logger.warning,
            SystemLog.LogLevelChoices.ERROR: logger.error,
            SystemLog.LogLevelChoices.CRITICAL: logger.critical,
        }
    
        # 打印到标准日志
        log_function = log_map.get(level, logger.info)
        log_function(message)
    
        # 保存到数据库
        # try:
        #     SystemLog.objects.create(
        #         log_level=level,
        #         module_name=MODULE_NAME,
        #         message=message
        #     )
        # except Exception as e:
        #     logger.error(f"无法将日志写入数据库: {e}")

    def _save_quotes_df_to_db(self, quotes_df: pd.DataFrame):
        """
        辅助方法：将一个DataFrame的行情数据通过 update_or_create 批量存入数据库。
        此方法具有幂等性，适用于所有数据，无需区分历史和当日。
        """
        if quotes_df.empty:
            return
 
        # 数据清洗和预处理
        quotes_df.fillna(0, inplace=True)
        quotes_df = quotes_df[(quotes_df['开盘'] > 0) & (quotes_df['收盘'] > 0) & (quotes_df['最高'] > 0) & (quotes_df['最低'] > 0) & (quotes_df['成交量'] >= 0)]
        if quotes_df.empty:
            self._log_and_save("数据清洗后，当前批次无有效数据可存储。", level=SystemLog.LogLevelChoices.INFO)
            return
          
        quotes_df['日期'] = pd.to_datetime(quotes_df['日期']).dt.date
      
        hfq_precision = Decimal('0.0000000001')
        records_to_process = len(quotes_df)
  
        try:
            # 将整个批次的 update_or_create 操作放在一个事务中，以提高性能
            with transaction.atomic():
                for _, row in quotes_df.iterrows():
                    try:
                        close_dec = Decimal(str(row['收盘']))
                        factor_dec = Decimal(str(row['复权因子']))
                        hfq_close_dec = (close_dec * factor_dec).quantize(hfq_precision, rounding=ROUND_HALF_UP)
                      
                        # 对每一行数据都执行 update_or_create
                        DailyQuotes.objects.update_or_create(
                            stock_code_id=row['stock_code'], 
                            trade_date=row['日期'],
                            defaults={
                                'open': Decimal(str(row['开盘'])), 
                                'high': Decimal(str(row['最高'])),
                                'low': Decimal(str(row['最低'])), 
                                'close': close_dec,
                                'volume': int(row['成交量']), 
                                'turnover': Decimal(str(row['成交额'])),
                                'adjust_factor': factor_dec, 
                                'hfq_close': hfq_close_dec
                            }
                        )
                    except (InvalidOperation, TypeError) as conversion_error:
                        self._log_and_save(f"跳过一条数据转换失败的记录: {row['stock_code']} on {row['日期']}. Error: {conversion_error}", level=SystemLog.LogLevelChoices.WARNING)
                        continue
          
            self._log_and_save(f"通过 update_or_create 成功处理了 {records_to_process} 条日线数据。")
  
        except (DatabaseError, Exception) as e:
            self._log_and_save(f"数据批量入库阶段(update_or_create)发生严重错误: {e}", level=SystemLog.LogLevelChoices.ERROR)

    def update_local_a_shares(
        self, 
        stock_codes: list[str] = None, 
        start_date: str = None, 
        end_date: str = None
    ):

        """
        1. 更新本地A股信息 (最终版：高效、健壮)
        """
        self._log_and_save(f"开始执行A股数据更新任务...")
        target_codes=[]
        # --- Part 1: 更新股票基础信息 (tb_stock_info) ---
        try:
            self._log_and_save("正在从交易所官方数据源获取全量A股列表...")
          
            # 1. 通过高效、可靠的接口一次性获取所有A股信息
            # 上海主板A股
            sh_main_df = ak.stock_info_sh_name_code(symbol="主板A股").copy()
            # 上海科创板
            sh_star_df = ak.stock_info_sh_name_code(symbol="科创板").copy()
            # 深圳A股
            sz_a_df = ak.stock_info_sz_name_code(symbol="A股列表").copy()
 
            # 2. 数据预处理和合并
            # 统一列名
            sh_main_df.rename(columns={'证券简称': 'stock_name', '上市日期': 'listing_date', '证券代码': 'code'}, inplace=True)
            sh_star_df.rename(columns={'证券简称': 'stock_name', '上市日期': 'listing_date', '证券代码': 'code'}, inplace=True)
            sz_a_df.rename(columns={'A股简称': 'stock_name', 'A股上市日期': 'listing_date', 'A股代码': 'code'}, inplace=True)
 
            # 添加市场前缀
            sh_main_df['code'] = 'sh.' + sh_main_df['code']
            sh_star_df['code'] = 'sh.' + sh_star_df['code']
            sz_a_df['code'] = 'sz.' + sz_a_df['code']
 
            # 合并为一个DataFrame
            all_stocks_df = pd.concat([
                sh_main_df[['code', 'stock_name', 'listing_date']],
                sh_star_df[['code', 'stock_name', 'listing_date']],
                sz_a_df[['code', 'stock_name', 'listing_date']]
            ], ignore_index=True)
 
            # 转换日期格式
            all_stocks_df['listing_date'] = pd.to_datetime(all_stocks_df['listing_date']).dt.date
          
            self._log_and_save(f"成功获取 {len(all_stocks_df)} 条A股基础信息。")
 
            # 3. 高效的批量入库操作
            with transaction.atomic():
                existing_stocks = StockInfo.objects.in_bulk(field_name='stock_code')
              
                to_create = []
                to_update = []
 
                for _, row in all_stocks_df.iterrows():
                    code = row['code']
                    stock_obj = existing_stocks.get(code)
                  
                    if not stock_obj:
                        # 如果股票不存在，则准备新建
                        to_create.append(
                            StockInfo(
                                stock_code=code,
                                stock_name=row['stock_name'],
                                listing_date=row['listing_date'],
                                status=StockInfo.StatusChoices.LISTING
                            )
                        )
                    elif stock_obj.stock_name != row['stock_name']:
                        # 如果股票存在但名称有变，则准备更新
                        stock_obj.stock_name = row['stock_name']
                        to_update.append(stock_obj)
 
                # 批量创建
                if to_create:
                    StockInfo.objects.bulk_create(to_create, batch_size=500)
                    self._log_and_save(f"批量新增 {len(to_create)} 条股票基础信息。")
              
                # 批量更新
                if to_update:
                    StockInfo.objects.bulk_update(to_update, ['stock_name'], batch_size=500)
                    self._log_and_save(f"批量更新 {len(to_update)} 条股票基础信息。")
 
            # 如果未指定 stock_codes，则使用获取到的所有代码进行下一步
            if not stock_codes or len(stock_codes)==0:
                stock_codes = all_stocks_df['code'].tolist()
            else:
                # 如果指定了，则只处理指定的代码
                stock_codes = [code for code in stock_codes if code in all_stocks_df['code'].values]
            target_codes = stock_codes if stock_codes else all_stocks_df['code'].tolist()
        except Exception as e:
            self._log_and_save(f"更新股票基础信息时发生严重错误: {e}", level=SystemLog.LogLevelChoices.ERROR)
            return

        # --- Part 2: 更新日线行情 (串行获取、内存汇总、批量入库) ---
        self._log_and_save(f"开始为 {len(target_codes)} 只股票串行获取日线行情...")
        today_str = datetime.date.today().strftime('%Y%m%d')
        start_date_str = datetime.datetime.strptime(start_date, '%Y-%m-%d').strftime('%Y%m%d') if start_date else today_str
        end_date_str = datetime.datetime.strptime(end_date, '%Y-%m-%d').strftime('%Y%m%d') if end_date else today_str
        # 定义批处理参数
        batch_size = 50  # 每批处理50只股票，可以根据你的机器内存调整
        batch_quotes_list = []
        # 改为串行循环
        for i, code in enumerate(target_codes):
            ak_code = code.split('.')[1]
            logger.info(f"进度: [{i+1}/{len(target_codes)}] 正在获取 {code}...")
            try:
                df_normal = ak.stock_zh_a_hist(symbol=ak_code, period="daily", start_date=start_date_str, end_date=end_date_str, adjust="")
                time.sleep(1.6) # 增加礼貌性延时，降低被封风险
                df_hfq = ak.stock_zh_a_hist(symbol=ak_code, period="daily", start_date=start_date_str, end_date=end_date_str, adjust="hfq")
              
                if df_normal.empty or df_hfq.empty:
                    continue
 
                df = pd.merge(df_normal, df_hfq[['日期', '收盘']], on='日期', suffixes=('', '_hfq'))
                df['复权因子'] = df.apply(lambda row: row['收盘_hfq'] / row['收盘'] if row['收盘'] and row['收盘'] != 0 else 0, axis=1)
                df['stock_code'] = code
                batch_quotes_list.append(df)
              
                time.sleep(1.4) # 增加礼貌性延时，降低被封风险
 
            except Exception as e:
                self._log_and_save(f"获取 {code} 日线行情失败: {e}", level=SystemLog.LogLevelChoices.WARNING)
                continue
 
        # 检查是否达到批处理大小，或者已经是最后一只股票
            if (i + 1) % batch_size == 0 or (i + 1) == len(target_codes):
                if not batch_quotes_list:
                    continue # 如果这个批次是空的，就跳过

                self._log_and_save(f"处理批次 {i//batch_size + 1}，包含 {len(batch_quotes_list)} 只股票...")
              
                # 1. 合并当前批次的数据
                batch_master_df = pd.concat(batch_quotes_list, ignore_index=True)
              
                # 2. 将这个批次的数据存入数据库
                self._save_quotes_df_to_db(batch_master_df)
              
                # 3. 清空批次列表，释放内存，为下一批做准备
                batch_quotes_list = []
                self._log_and_save(f"批次 {i//batch_size + 1} 处理完毕，内存已释放。")
 
        self._log_and_save("A股数据更新任务全部执行完毕。")

    def query_stock_info(self, stock_codes: list[str] = None) -> dict[str, StockInfo]:
        """
        2. 查询本地A股基础信息
        直接查询 tb_stock_info。
        """
        queryset = StockInfo.objects.all()
        if stock_codes:
            queryset = queryset.filter(stock_code__in=stock_codes)
    
        return {stock.stock_code: stock for stock in queryset}

    def query_daily_quotes(
        self, 
        stock_codes: list[str] = None, 
        start_date: str = None, 
        end_date: str = None
    ) -> dict[str, list[DailyQuotes]]:
        """
        3. 查询本地A股交易信息
        直接查询 tb_daily_quotes。
        """
        # 设置默认日期为今天
        today = datetime.date.today()
        start_date = start_date or today.strftime('%Y-%m-%d')
        end_date = end_date or today.strftime('%Y-%m-%d')

        # 使用 select_related 优化查询，一次性获取关联的 StockInfo 对象
        # 使用 order_by 确保数据按股票和日期排序，便于后续分组
        queryset = DailyQuotes.objects.select_related('stock_code').filter(
            trade_date__gte=start_date,
            trade_date__lte=end_date
        ).order_by('stock_code', 'trade_date')

        if stock_codes:
            queryset = queryset.filter(stock_code__in=stock_codes)
    
        # 构建输出字典
        result = {}
        for quote in queryset:
            # 使用 stock_code_id 避免再次访问数据库
            # setdefault 是构建这种分组字典的优雅方式
            result.setdefault(quote.stock_code_id, []).append(quote)
        
        return result

    #清空所有数据
    def clear_all_data(self):
        with connection.cursor() as cursor:
            cursor.execute(f"DELETE FROM tb_daily_factor_values;")
            cursor.execute(f"DELETE FROM tb_daily_quotes;")
            cursor.execute(f"DELETE FROM tb_daily_trading_plan;")
            cursor.execute(f"DELETE FROM tb_factor_definitions;")
            cursor.execute(f"DELETE FROM tb_positions;")
            cursor.execute(f"DELETE FROM tb_stock_info;")
            cursor.execute(f"DELETE FROM tb_strategy_parameters;")
            cursor.execute(f"DELETE FROM tb_system_log;")
            cursor.execute(f"DELETE FROM tb_trade_log;")
####文件结束####

####selection_manager\__init__.py####

####文件结束####

####selection_manager\admin.py####
from django.contrib import admin

# Register your models here.

####文件结束####

####selection_manager\apps.py####
from django.apps import AppConfig


class SelectionManagerConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'selection_manager'

####文件结束####

####selection_manager\models.py####
from django.db import models

# Create your models here.

####文件结束####

####selection_manager\tests.py####
from django.test import TestCase

# Create your tests here.

####文件结束####

####selection_manager\urls.py####
"""
URL configuration for autoTrade project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path,include
from . import views
urlpatterns = [
    path('initSelectionStratage', views.init_strategy),
    path('runSelection',views.run_selection)
]

####文件结束####

####selection_manager\views.py####
from datetime import date,datetime
from django.shortcuts import render
from django.http.response import JsonResponse
from selection_manager.service.selection_service import SelectionService
import json
from django.views.decorators.http import require_http_methods
# Create your views here.
@require_http_methods(["GET"])
def init_strategy(request):
    SelectionService.initialize_strategy()
    result={}
    return JsonResponse(result)
@require_http_methods(["POST"])
def run_selection(request):
    if request.method=='POST':
        body= json.loads(request.body)
        selection_date=datetime.strptime(body['date'], "%Y-%m-%d").date()
        service=SelectionService(selection_date,mode=body['mode'])
        service.run_selection()
        return JsonResponse({
            'type':selection_date,
            'data':json.loads(request.body)
        })
  

####文件结束####

####selection_manager\management\commands\prime_market_regime_cache.py####
# selection_manager/management/commands/prime_market_regime_cache.py

import logging
import time
from datetime import date, timedelta

import pandas as pd
from django.core.management.base import BaseCommand
from django.db import transaction
from decimal import Decimal

from common.models import DailyQuotes, StockInfo, DailyFactorValues, StrategyParameters
from selection_manager.service.selection_service import MARKET_INDICATOR_CODE

# 配置日志
logger = logging.getLogger('prime_market_regime_cache')

# 尝试导入GPU库
try:
    import cudf
    import cupy as cp
    GPU_AVAILABLE = True
    logger.info("cuDF 和 cuPy 库已找到，将使用 GPU 进行计算。")
except ImportError:
    GPU_AVAILABLE = False
    logger.warning("未找到 cuDF 或 cuPy 库。此命令需要GPU环境。请安装相关依赖后重试。")
    logger.warning("参考安装: conda install -c rapidsai -c nvidia -c conda-forge cudf cupy")


class Command(BaseCommand):
    help = '使用GPU预热市场状态M(t)的历史数据缓存，用于首次运行或数据回补。'

    def add_arguments(self, parser):
        parser.add_argument(
            '--days',
            type=int,
            default=750,
            help='要预热的交易日天数，默认为750 (约3年)。'
        )
        parser.add_argument(
            '--end_date',
            type=str,
            # default=date.today().isoformat(),
            default="2023-04-30",
            help='预热的结束日期，默认为今天。格式: YYYY-MM-DD'
        )

    def handle(self, *args, **options):
        if not GPU_AVAILABLE:
            self.stdout.write(self.style.ERROR("GPU环境不可用，命令终止。"))
            return

        days_to_prime = options['days']
        end_date = date.fromisoformat(options['end_date'])
      
        self.stdout.write(self.style.SUCCESS(f"===== 开始M(t)缓存预热任务 (GPU模式) ====="))
        self.stdout.write(f"预热周期: {days_to_prime} 个交易日, 截止日期: {end_date}")
      
        total_start_time = time.time()

        # 1. 获取所需参数和交易日历
        params = {p.param_name: float(p.param_value) for p in StrategyParameters.objects.filter(param_name__startswith='dynamic_')}
        min_liquidity = params.get('dynamic_min_liquidity', 100000000)
        lookback_new_stock = int(params.get('dynamic_lookback_new_stock', 60))

        trade_dates = list(DailyQuotes.objects.filter(trade_date__lte=end_date)
                           .values_list('trade_date', flat=True).distinct().order_by('-trade_date')[:days_to_prime + 60])
        trade_dates.reverse()

        if not trade_dates:
            self.stdout.write(self.style.ERROR("数据库中无交易日数据，无法预热。"))
            return

        # 2. 加载全周期数据到Pandas
        self.stdout.write("正在从数据库加载全周期行情数据到内存...")
        start_load_time = time.time()
        all_quotes_qs = DailyQuotes.objects.filter(trade_date__in=trade_dates).values(
            'trade_date', 'stock_code_id', 'close', 'turnover', 'hfq_close'
        )
        all_stocks_qs = StockInfo.objects.values('stock_code', 'listing_date', 'stock_name')
      
        df_quotes = pd.DataFrame.from_records(all_quotes_qs)
        df_stocks = pd.DataFrame.from_records(all_stocks_qs)
      
        df_quotes['trade_date'] = pd.to_datetime(df_quotes['trade_date'])
        df_stocks['listing_date'] = pd.to_datetime(df_stocks['listing_date'])
      
        df = pd.merge(df_quotes, df_stocks, left_on='stock_code_id', right_on='stock_code')
        load_duration = time.time() - start_load_time
        self.stdout.write(f"数据加载完成，共 {len(df)} 条记录，耗时: {load_duration:.2f} 秒。")

        # 3. 数据传输到GPU
        self.stdout.write("正在将数据传输到GPU显存...")
        start_gpu_transfer_time = time.time()
        gdf = cudf.from_pandas(df)
        gpu_transfer_duration = time.time() - start_gpu_transfer_time
        self.stdout.write(f"数据成功传输到GPU，耗时: {gpu_transfer_duration:.2f} 秒。")

        # 4. 在GPU上进行计算
        self.stdout.write("正在GPU上并行计算所有日期的M(t)基础指标...")
        start_gpu_calc_time = time.time()
      
        # GPU计算逻辑
        results = []
        # 我们只对最近 `days_to_prime` 天进行计算和保存
        for calc_date in pd.to_datetime(trade_dates[-days_to_prime:]):
            # a. 当日筛选
            gdf_today = gdf[gdf['trade_date'] == calc_date]
          
            # 剔除ST
            gdf_today = gdf_today[~gdf_today['stock_name'].str.contains('ST')]
          
            # 剔除次新股
            min_listing_date = calc_date - timedelta(days=lookback_new_stock)
            gdf_today = gdf_today[gdf_today['listing_date'] < min_listing_date]
          
            # 剔除低流动性
            start_liquidity_date = calc_date - timedelta(days=40) # 多取一些数据
            gdf_liquidity_period = gdf[(gdf['trade_date'] >= start_liquidity_date) & (gdf['trade_date'] <= calc_date)]
          
            # 获取最近20个交易日
            recent_20_days = gdf_liquidity_period['trade_date'].unique().nlargest(20)
            gdf_liquidity_period = gdf_liquidity_period[gdf_liquidity_period['trade_date'].isin(recent_20_days)]
          
            avg_turnover = gdf_liquidity_period.groupby('stock_code_id')['turnover'].mean()
            liquid_stocks = avg_turnover[avg_turnover >= min_liquidity].index
          
            gdf_today = gdf_today[gdf_today['stock_code_id'].isin(liquid_stocks)]
          
            if gdf_today.empty:
                continue

            # b. 获取用于计算指标的历史窗口数据
            start_hist_date = calc_date - timedelta(days=120) # 넉넉하게 120일
            gdf_hist = gdf[(gdf['trade_date'] >= start_hist_date) & (gdf['trade_date'] <= calc_date)]
            gdf_hist = gdf_hist[gdf_hist['stock_code_id'].isin(gdf_today['stock_code_id'])]

            # c. 计算指标
            # M1: 创60日新高占比
            gdf_hist_60d = gdf_hist[gdf_hist['trade_date'].isin(gdf_hist['trade_date'].unique().nlargest(60))]
            high60 = gdf_hist_60d.groupby('stock_code_id')['close'].max()
            merged_m1 = gdf_today.merge(high60.rename('high60'), on='stock_code_id')
            m1 = (merged_m1['close'] >= merged_m1['high60']).sum() / len(merged_m1) if len(merged_m1) > 0 else 0

            # M2: MA60之上占比
            ma60 = gdf_hist_60d.groupby('stock_code_id')['close'].mean()
            merged_m2 = gdf_today.merge(ma60.rename('ma60'), on='stock_code_id')
            m2 = (merged_m2['close'] > merged_m2['ma60']).sum() / len(merged_m2) if len(merged_m2) > 0 else 0
          
            # M3: 60日回报率中位数
            date_t_minus_60 = gdf_hist_60d['trade_date'].unique().nsmallest(1).iloc[0]
            close_t = gdf_today[['stock_code_id', 'hfq_close']].set_index('stock_code_id')
            close_t_minus_60 = gdf_hist_60d[gdf_hist_60d['trade_date'] == date_t_minus_60][['stock_code_id', 'hfq_close']].set_index('stock_code_id')
            ret60 = (close_t / close_t_minus_60 - 1).dropna()
            m3 = ret60['hfq_close'].median() if not ret60.empty else 0

            # M4: 20日平均波动率
            gdf_hist_20d = gdf_hist[gdf_hist['trade_date'].isin(gdf_hist['trade_date'].unique().nlargest(20))]
            gdf_hist_20d = gdf_hist_20d.sort_values(by=['stock_code_id', 'trade_date'])
            returns = gdf_hist_20d.groupby('stock_code_id')['hfq_close'].pct_change().dropna()
            vol20 = gdf_hist_20d.merge(returns.rename('returns'), left_index=True, right_index=True).groupby('stock_code_id')['returns'].std()
            m4 = vol20.mean() if not vol20.empty else 0

            results.append({
                'trade_date': calc_date.date(),
                'dynamic_M1_RAW': float(m1),
                'dynamic_M2_RAW': float(m2),
                'dynamic_M3_RAW': float(m3) if m3 is not None else 0.0,
                'dynamic_M4_RAW': float(m4) if m4 is not None else 0.0,
            })
            self.stdout.write(f"  - 完成日期 {calc_date.date()} 的计算。")

        gpu_calc_duration = time.time() - start_gpu_calc_time
        self.stdout.write(f"GPU计算完成，耗时: {gpu_calc_duration:.2f} 秒。")

        # 5. 结果批量存入数据库
        self.stdout.write("正在将计算结果批量写入数据库缓存...")
        start_db_write_time = time.time()
      
        records_to_create = []
        for res in results:
            trade_date_res = res['trade_date']
            for factor_code_suffix, value in res.items():
                if factor_code_suffix == 'trade_date': continue
                if pd.notna(value):
                    records_to_create.append(DailyFactorValues(
                        stock_code_id=MARKET_INDICATOR_CODE,
                        trade_date=trade_date_res,
                        factor_code_id=factor_code_suffix,
                        raw_value=Decimal(str(value))
                    ))
      
        with transaction.atomic():
            # 先删除，再插入，保证幂等性
            dates_in_results = [r['trade_date'] for r in results]
            DailyFactorValues.objects.filter(
                stock_code_id=MARKET_INDICATOR_CODE,
                trade_date__in=dates_in_results
            ).delete()
            DailyFactorValues.objects.bulk_create(records_to_create, batch_size=500)

        db_write_duration = time.time() - start_db_write_time
        self.stdout.write(f"数据库写入完成，共 {len(records_to_create)} 条记录，耗时: {db_write_duration:.2f} 秒。")

        total_duration = time.time() - total_start_time
        self.stdout.write(self.style.SUCCESS(f"===== M(t)缓存预热任务成功完成！总耗时: {total_duration:.2f} 秒 ====="))


####文件结束####

####selection_manager\service\selection_service.py####
# selection_manager/service/selection_service.py

import logging
from datetime import date, timedelta
from decimal import Decimal

import numpy as np
import pandas as pd
import pandas_ta as ta
from scipy.stats import linregress

from django.db import transaction
from django.utils import timezone

from common.models import (
    StockInfo, DailyQuotes, SystemLog, FactorDefinitions, DailyFactorValues,
    StrategyParameters, DailyTradingPlan
)

# region: 全局配置
MODULE_NAME = '日终选股与预案模块(动态版)'
logger = logging.getLogger(__name__)
MARKET_INDICATOR_CODE = '_MARKET_REGIME_INDICATOR_'
# endregion


class SelectionService:
    """
    T-1日收盘后运行的动态自适应选股与预案生成服务。
  
    该服务实现了 f_dynamic(x, t) 选股评分函数，能够根据市场状态 M(t)
    动态调整选股策略的维度权重，以适应不同的市场环境。
    """

    def __init__(self, trade_date: date, mode: str = 'realtime'):
        """
        初始化选股服务。

        :param trade_date: T-1日，即执行计算的当天日期。
        :param mode: 运行模式, 'realtime' 或 'backtest'。
        """
        if mode not in ['realtime', 'backtest']:
            raise ValueError("模式(mode)必须是 'realtime' 或 'backtest'")

        self.trade_date = trade_date
        self.mode = mode
        self.dynamic_params = {}
        self.dynamic_factor_defs = {}
      
        # 市场状态与动态权重
        self.market_regime_M = 0.0
        self.dynamic_weights = {}

        # 面板数据
        self.panel_open = None
        self.panel_high = None
        self.panel_low = None
        self.panel_close = None
        self.panel_volume = None
        self.panel_turnover = None
        self.panel_hfq_close = None

        logger.debug(f"--- SelectionService(动态版) 初始化 ---")
        logger.debug(f"交易日期 (T-1): {self.trade_date}")
        logger.debug(f"运行模式: {self.mode}")

    # region: --- 1. 主流程与入口方法 ---

    @staticmethod
    def initialize_strategy():
        """
        初始化动态策略所需的因子定义和参数到数据库。
        这是一个幂等操作，可以重复运行。
        """
        logger.debug("开始初始化动态策略：铺底因子定义和策略参数...")

        # 1. 确保市场指标的特殊股票代码存在
        try:
            StockInfo.objects.get_or_create(
                stock_code=MARKET_INDICATOR_CODE,
                defaults={
                    'stock_name': '市场状态指标',
                    'listing_date': date(1990, 1, 1),
                    'status': StockInfo.StatusChoices.LISTING
                }
            )
            logger.debug(f"特殊股票代码 '{MARKET_INDICATOR_CODE}' 已确认存在。")
        except Exception as e:
            logger.error(f"创建特殊股票代码 '{MARKET_INDICATOR_CODE}' 失败: {e}")
            # 这是一个关键步骤，如果失败则不应继续
            return

        # 2. 定义所有因子 (包括M(t)缓存因子和个股因子)
        factors_to_define = [
            # M(t) 缓存因子
            {'factor_code': 'dynamic_M_VALUE', 'factor_name': '动态-市场状态M(t)最终值', 'direction': 'positive'},
            {'factor_code': 'dynamic_M1_RAW', 'factor_name': '动态-M1原始值(新高占比)', 'direction': 'positive'},
            {'factor_code': 'dynamic_M2_RAW', 'factor_name': '动态-M2原始值(MA60之上占比)', 'direction': 'positive'},
            {'factor_code': 'dynamic_M3_RAW', 'factor_name': '动态-M3原始值(60日回报中位数)', 'direction': 'positive'},
            {'factor_code': 'dynamic_M4_RAW', 'factor_name': '动态-M4原始值(20日平均波动率)', 'direction': 'negative'},
          
            # 趋势动能 (MT) 维度因子
            {'factor_code': 'dynamic_MA20_SLOPE', 'factor_name': '动态-20日均线斜率', 'direction': 'positive'},
            {'factor_code': 'dynamic_MA_SCORE', 'factor_name': '动态-均线排列评分', 'direction': 'positive'},
            {'factor_code': 'dynamic_ADX_CONFIRM', 'factor_name': '动态-ADX趋势确认', 'direction': 'positive'},
          
            # 强势突破 (BO) 维度因子
            {'factor_code': 'dynamic_BREAKOUT_PWR', 'factor_name': '动态-突破强度', 'direction': 'positive'},
            {'factor_code': 'dynamic_VOLUME_SURGE', 'factor_name': '动态-成交量激增', 'direction': 'positive'},
            {'factor_code': 'dynamic_MOM_ACCEL', 'factor_name': '动态-动能加速度', 'direction': 'positive'},

            # 均值回归 (MR) 维度因子
            {'factor_code': 'dynamic_RSI_OS', 'factor_name': '动态-短期超卖(RSI14)', 'direction': 'negative'},
            {'factor_code': 'dynamic_NEG_DEV', 'factor_name': '动态-负向偏离度(vs MA60)', 'direction': 'negative'},
            {'factor_code': 'dynamic_BOLL_LB', 'factor_name': '动态-布林下轨支撑', 'direction': 'negative'},

            # 质量防御 (QD) 维度因子
            {'factor_code': 'dynamic_LOW_VOL', 'factor_name': '动态-低波动率(20日)', 'direction': 'negative'},
            {'factor_code': 'dynamic_MAX_DD', 'factor_name': '动态-最大回撤控制(60日)', 'direction': 'negative'},
            {'factor_code': 'dynamic_DOWNSIDE_RISK', 'factor_name': '动态-下行风险(60日)', 'direction': 'negative'},
        ]
        with transaction.atomic():
            for factor_data in factors_to_define:
                FactorDefinitions.objects.update_or_create(
                    factor_code=factor_data['factor_code'],
                    defaults={'factor_name': factor_data['factor_name'], 'direction': factor_data['direction'], 'is_active': True}
                )
        logger.debug(f"成功初始化/更新 {len(factors_to_define)} 个动态因子定义。")

        # 3. 定义所有参数 (使用 'dynamic_' 前缀)
        parameters_to_define = {
            # M(t) 参数
            'dynamic_w_m1': {'value': '0.3', 'group': 'M_WEIGHTS', 'desc': 'M(t)指标权重: M1-创60日新高占比'},
            'dynamic_w_m2': {'value': '0.3', 'group': 'M_WEIGHTS', 'desc': 'M(t)指标权重: M2-MA60之上占比'},
            'dynamic_w_m3': {'value': '0.25', 'group': 'M_WEIGHTS', 'desc': 'M(t)指标权重: M3-60日回报率中位数'},
            'dynamic_w_m4': {'value': '0.15', 'group': 'M_WEIGHTS', 'desc': 'M(t)指标权重: M4-20日平均波动率'},
            'dynamic_m_lookback': {'value': '750', 'group': 'M_PARAMS', 'desc': 'M(t)历史回看周期(约3年)'},

            # 动态权重 N_i(M(t)) 参数
            'dynamic_c_MT': {'value': '1.0', 'group': 'N_ATTRACTION', 'desc': '吸引力函数强度系数: 趋势动能'},
            'dynamic_c_BO': {'value': '1.0', 'group': 'N_ATTRACTION', 'desc': '吸引力函数强度系数: 强势突破'},
            'dynamic_c_QD': {'value': '1.0', 'group': 'N_ATTRACTION', 'desc': '吸引力函数强度系数: 质量防御'},
            'dynamic_c_MR': {'value': '1.0', 'group': 'N_ATTRACTION', 'desc': '吸引力函数强度系数: 均值回归'},
            'dynamic_sigma_MR': {'value': '0.3', 'group': 'N_PARAMS', 'desc': '均值回归策略适用范围宽度'},
            'dynamic_tau': {'value': '0.5', 'group': 'N_PARAMS', 'desc': 'Softmax温度系数(控制切换灵敏度)'},

            # 维度内部因子权重 (k_ij)
            'dynamic_k_MT1': {'value': '0.4', 'group': 'K_WEIGHTS_MT', 'desc': '趋势动能-MA20斜率权重'},
            'dynamic_k_MT2': {'value': '0.3', 'group': 'K_WEIGHTS_MT', 'desc': '趋势动能-均线排列权重'},
            'dynamic_k_MT3': {'value': '0.3', 'group': 'K_WEIGHTS_MT', 'desc': '趋势动能-ADX确认权重'},
            'dynamic_k_BO1': {'value': '0.4', 'group': 'K_WEIGHTS_BO', 'desc': '强势突破-突破强度权重'},
            'dynamic_k_BO2': {'value': '0.4', 'group': 'K_WEIGHTS_BO', 'desc': '强势突破-成交量激增权重'},
            'dynamic_k_BO3': {'value': '0.2', 'group': 'K_WEIGHTS_BO', 'desc': '强势突破-动能加速度权重'},
            'dynamic_k_MR1': {'value': '0.4', 'group': 'K_WEIGHTS_MR', 'desc': '均值回归-RSI超卖权重'},
            'dynamic_k_MR2': {'value': '0.3', 'group': 'K_WEIGHTS_MR', 'desc': '均值回归-负向偏离度权重'},
            'dynamic_k_MR3': {'value': '0.3', 'group': 'K_WEIGHTS_MR', 'desc': '均值回归-布林下轨支撑权重'},
            'dynamic_k_QD1': {'value': '0.4', 'group': 'K_WEIGHTS_QD', 'desc': '质量防御-低波动率权重'},
            'dynamic_k_QD2': {'value': '0.3', 'group': 'K_WEIGHTS_QD', 'desc': '质量防御-最大回撤权重'},
            'dynamic_k_QD3': {'value': '0.3', 'group': 'K_WEIGHTS_QD', 'desc': '质量防御-下行风险权重'},
          
            # 交易预案参数
            'dynamic_k_drop': {'value': '0.3', 'group': 'PLAN_PARAMS', 'desc': 'MIOP低开容忍系数'},
            'dynamic_k_gap': {'value': '0.5', 'group': 'PLAN_PARAMS', 'desc': 'MAOP高开容忍系数'},
          
            # 筛选与计算参数
            'dynamic_lookback_new_stock': {'value': '60', 'group': 'FILTERS', 'desc': '次新股定义天数(自然日)'},
            'dynamic_min_liquidity': {'value': '100000000', 'group': 'FILTERS', 'desc': '最低日均成交额(元)'},
            'dynamic_top_n': {'value': '10', 'group': 'SELECTION', 'desc': '最终选取股票数量'},
        }
        with transaction.atomic():
            for name, data in parameters_to_define.items():
                StrategyParameters.objects.update_or_create(
                    param_name=name,
                    defaults={
                        'param_value': Decimal(data['value']),
                        'group_name': data['group'],
                        'description': data['desc']
                    }
                )
        logger.debug(f"成功初始化/更新 {len(parameters_to_define)} 个动态策略参数。")
        logger.debug("动态策略初始化完成。")

    def run_selection(self):
        """
        一键启动全流程的入口方法。
        """
        ta.Imports["verbose"] = False
        self._log_to_db('INFO', f"动态选股流程启动。模式: {self.mode}, 日期: {self.trade_date}")
        try:
            self._load_dynamic_parameters_and_defs()
            initial_stock_pool = self._initial_screening()
            if not initial_stock_pool:
                self._log_to_db('WARNING', "初步筛选后无符合条件的股票，流程终止。")
                return

            # 核心动态逻辑
            self.market_regime_M = self._calculate_market_regime_M(initial_stock_pool)
            self.dynamic_weights = self._calculate_dynamic_weights(self.market_regime_M)
          
            self._load_market_data(initial_stock_pool)
            raw_factors_df = self._calculate_all_dynamic_factors()
            norm_scores_df = self._standardize_factors(raw_factors_df)
          
            dimension_scores_df = self._calculate_dimension_scores(norm_scores_df)
            final_scores = self._calculate_final_dynamic_score(dimension_scores_df, self.dynamic_weights)
          
            trading_plan = self._generate_trading_plan(final_scores)
            if trading_plan.empty:
                self._log_to_db('WARNING', "最终未生成任何交易预案。")
                return

            self._save_results(raw_factors_df, norm_scores_df, trading_plan)

            success_msg = f"动态选股流程成功完成。M(t)={self.market_regime_M:.4f}, 生成 {len(trading_plan)} 条交易预案。"
            logger.info(success_msg)
            self._log_to_db('INFO', success_msg)

        except Exception as e:
            error_msg = f"动态选股流程发生严重错误: {e}"
            logger.critical(error_msg, exc_info=True)
            self._log_to_db('CRITICAL', error_msg)
            raise

    # endregion

    # region: --- 2. 核心动态逻辑实现 ---

    def _calculate_market_regime_M(self, stock_pool: list[str]) -> float:
        """
        计算市场状态函数 M(t)，使用数据库缓存机制进行增量计算。
        """
        logger.debug("开始计算市场状态 M(t)...")
      
        # 1. 检查当日缓存
        try:
            cached_m = DailyFactorValues.objects.get(
                stock_code_id=MARKET_INDICATOR_CODE,
                trade_date=self.trade_date,
                factor_code_id='dynamic_M_VALUE'
            )
            m_value = float(cached_m.raw_value)
            logger.debug(f"成功从缓存中读取当日 M(t) = {m_value:.4f}")
            return m_value
        except DailyFactorValues.DoesNotExist:
            logger.debug("当日 M(t) 缓存未命中，开始增量计算...")

        # 2. 缓存未命中，进行计算
        lookback_days = int(self.dynamic_params['dynamic_m_lookback'])
        all_trade_dates = self._get_market_trade_dates(lookback_days)
        if not all_trade_dates:
            raise ValueError("无法获取历史交易日历，无法计算M(t)")

        # 3. 获取历史缓存的原始指标值
        m_factor_codes = ['dynamic_M1_RAW', 'dynamic_M2_RAW', 'dynamic_M3_RAW', 'dynamic_M4_RAW']
        cached_raw_values_qs = DailyFactorValues.objects.filter(
            stock_code_id=MARKET_INDICATOR_CODE,
            trade_date__in=all_trade_dates,
            factor_code_id__in=m_factor_codes
        ).values('trade_date', 'factor_code_id', 'raw_value')

        cached_df = pd.DataFrame.from_records(cached_raw_values_qs)
        if not cached_df.empty:
            cached_pivot = cached_df.pivot(index='trade_date', columns='factor_code_id', values='raw_value').astype(float)
        else:
            cached_pivot = pd.DataFrame(columns=m_factor_codes)

        # 4. 找出需要重新计算的日期
        dates_to_calculate = sorted(list(set(all_trade_dates) - set(cached_pivot.index)))
        logger.debug(f"需要重新计算 {len(dates_to_calculate)} 天的 M(t) 基础指标。")

        # 5. 对缺失日期进行计算
        newly_calculated_data = []
        if dates_to_calculate:
            # 只加载计算 M(t) 所需的数据
            self._load_market_data(stock_pool, for_m_calc=True)
            for calc_date in dates_to_calculate:
                m1, m2, m3, m4 = self._calculate_m_indicators_for_date(calc_date)
                newly_calculated_data.append({
                    'trade_date': calc_date,
                    'dynamic_M1_RAW': m1, 'dynamic_M2_RAW': m2,
                    'dynamic_M3_RAW': m3, 'dynamic_M4_RAW': m4
                })
                logger.debug(f"已完成计算{len(newly_calculated_data)}/ {len(dates_to_calculate)} 天")
      
        # 6. 合并新旧数据并存入缓存
        if newly_calculated_data:
            new_df = pd.DataFrame(newly_calculated_data).set_index('trade_date')
            self._save_m_raw_values_to_cache(new_df)
            # 合并到总的DataFrame
            if cached_pivot.empty:
                history_raw_df = new_df.sort_index()
            else:
                history_raw_df = pd.concat([cached_pivot, new_df]).sort_index()
        else:
            history_raw_df = cached_pivot.sort_index()

        # 7. 标准化并合成最终 M(t)
        current_raw = history_raw_df.loc[self.trade_date]
      
        m1_norm = self._norm_timeseries(current_raw['dynamic_M1_RAW'], history_raw_df['dynamic_M1_RAW'], 'positive')
        m2_norm = self._norm_timeseries(current_raw['dynamic_M2_RAW'], history_raw_df['dynamic_M2_RAW'], 'positive')
        m3_norm = self._norm_timeseries(current_raw['dynamic_M3_RAW'], history_raw_df['dynamic_M3_RAW'], 'positive')
        m4_norm = self._norm_timeseries(current_raw['dynamic_M4_RAW'], history_raw_df['dynamic_M4_RAW'], 'negative')

        m_t = (
            m1_norm * self.dynamic_params['dynamic_w_m1'] +
            m2_norm * self.dynamic_params['dynamic_w_m2'] +
            m3_norm * self.dynamic_params['dynamic_w_m3'] +
            m4_norm * self.dynamic_params['dynamic_w_m4']
        )
      
        # 8. 缓存最终的 M(t) 值
        DailyFactorValues.objects.update_or_create(
            stock_code_id=MARKET_INDICATOR_CODE,
            trade_date=self.trade_date,
            factor_code_id='dynamic_M_VALUE',
            defaults={'raw_value': Decimal(str(m_t)), 'norm_score': Decimal(str(m_t))}
        )
        logger.info(f"M(t) 计算完成，值为: {m_t:.4f}，并已存入缓存。")
        return m_t

    def _calculate_m_indicators_for_date(self, calc_date: date) -> tuple:
        """为特定一天计算M(t)的四个基础指标原始值"""
        # 获取当天的面板数据切片
        close_slice = self.panel_close.loc[:calc_date]
        hfq_close_slice = self.panel_hfq_close.loc[:calc_date]
      
        if close_slice.empty: return np.nan, np.nan, np.nan, np.nan

        # M1: 创60日新高占比
        high60 = close_slice.rolling(60, min_periods=1).max()
        is_new_high = close_slice.iloc[-1] == high60.iloc[-1]
        m1 = is_new_high.sum() / is_new_high.count() if is_new_high.count() > 0 else 0

        # M2: MA60之上占比
        ma60 = close_slice.rolling(60, min_periods=1).mean()
        above_ma60 = close_slice.iloc[-1] > ma60.iloc[-1]
        m2 = above_ma60.sum() / above_ma60.count() if above_ma60.count() > 0 else 0

        # M3: 60日回报率中位数
        if len(hfq_close_slice) >= 60:
            ret60 = hfq_close_slice.iloc[-1] / hfq_close_slice.iloc[-60] - 1
            m3 = ret60.median()
        else:
            m3 = np.nan

        # M4: 20日平均波动率
        if len(hfq_close_slice) >= 20:
            daily_ret = hfq_close_slice.pct_change(fill_method=None)
            vol20 = daily_ret.rolling(20, min_periods=1).std()
            m4 = vol20.iloc[-1].mean()
        else:
            m4 = np.nan
          
        return m1, m2, m3, m4

    def _norm_timeseries(self, value, history_series, direction):
        """对时间序列数据进行标准化"""
        # 使用T-1及之前的数据来计算分位数，作为T日的评价标准
        # history_series 是按时间升序排列的
        historical_benchmark = history_series.iloc[:-1] 
      
        if historical_benchmark.count() < 2: return 0.0 # 如果历史数据太少，也无法定标
        p1 = historical_benchmark.quantile(0.01)
        p99 = historical_benchmark.quantile(0.99)
      
        if (p99 - p1) < 1e-9: return 0.0
      
        value_prime = np.clip(value, p1, p99)
      
        if direction == 'positive':
            return ((value_prime - p1) / (p99 - p1)) * 2 - 1
        else: # negative
            return ((p99 - value_prime) / (p99 - p1)) * 2 - 1

    def _save_m_raw_values_to_cache(self, df: pd.DataFrame):
        """将新计算的M指标原始值批量存入数据库"""
        records = []
        for trade_date, row in df.iterrows():
            for factor_code, raw_value in row.items():
                if pd.notna(raw_value):
                    records.append(DailyFactorValues(
                        stock_code_id=MARKET_INDICATOR_CODE,
                        trade_date=trade_date,
                        factor_code_id=factor_code,
                        raw_value=Decimal(str(raw_value)),
                        norm_score=Decimal(str(raw_value)) # 原始值缓存，norm_score字段可复用
                    ))
        if records:
            DailyFactorValues.objects.bulk_create(records, ignore_conflicts=True)
            logger.debug(f"成功将 {len(records)} 条M(t)基础指标原始值存入缓存。")

    def _calculate_dynamic_weights(self, M_t: float) -> dict:
        """根据M(t)计算四个策略维度的动态权重"""
        logger.debug(f"根据 M(t)={M_t:.4f} 计算动态权重...")
        p = self.dynamic_params
      
        # a. 计算各维度吸引力 A_i
        A_MT = p['dynamic_c_MT'] * M_t
        A_BO = p['dynamic_c_BO'] * M_t
        A_QD = p['dynamic_c_QD'] * (-M_t)
        A_MR = p['dynamic_c_MR'] * np.exp(- (M_t / p['dynamic_sigma_MR'])**2)
      
        # b. 通过Softmax计算最终权重 N_i
        tau = p['dynamic_tau']
        exp_A_MT = np.exp(A_MT / tau)
        exp_A_BO = np.exp(A_BO / tau)
        exp_A_QD = np.exp(A_QD / tau)
        exp_A_MR = np.exp(A_MR / tau)
      
        sum_exp_A = exp_A_MT + exp_A_BO + exp_A_QD + exp_A_MR
      
        weights = {
            'MT': exp_A_MT / sum_exp_A,
            'BO': exp_A_BO / sum_exp_A,
            'QD': exp_A_QD / sum_exp_A,
            'MR': exp_A_MR / sum_exp_A,
        }
        logger.debug(f"动态权重计算完成: MT={weights['MT']:.2%}, BO={weights['BO']:.2%}, MR={weights['MR']:.2%}, QD={weights['QD']:.2%}")
        return weights

    def _calculate_dimension_scores(self, norm_scores_df: pd.DataFrame) -> pd.DataFrame:
        """计算四个策略维度的得分"""
        logger.debug("计算各策略维度得分...")
        p = self.dynamic_params
        scores = pd.DataFrame(index=norm_scores_df.index)

        scores['Score_MT'] = (
            norm_scores_df['dynamic_MA20_SLOPE'] * p['dynamic_k_MT1'] +
            norm_scores_df['dynamic_MA_SCORE'] * p['dynamic_k_MT2'] +
            norm_scores_df['dynamic_ADX_CONFIRM'] * p['dynamic_k_MT3']
        )
        scores['Score_BO'] = (
            norm_scores_df['dynamic_BREAKOUT_PWR'] * p['dynamic_k_BO1'] +
            norm_scores_df['dynamic_VOLUME_SURGE'] * p['dynamic_k_BO2'] +
            norm_scores_df['dynamic_MOM_ACCEL'] * p['dynamic_k_BO3']
        )
        scores['Score_MR'] = (
            norm_scores_df['dynamic_RSI_OS'] * p['dynamic_k_MR1'] +
            norm_scores_df['dynamic_NEG_DEV'] * p['dynamic_k_MR2'] +
            norm_scores_df['dynamic_BOLL_LB'] * p['dynamic_k_MR3']
        )
        scores['Score_QD'] = (
            norm_scores_df['dynamic_LOW_VOL'] * p['dynamic_k_QD1'] +
            norm_scores_df['dynamic_MAX_DD'] * p['dynamic_k_QD2'] +
            norm_scores_df['dynamic_DOWNSIDE_RISK'] * p['dynamic_k_QD3']
        )
        return scores

    def _calculate_final_dynamic_score(self, dimension_scores_df: pd.DataFrame, weights: dict) -> pd.Series:
        """计算最终的 f_dynamic 得分"""
        logger.debug("计算最终综合得分 f_dynamic(x, t)...")
        final_score = (
            dimension_scores_df['Score_MT'] * weights['MT'] +
            dimension_scores_df['Score_BO'] * weights['BO'] +
            dimension_scores_df['Score_MR'] * weights['MR'] +
            dimension_scores_df['Score_QD'] * weights['QD']
        )
        return final_score.sort_values(ascending=False)

    # endregion

    # region: --- 3. 因子计算 (模块化) ---

    def _calculate_all_dynamic_factors(self) -> pd.DataFrame:
        """调度所有12个因子计算方法"""
        logger.debug("开始计算所有动态因子...")
      
        factor_calculators = {
            'dynamic_MA20_SLOPE': self._calc_factor_ma20_slope,
            'dynamic_MA_SCORE': self._calc_factor_ma_score,
            'dynamic_ADX_CONFIRM': self._calc_factor_adx_confirm,
            'dynamic_BREAKOUT_PWR': self._calc_factor_breakout_pwr,
            'dynamic_VOLUME_SURGE': self._calc_factor_volume_surge,
            'dynamic_MOM_ACCEL': self._calc_factor_mom_accel,
            'dynamic_RSI_OS': self._calc_factor_rsi_os,
            'dynamic_NEG_DEV': self._calc_factor_neg_dev,
            'dynamic_BOLL_LB': self._calc_factor_boll_lb,
            'dynamic_LOW_VOL': self._calc_factor_low_vol,
            'dynamic_MAX_DD': self._calc_factor_max_dd,
            'dynamic_DOWNSIDE_RISK': self._calc_factor_downside_risk,
        }
      
        all_factors = {}
        for code, func in factor_calculators.items():
            if code in self.dynamic_factor_defs:
                logger.debug(f"  - 计算因子: {code}")
                all_factors[code] = func()
      
        raw_factors_df = pd.DataFrame(all_factors)
        original_count = len(raw_factors_df)

        inf_count = np.isinf(raw_factors_df).sum().sum()
        if inf_count > 0:
            logger.debug(f"发现 {inf_count} 个无穷大(inf)值，将替换为NaN进行剔除。")
            raw_factors_df.replace([np.inf, -np.inf], np.nan, inplace=True)
        # --- 核心调试代码 ---
        if original_count > 0:
            logger.debug("--- NaN 值分析开始 ---")
            nan_counts = raw_factors_df.isna().sum()
            logger.debug(f"因子计算后，各因子的 NaN 值数量 (总计 {original_count} 只股票):")
            logger.debug("\n" + nan_counts.to_string())
          
            # 找出NaN数量最多的因子
            problematic_factors = nan_counts[nan_counts > 0].sort_values(ascending=False)
            if not problematic_factors.empty:
                logger.warning(f"问题可能出在以下因子中，它们的NaN数量较多: \n{problematic_factors}")
            else:
                logger.debug("太棒了！没有任何因子产生NaN。")
            # 检查是否存在某一行全是NaN
            all_nan_rows = raw_factors_df.isna().all(axis=1).sum()
            if all_nan_rows > 0:
                logger.warning(f"警告：有 {all_nan_rows} 只股票的所有因子值都为 NaN！")
            logger.debug("--- NaN 值分析结束 ---")
        raw_factors_df.dropna(inplace=True)
        final_count = len(raw_factors_df)
        logger.debug(f"因子计算完成。因数据不足(NaN)剔除了 {original_count - final_count} 只股票。剩余 {final_count} 只。")
      
        return raw_factors_df

    # --- MT 因子 ---
    def _calc_factor_ma20_slope(self) -> pd.Series:
        """
        计算20日均线的20日线性回归斜率。
        使用numpy.linalg.lstsq进行向量化计算，避免了低效的rolling.apply()。
        """
        ma20 = self.panel_hfq_close.rolling(20).mean()
      
        # 我们只需要最后20个MA20值来计算当前斜率
        last_20_ma20 = ma20.tail(20)
      
        # 如果数据不足20天，则无法计算
        if len(last_20_ma20) < 20:
            # 返回一个全为NaN的Series，保持与原输出结构一致
            return pd.Series(np.nan, index=self.panel_hfq_close.columns)
        # 准备最小二乘法求解
        # x是时间自变量 [0, 1, 2, ..., 19]
        x = np.arange(20)
        # 我们需要一个常数项，所以构建一个 (20, 2) 的矩阵A
        A = np.vstack([x, np.ones(20)]).T
      
        # y是因变量，即每个股票的最后20个MA20值
        y = last_20_ma20.values
      
        # np.linalg.lstsq 会为y的每一列（每个股票）解出 Ax = y 中的 x
        # 返回结果的第一个元素是解的矩阵，其中第一行是斜率(m)，第二行是截距(c)
        slopes, _ = np.linalg.lstsq(A, y, rcond=None)[0]
      
        # 将结果转换回pandas Series
        return pd.Series(slopes, index=last_20_ma20.columns)

    def _calc_factor_ma_score(self) -> pd.Series:
        close, ma5, ma10, ma20 = (
            self.panel_close.iloc[-1],
            self.panel_close.rolling(5).mean().iloc[-1],
            self.panel_close.rolling(10).mean().iloc[-1],
            self.panel_close.rolling(20).mean().iloc[-1]
        )
        return (close > ma5).astype(int) + (ma5 > ma10).astype(int) + (ma10 > ma20).astype(int)

    def _calc_factor_adx_confirm(self) -> pd.Series:
        adx_df = self.panel_close.apply(lambda s: ta.adx(self.panel_high[s.name], self.panel_low[s.name], s, length=14).iloc[-1])
        adx_df = adx_df.T
        condition = (adx_df['ADX_14'] > 20) & (adx_df['DMP_14'] > adx_df['DMN_14'])
        return adx_df['ADX_14'].where(condition, 0)

    # --- BO 因子 ---
    def _calc_factor_breakout_pwr(self) -> pd.Series:
        close = self.panel_close
        atr14 = self.panel_close.apply(lambda s: ta.atr(self.panel_high[s.name], self.panel_low[s.name], s, length=14).iloc[-1])
        breakout_level = close.iloc[-60:-1].max()
        return (close.iloc[-1] - breakout_level) / (atr14+ 1e-9)

    def _calc_factor_volume_surge(self) -> pd.Series:
        vol = self.panel_volume
        return vol.iloc[-1] / (vol.iloc[-20:-1].mean()+ 1e-9)

    def _calc_factor_mom_accel(self) -> pd.Series:
        """计算动能加速度：(今日ROC5 / 11日前ROC5) - 1"""
        # 1. 计算整个面板的5日变化率 (动能)
        roc5 = self.panel_hfq_close.pct_change(5, fill_method=None)
        # 2. 使用 shift() 获取11个周期前的动能值。这才是正确的向量化操作。
        # shift() 会在每个股票代码（列）内部独立进行数据下移。
        roc5_shifted = roc5.shift(11)
        # 3. 计算动能加速度
        # 这个计算现在是正确的元素对元素操作：每个格子的值除以它上面11个格子的值
        acceleration = roc5 / (roc5_shifted + 1e-9) - 1
        # 4. 如果数据长度不足，acceleration的开头几行会是NaN，但最后一行应该是有效的。
        # 我们返回最后一行的Series即可。
        if acceleration.empty:
            return pd.Series(np.nan, index=self.panel_hfq_close.columns)
      
        return acceleration.iloc[-1]

    # --- MR 因子 ---
    def _calc_factor_rsi_os(self) -> pd.Series:
        return self.panel_close.apply(lambda s: ta.rsi(s, length=14).iloc[-1])

    def _calc_factor_neg_dev(self) -> pd.Series:
        ma60 = self.panel_close.rolling(60).mean().iloc[-1]
        return (self.panel_close.iloc[-1] - ma60) / (ma60+ 1e-9)

    def _calc_factor_boll_lb(self) -> pd.Series:
        boll_df = self.panel_close.apply(lambda s: ta.bbands(s, length=20).iloc[-1])
        boll_df = boll_df.T
        return (self.panel_close.iloc[-1] - boll_df['BBL_20_2.0']) / (boll_df['BBU_20_2.0'] - boll_df['BBL_20_2.0']+ 1e-9)

    # --- QD 因子 ---
    def _calc_factor_low_vol(self) -> pd.Series:
        return self.panel_hfq_close.pct_change(fill_method=None).rolling(20, min_periods=2).std().iloc[-1]

    def _calc_factor_max_dd(self) -> pd.Series:
        roll_max = self.panel_hfq_close.rolling(60, min_periods=1).max()
        daily_dd = self.panel_hfq_close / roll_max - 1.0
        return daily_dd.rolling(60, min_periods=1).min().iloc[-1]

    def _calc_factor_downside_risk(self) -> pd.Series:
        returns = self.panel_hfq_close.pct_change(fill_method=None)
        downside_returns = returns.copy()
        downside_returns[downside_returns > 0] = 0
        # 添加 min_periods=2
        downside_risk = downside_returns.rolling(60, min_periods=2).std() 
        return downside_risk.iloc[-1]

    # endregion
  
    # region: --- 4. 辅助方法 (基本与旧版兼容) ---

    def _log_to_db(self, level, message):
        return
        #SystemLog.objects.create(log_level=level, module_name=MODULE_NAME, message=message)

    def _load_dynamic_parameters_and_defs(self):
        logger.debug("加载动态策略参数和因子定义...")
        params_qs = StrategyParameters.objects.filter(param_name__startswith='dynamic_')
        self.dynamic_params = {p.param_name: float(p.param_value) for p in params_qs}
      
        defs_qs = FactorDefinitions.objects.filter(is_active=True, factor_code__startswith='dynamic_')
        self.dynamic_factor_defs = {f.factor_code: {'direction': f.direction} for f in defs_qs}
        logger.debug(f"加载了 {len(self.dynamic_params)} 个动态参数和 {len(self.dynamic_factor_defs)} 个启用的动态因子定义。")

    def _get_market_trade_dates(self, lookback_period: int) -> list[date]:
        trade_dates = list(
            DailyQuotes.objects
            .filter(trade_date__lte=self.trade_date)
            .values_list('trade_date', flat=True)
            .distinct()
            .order_by('-trade_date')[:lookback_period]
        )
        trade_dates.reverse()
        return trade_dates

    def _initial_screening(self) -> list[str]:
        logger.debug("开始执行初步筛选...")
        all_stocks = StockInfo.objects.filter(status=StockInfo.StatusChoices.LISTING)
        #过滤科创版、ST、*ST
        non_st_stocks = all_stocks.exclude(stock_code__contains='.688').exclude(stock_name__startswith='ST').exclude(stock_name__startswith='*ST')
      
        min_listing_date = self.trade_date - timedelta(days=int(self.dynamic_params['dynamic_lookback_new_stock']))
      
        non_new_stocks = non_st_stocks.filter(listing_date__lt=min_listing_date)
      
        stock_pool_codes = list(non_new_stocks.values_list('stock_code', flat=True))
        logger.info(f"剔除科创版和ST和次新股后，剩余 {len(stock_pool_codes)} 只股票。")

        lookback_days = 20
        start_date = self.trade_date - timedelta(days=lookback_days * 2)
      
        quotes = DailyQuotes.objects.filter(
            stock_code_id__in=stock_pool_codes,
            trade_date__lte=self.trade_date,
            trade_date__gte=start_date
        ).values('stock_code_id', 'trade_date', 'turnover')

        if not quotes:
            logger.warning("在流动性筛选期间未找到任何行情数据。")
            return []

        quotes_df = pd.DataFrame.from_records(quotes)
        recent_trade_dates = sorted(quotes_df['trade_date'].unique())[-lookback_days:]
        quotes_df = quotes_df[quotes_df['trade_date'].isin(recent_trade_dates)]

        avg_turnover = quotes_df.groupby('stock_code_id')['turnover'].mean()
        liquid_stocks = avg_turnover[avg_turnover >= self.dynamic_params['dynamic_min_liquidity']]
      
        final_stock_pool = list(liquid_stocks.index)
        logger.info(f"剔除低流动性股后，最终剩余 {len(final_stock_pool)} 只股票进入精选池。")
      
        return final_stock_pool

    def _load_market_data(self, stock_pool: list[str], for_m_calc: bool = False):
        max_lookback=1000
        if for_m_calc:
            # M(t)本身要看750天历史，其计算又需要60天窗口，所以总共需要约810天
            # 从数据库动态获取参数，避免硬编码
            m_lookback_param = int(self.dynamic_params.get('dynamic_m_lookback', 750))
            # 额外增加90天作为计算Buffer (覆盖60个交易日)
            max_lookback = m_lookback_param + 90 
        else:
            # 个股因子最长回溯60天，给足buffer到250天是合理的
            max_lookback = 250
        logger.debug(f"确定最大数据回溯期为 {max_lookback} 个交易日。")

        trade_dates = self._get_market_trade_dates(max_lookback)
        if not trade_dates: raise ValueError("无法获取市场交易日历。")
      
        logger.debug(f"正在加载 {len(stock_pool)} 只股票在 {len(trade_dates)} 个交易日内的行情数据...")
      
        quotes_qs = DailyQuotes.objects.filter(
            stock_code_id__in=stock_pool,
            trade_date__in=trade_dates
        ).values('trade_date', 'stock_code_id', 'open', 'high', 'low', 'close', 'volume', 'turnover', 'hfq_close')
      
        if not quotes_qs: raise ValueError("在指定日期范围内未找到任何股票的行情数据。")

        df = pd.DataFrame.from_records(quotes_qs)
        df['trade_date'] = pd.to_datetime(df['trade_date'])
      
        logger.debug("正在构建面板数据(Panel Data)...")
        for col in ['open', 'high', 'low', 'close', 'volume', 'turnover', 'hfq_close']:
            panel = df.pivot(index='trade_date', columns='stock_code_id', values=col).astype(float)
            setattr(self, f'panel_{col}', panel)
        logger.debug("面板数据构建完成。")

    def _standardize_factors(self, raw_factors_df: pd.DataFrame) -> pd.DataFrame:
        logger.debug("开始对因子值进行标准化...")
        norm_scores_df = pd.DataFrame(index=raw_factors_df.index)
      
        for factor_code, series in raw_factors_df.items():
            direction = self.dynamic_factor_defs[factor_code]['direction']
            p1, p99 = series.quantile(0.01), series.quantile(0.99)
          
            if (p99 - p1) < 1e-9:
                norm_scores_df[factor_code] = 0
                continue
          
            x_prime = series.clip(p1, p99)
          
            if direction == 'positive':
                score = ((x_prime - p1) / (p99 - p1)) * 200 - 100
            else:
                score = ((p99 - x_prime) / (p99 - p1)) * 200 - 100
          
            norm_scores_df[factor_code] = score
          
        logger.debug("因子标准化完成。")
        return norm_scores_df

    def _generate_trading_plan(self, final_scores: pd.Series) -> pd.DataFrame:
        top_n = int(self.dynamic_params['dynamic_top_n'])
        top_stocks = final_scores.head(top_n)
      
        if top_stocks.empty: return pd.DataFrame()
        top_stock_codes = top_stocks.index.tolist()
      
        atr14 = self.panel_close.apply(lambda s: ta.atr(self.panel_high[s.name], self.panel_low[s.name], s, length=14).iloc[-1])
      
        last_close = self.panel_close.iloc[-1].reindex(top_stock_codes)
        last_atr = atr14.reindex(top_stock_codes)
      
        k_drop = self.dynamic_params['dynamic_k_drop']
        k_gap = self.dynamic_params['dynamic_k_gap']
      
        miop = last_close * (1 - k_drop * (last_atr / last_close))
        maop = last_close * (1 + k_gap * (last_atr / last_close))
 
        plan_df = pd.DataFrame({
            'stock_code': top_stock_codes,
            'rank': range(1, len(top_stock_codes) + 1),
            'final_score': top_stocks.values,
            'miop': miop.values,
            'maop': maop.values
        }).dropna(subset=['miop', 'maop'])
      
        logger.debug("交易预案生成完成。")
        return plan_df

    @transaction.atomic
    def _save_results(self, raw_factors_df, norm_scores_df, trading_plan_df):
        logger.debug("开始将结果保存到数据库...")
      
        # 1. 保存每日因子值
        factor_values_to_create = []
        for stock_code, row in raw_factors_df.iterrows():
            for factor_code, raw_value in row.items():
                norm_score = norm_scores_df.loc[stock_code, factor_code]
                factor_values_to_create.append(
                    DailyFactorValues(
                        stock_code_id=stock_code, trade_date=self.trade_date,
                        factor_code_id=factor_code, raw_value=Decimal(str(raw_value)),
                        norm_score=Decimal(str(norm_score))
                    )
                )
        DailyFactorValues.objects.bulk_create(factor_values_to_create, ignore_conflicts=True)

        # 2. 保存每日交易预案
        plan_date = self.trade_date + timedelta(days=1)
        DailyTradingPlan.objects.filter(plan_date=plan_date).delete()
      
        plans_to_create = []
        for _, row in trading_plan_df.iterrows():
            plans_to_create.append(
                DailyTradingPlan(
                    plan_date=plan_date, stock_code_id=row['stock_code'],
                    rank=row['rank'], final_score=Decimal(str(row['final_score'])),
                    miop=Decimal(str(row['miop'])).quantize(Decimal('0.01')),
                    maop=Decimal(str(row['maop'])).quantize(Decimal('0.01')),
                    status=DailyTradingPlan.StatusChoices.PENDING
                )
            )
        DailyTradingPlan.objects.bulk_create(plans_to_create)
      
        log_message = f"T-1日({self.trade_date})动态选股完成, T日({plan_date})预案如下:\n"
        log_message += trading_plan_df.to_string(index=False)
        self._log_to_db('INFO', log_message)
        logger.debug("所有结果已成功保存到数据库。")

    # endregion

####文件结束####

####selection_manager\service\selection_service_old.py####
# selection_manager/service/selection_service.py

import logging
from datetime import date, timedelta
from decimal import Decimal

import numpy as np
import pandas as pd
import pandas_ta as ta
from scipy.stats import linregress

from django.db import transaction
from django.utils import timezone

from common.models.stock_info import StockInfo
from common.models.daily_quotes import DailyQuotes
from common.models.system_log import SystemLog
from common.models.factor_definitions import FactorDefinitions
from common.models.daily_factor_values import DailyFactorValues
from common.models.strategy_parameters import StrategyParameters
from common.models.daily_trading_plan import DailyTradingPlan



# region: 全局配置
MODULE_NAME = '日终选股与预案生成'
logger = logging.getLogger(MODULE_NAME)
# endregion


class SelectionService:
    """
    T-1日收盘后运行的选股与预案生成服务。
  
    执行流程:
    1. 加载策略参数。
    2. 对全市场股票进行初步筛选。
    3. 加载所需时间窗口内的所有行情数据，构建面板数据(Panel Data)。
    4. 计算所有因子原始值。
    5. 对因子值进行标准化处理。
    6. 计算综合得分并排序。
    7. 为Top N股票生成交易预案（MIOP/MAOP）。
    8. 将所有结果持久化到数据库。
    """

    def __init__(self, trade_date: date, mode: str = 'realtime'):
        """
        初始化选股服务。

        :param trade_date: T-1日，即执行计算的当天日期。
        :param mode: 运行模式, 'realtime' 或 'backtest'。
        """
        if mode not in ['realtime', 'backtest']:
            raise ValueError("模式(mode)必须是 'realtime' 或 'backtest'")

        self.trade_date = trade_date
        self.mode = mode
        self.params = {}
        self.factor_defs = {}
      
        # 用于存储面板数据
        self.panel_open = None
        self.panel_high = None
        self.panel_low = None
        self.panel_close = None
        self.panel_volume = None
        self.panel_turnover = None
        self.panel_hfq_close = None

        logger.debug(f"--- SelectionService 初始化 ---")
        logger.debug(f"交易日期 (T-1): {self.trade_date}")
        logger.debug(f"运行模式: {self.mode}")

    # region: --- 1. 主流程与入口方法 ---

    @staticmethod
    def initialize_strategy():
        """
        初始化策略所需的因子定义和参数到数据库。
        这是一个幂等操作，可以重复运行。
        """
        logger.debug("开始初始化策略：铺底因子定义和策略参数...")

        # 1. 定义所有因子
        factors_to_define = [
            {'factor_code': 'MA20_SLOPE', 'factor_name': '20日均线斜率', 'direction': 'positive', 'description': 'x1: 过去20个交易日MA20值的线性回归斜率'},
            {'factor_code': 'MA_ALIGNMENT', 'factor_name': '均线排列评分', 'direction': 'positive', 'description': 'x2: 收盘价/MA5/MA10/MA20多头排列评分(0-3)'},
            {'factor_code': 'ADX_TREND', 'factor_name': 'ADX趋势强度', 'direction': 'positive', 'description': 'x3: ADX > 25 且 +DI > -DI 时的ADX值'},
            {'factor_code': 'ROC10', 'factor_name': '10日价格变化率', 'direction': 'positive', 'description': 'x4: (Close_t / Close_t-10) - 1'},
            {'factor_code': 'VOL_BREAKOUT', 'factor_name': '成交量突破', 'direction': 'positive', 'description': 'x5: 最近5日均量 / 最近60日均量'},
            {'factor_code': 'NEW_HIGH_MOMENTUM', 'factor_name': '新高动能', 'direction': 'positive', 'description': 'x6: 当前收盘价 / 过去60日最高价'},
            {'factor_code': 'VOLATILITY20', 'factor_name': '20日波动率', 'direction': 'negative', 'description': 'x7: 最近20日复权收益率标准差'},
            {'factor_code': 'LIQUIDITY20', 'factor_name': '20日流动性', 'direction': 'positive', 'description': 'x8: 最近20日日均成交额'},
        ]
        with transaction.atomic():
            for factor_data in factors_to_define:
                FactorDefinitions.objects.update_or_create(
                    factor_code=factor_data['factor_code'],
                    defaults=factor_data
                )
        logger.debug(f"成功初始化/更新 {len(factors_to_define)} 个因子定义。")

        # 2. 定义所有参数 (权重、系数、计算周期)
        # !!! 要求4: 给我留一个字典当口子，后面我想好了值再填进去 !!!
        # 这里就是那个口子，您可以随时修改这些默认值
        parameters_to_define = {
            # 维度权重 (和必须为1)
            'w_trend': {'value': Decimal('0.4'), 'group': 'WEIGHTS', 'desc': '趋势维度权重'},
            'w_momentum': {'value': Decimal('0.4'), 'group': 'WEIGHTS', 'desc': '动能维度权重'},
            'w_quality': {'value': Decimal('0.2'), 'group': 'WEIGHTS', 'desc': '质量/风控维度权重'},
            # 因子权重
            'k1': {'value': Decimal('0.4'), 'group': 'TREND_FACTORS', 'desc': 'x1: MA20斜率权重'},
            'k2': {'value': Decimal('0.3'), 'group': 'TREND_FACTORS', 'desc': 'x2: 均线排列权重'},
            'k3': {'value': Decimal('0.3'), 'group': 'TREND_FACTORS', 'desc': 'x3: ADX趋势强度权重'},
            'k4': {'value': Decimal('0.4'), 'group': 'MOMENTUM_FACTORS', 'desc': 'x4: ROC10权重'},
            'k5': {'value': Decimal('0.3'), 'group': 'MOMENTUM_FACTORS', 'desc': 'x5: 成交量突破权重'},
            'k6': {'value': Decimal('0.3'), 'group': 'MOMENTUM_FACTORS', 'desc': 'x6: 新高动能权重'},
            'k7': {'value': Decimal('0.5'), 'group': 'QUALITY_FACTORS', 'desc': 'x7: 波动率权重'},
            'k8': {'value': Decimal('0.5'), 'group': 'QUALITY_FACTORS', 'desc': 'x8: 流动性权重'},
            # 交易预案参数
            'k_drop': {'value': Decimal('0.3'), 'group': 'PLAN_PARAMS', 'desc': 'MIOP低开容忍系数'},
            'k_gap': {'value': Decimal('0.5'), 'group': 'PLAN_PARAMS', 'desc': 'MAOP高开容忍系数'},
            # 计算周期参数
            'lookback_new_stock': {'value': Decimal('60'), 'group': 'LOOKBACKS', 'desc': '次新股定义天数'},
            'lookback_liquidity': {'value': Decimal('20'), 'group': 'LOOKBACKS', 'desc': '流动性计算周期'},
            'lookback_ma_slow': {'value': Decimal('60'), 'group': 'LOOKBACKS', 'desc': '慢速均线周期(如成交量)'},
            'lookback_ma_fast': {'value': Decimal('5'), 'group': 'LOOKBACKS', 'desc': '快速均线周期(如成交量)'},
            'lookback_ma20': {'value': Decimal('20'), 'group': 'LOOKBACKS', 'desc': 'MA20周期'},
            'lookback_ma10': {'value': Decimal('10'), 'group': 'LOOKBACKS', 'desc': 'MA10周期'},
            'lookback_ma5': {'value': Decimal('5'), 'group': 'LOOKBACKS', 'desc': 'MA5周期'},
            'lookback_roc': {'value': Decimal('10'), 'group': 'LOOKBACKS', 'desc': 'ROC计算周期'},
            'lookback_new_high': {'value': Decimal('60'), 'group': 'LOOKBACKS', 'desc': '新高动能计算周期'},
            'lookback_volatility': {'value': Decimal('20'), 'group': 'LOOKBACKS', 'desc': '波动率计算周期'},
            'lookback_atr': {'value': Decimal('14'), 'group': 'LOOKBACKS', 'desc': 'ATR计算周期'},
            'lookback_adx': {'value': Decimal('14'), 'group': 'LOOKBACKS', 'desc': 'ADX计算周期'},
            # 其他参数
            'param_min_liquidity': {'value': Decimal('100000000'), 'group': 'FILTERS', 'desc': '最低日均成交额(元)'},
            'param_top_n': {'value': Decimal('10'), 'group': 'SELECTION', 'desc': '最终选取股票数量'},
            'param_adx_threshold': {'value': Decimal('25'), 'group': 'THRESHOLDS', 'desc': 'ADX趋势形成阈值'},
        }
        with transaction.atomic():
            for name, data in parameters_to_define.items():
                StrategyParameters.objects.update_or_create(
                    param_name=name,
                    defaults={
                        'param_value': data['value'],
                        'group_name': data['group'],
                        'description': data['desc']
                    }
                )
        logger.debug(f"成功初始化/更新 {len(parameters_to_define)} 个策略参数。")
        logger.debug("策略初始化完成。")

    def run_selection(self):
        """
        一键启动全流程的入口方法。
        """
        # 关闭 pandas-ta 的冗余日志
        ta.Imports["verbose"] = False
        self._log_to_db('INFO', f"选股流程启动。模式: {self.mode}, 日期: {self.trade_date}")
        try:
            # 步骤 1: 加载所有配置参数
            self._load_parameters_and_defs()

            # 步骤 2: 初步筛选股票池
            initial_stock_pool = self._initial_screening()
            if not initial_stock_pool:
                logger.warning("初步筛选后无符合条件的股票，流程终止。")
                self._log_to_db('WARNING', "初步筛选后无符合条件的股票，流程终止。")
                return

            # 步骤 3: 加载行情数据并构建面板
            self._load_market_data(initial_stock_pool)

            # 步骤 4: 计算所有因子原始值
            raw_factors_df = self._calculate_all_factors()

            # 步骤 5: 标准化因子
            norm_scores_df = self._standardize_factors(raw_factors_df)

            # 步骤 6: 计算综合得分
            final_scores = self._calculate_composite_score(norm_scores_df)
          
            # 步骤 7: 生成交易预案
            trading_plan = self._generate_trading_plan(final_scores)
            if trading_plan.empty:
                logger.warning("最终未生成任何交易预案。")
                self._log_to_db('WARNING', "最终未生成任何交易预案。")
                return

            # 步骤 8: 保存所有结果到数据库
            self._save_results(raw_factors_df, norm_scores_df, trading_plan)

            # 模式特定逻辑的口子
            if self.mode == 'backtest':
                logger.debug("回测模式特定逻辑处理... (当前无)")
            elif self.mode == 'realtime':
                logger.debug("实时模式特定逻辑处理... (当前无)")

            success_msg = f"选股流程成功完成。生成 {len(trading_plan)} 条交易预案。"
            logger.info(success_msg)
            self._log_to_db('INFO', success_msg)

        except Exception as e:
            error_msg = f"选股流程发生严重错误: {e}"
            logger.critical(error_msg, exc_info=True)
            self._log_to_db('CRITICAL', error_msg)
            # 如果在事务中，需要确保事务回滚，但Django的请求/响应周期或事务装饰器通常会处理这个
            raise

    # endregion

    # region: --- 2. 内部辅助方法 ---

    def _log_to_db(self, level, message):
        """辅助方法：将日志写入数据库"""
        SystemLog.objects.create(
            log_level=level,
            module_name=MODULE_NAME,
            message=message
        )

    def _load_parameters_and_defs(self):
        """从数据库加载所有策略参数和因子定义到内存"""
        logger.debug("加载策略参数和因子定义...")
      
        # 加载参数
        params_qs = StrategyParameters.objects.all()
        # --- 修改点在这里 ---
        # 在加载时，直接将 Decimal 转换为 float，用于后续的科学计算
        # 对于需要整数的参数，单独处理
        self.params = {}
        for p in params_qs:
            if p.param_name.startswith('lookback_') or p.param_name in ['param_top_n', 'param_adx_threshold']:
                self.params[p.param_name] = int(p.param_value)
            else:
                self.params[p.param_name] = float(p.param_value)
      
        # 加载因子定义
        defs_qs = FactorDefinitions.objects.filter(is_active=True)
        self.factor_defs = {f.factor_code: {'direction': f.direction} for f in defs_qs}
      
        logger.debug(f"加载了 {len(self.params)} 个参数和 {len(self.factor_defs)} 个启用的因子定义。")

    def _get_market_trade_dates(self, lookback_period: int) -> list[date]:
        """获取截至T-1日的N个市场交易日历"""
        trade_dates = list(
            DailyQuotes.objects
            .filter(trade_date__lte=self.trade_date)
            .values_list('trade_date', flat=True)
            .distinct()
            .order_by('-trade_date')[:lookback_period]
        )
        trade_dates.reverse()
        return trade_dates

    def _initial_screening(self) -> list[str]:
        """执行初步筛选，返回符合条件的股票代码列表"""
        logger.debug("开始执行初步筛选...")
      
        # 1. 剔除ST股
        all_stocks = StockInfo.objects.filter(status=StockInfo.StatusChoices.LISTING)
        non_st_stocks = all_stocks.exclude(stock_code__contains='.688').exclude(stock_name__startswith='ST').exclude(stock_name__startswith='*ST')
      
        # 2. 剔除次新股
        min_listing_date = self.trade_date - timedelta(days=self.params['lookback_new_stock'])
        non_new_stocks = non_st_stocks.filter(listing_date__lt=min_listing_date)
      
        stock_pool_codes = list(non_new_stocks.values_list('stock_code', flat=True))
        logger.info(f"剔除ST和次新股后，剩余 {len(stock_pool_codes)} 只股票。")

        # 3. 剔除低流动性股
        lookback_days = self.params['lookback_liquidity']
        start_date = self.trade_date - timedelta(days=lookback_days * 2) 
      
        quotes = DailyQuotes.objects.filter(
            stock_code_id__in=stock_pool_codes,
            trade_date__lte=self.trade_date,
            trade_date__gte=start_date
        ).values('stock_code_id', 'trade_date', 'turnover')

        if not quotes:
            logger.warning("在流动性筛选期间未找到任何行情数据。")
            return []

        quotes_df = pd.DataFrame.from_records(quotes)
      
        # 获取最近 lookback_days 个交易日
        recent_trade_dates = sorted(quotes_df['trade_date'].unique())[-lookback_days:]
        quotes_df = quotes_df[quotes_df['trade_date'].isin(recent_trade_dates)]

        avg_turnover = quotes_df.groupby('stock_code_id')['turnover'].mean()
        liquid_stocks = avg_turnover[avg_turnover >= self.params['param_min_liquidity']]
      
        final_stock_pool = list(liquid_stocks.index)
        logger.info(f"剔除低流动性股后，最终剩余 {len(final_stock_pool)} 只股票进入精选池。")
      
        return final_stock_pool

    def _load_market_data(self, stock_pool: list[str]):
        """加载所有需要的数据并构建面板"""
        # 确定最长的回溯期
        max_lookback = max(
            self.params['lookback_ma_slow'],
            self.params['lookback_new_high'],
            self.params['lookback_adx'] + 50 # ADX需要更长的数据来稳定
        )
        logger.debug(f"确定最大数据回溯期为 {max_lookback} 个交易日。")

        trade_dates = self._get_market_trade_dates(max_lookback)
        if not trade_dates:
            raise ValueError("无法获取市场交易日历，数据库可能为空。")
      
        logger.debug(f"正在加载 {len(stock_pool)} 只股票在 {len(trade_dates)} 个交易日内的行情数据...")
      
        quotes_qs = DailyQuotes.objects.filter(
            stock_code_id__in=stock_pool,
            trade_date__in=trade_dates
        ).values('trade_date', 'stock_code_id', 'open', 'high', 'low', 'close', 'volume', 'turnover', 'hfq_close')
      
        if not quotes_qs:
            raise ValueError("在指定日期范围内未找到任何股票的行情数据。")

        df = pd.DataFrame.from_records(quotes_qs)
        df['trade_date'] = pd.to_datetime(df['trade_date'])
      
        # 构建面板数据，停牌的股票会自动填充NaN
        logger.debug("正在构建面板数据(Panel Data)...")
        # 1. 从原始DataFrame中确定所有面板的“理想形状”
        # 这是最全的日期和股票列表，是我们的“真理之源”
        master_index_raw = df['trade_date'].unique()
        master_columns_raw = df['stock_code_id'].unique()
        master_index = np.sort(master_index_raw)
        master_columns = np.sort(master_columns_raw)
      
      
      
        logger.debug(f"已确定基准形状: {len(master_index)} 个日期 x {len(master_columns)} 只股票。")
 
        # 2. 使用 set_index + unstack 高效地创建各个面板
        # 这一步创建的面板可能形状不一，因为个别股票在某些天可能没有某个值
        base_df = df.set_index(['trade_date', 'stock_code_id'])
      
        panel_open_raw = base_df['open'].unstack()
        panel_high_raw = base_df['high'].unstack()
        panel_low_raw = base_df['low'].unstack()
        panel_close_raw = base_df['close'].unstack()
        panel_volume_raw = base_df['volume'].unstack()
        panel_turnover_raw = base_df['turnover'].unstack()
        panel_hfq_close_raw = base_df['hfq_close'].unstack()
 
        # 3. 将所有原始面板 reindex 到我们预先定义的“理想形状”
        # 这样可以确保所有面板的维度完全一致，缺失值会被正确地填充为NaN
        self.panel_open = panel_open_raw.reindex(index=master_index, columns=master_columns)
        self.panel_high = panel_high_raw.reindex(index=master_index, columns=master_columns)
        self.panel_low = panel_low_raw.reindex(index=master_index, columns=master_columns)
        self.panel_close = panel_close_raw.reindex(index=master_index, columns=master_columns)
        self.panel_volume = panel_volume_raw.reindex(index=master_index, columns=master_columns)
        self.panel_turnover = panel_turnover_raw.reindex(index=master_index, columns=master_columns)
        self.panel_hfq_close = panel_hfq_close_raw.reindex(index=master_index, columns=master_columns)
        self.panel_open = self.panel_open.astype(float)
        self.panel_high = self.panel_high.astype(float)
        self.panel_low = self.panel_low.astype(float)
        self.panel_close = self.panel_close.astype(float)
        self.panel_volume = self.panel_volume.astype(float)
        self.panel_turnover = self.panel_turnover.astype(float)
        self.panel_hfq_close = self.panel_hfq_close.astype(float)
        logger.debug("面板数据构建完成。")

    # endregion

    # region: --- 3. 因子计算 (模块化) ---

    def _calculate_all_factors(self) -> pd.DataFrame:
        """
        调度所有因子计算方法，并将结果合并到一个DataFrame中。
        返回的DataFrame: index=stock_code, columns=factor_codes
        """
        logger.debug("开始计算所有因子...")
      
        factor_calculators = {
            'MA20_SLOPE': self._calc_factor_x1_ma20_slope,
            'MA_ALIGNMENT': self._calc_factor_x2_ma_alignment,
            'ADX_TREND': self._calc_factor_x3_adx_trend,
            'ROC10': self._calc_factor_x4_roc,
            'VOL_BREAKOUT': self._calc_factor_x5_vol_breakout,
            'NEW_HIGH_MOMENTUM': self._calc_factor_x6_new_high_momentum,
            'VOLATILITY20': self._calc_factor_x7_volatility,
            'LIQUIDITY20': self._calc_factor_x8_liquidity,
        }
      
        all_factors = {}
        for code, func in factor_calculators.items():
            if code in self.factor_defs:
                logger.debug(f"  - 计算因子: {code}")
                # 每个因子计算方法返回一个以stock_code为索引的Series
                all_factors[code] = func()
      
        # 合并所有因子Series为一个DataFrame
        raw_factors_df = pd.DataFrame(all_factors)
      
        # 剔除任何一个因子值为NaN的股票
        original_count = len(raw_factors_df)
        raw_factors_df.dropna(inplace=True)
        final_count = len(raw_factors_df)
        logger.info(f"因子计算完成。因数据不足(NaN)剔除了 {original_count - final_count} 只股票。剩余 {final_count} 只。")
      
        return raw_factors_df

    # --- 每个因子的独立计算方法 ---
    # 传参: 无 (通过self访问面板数据和参数)
    # 返回: pd.Series (index=stock_code, value=因子原始值)

    def _calc_factor_x1_ma20_slope(self) -> pd.Series:
        ma_period = self.params['lookback_ma20']
        panel_close_float = self.panel_hfq_close.astype(float)
        ma20 = panel_close_float.apply(
            lambda col: ta.sma(close=col, length=ma_period)
        )
      
        # 对每只股票，取最后ma_period个MA值进行线性回归
        def get_slope(series):
            y = series.dropna()
            if len(y) < 2:
                return np.nan
            y_values = y.values
            x_values = np.arange(len(y_values))
            # 增加一个额外的健壮性检查，防止y_values中所有值都相同导致回归失败
            if np.all(y_values == y_values[0]):
                return 0.0 # 如果所有值都一样，斜率为0
            slope, _, _, _, _ = linregress(x_values, y_values)
            return slope

        # 只取最后ma_period行数据进行计算以提高效率
        slopes = ma20.iloc[-ma_period:].apply(get_slope, axis=0)
        return slopes

    def _calc_factor_x2_ma_alignment(self) -> pd.Series:
        ma5 = self.panel_hfq_close.apply(
            lambda col: ta.sma(close=col, length=self.params['lookback_ma5'])
        )
        ma10 = self.panel_hfq_close.apply(
            lambda col: ta.sma(close=col, length=self.params['lookback_ma10'])
        )
        ma20 = self.panel_hfq_close.apply(
            lambda col: ta.sma(close=col, length=self.params['lookback_ma20'])
        )
      
        last_close = self.panel_hfq_close.iloc[-1]
        last_ma5 = ma5.iloc[-1]
        last_ma10 = ma10.iloc[-1]
        last_ma20 = ma20.iloc[-1]
      
        score = (
            (last_close > last_ma5).astype(int) +
            (last_ma5 > last_ma10).astype(int) +
            (last_ma10 > last_ma20).astype(int)
        )
        return score

    def _calc_factor_x3_adx_trend(self) -> pd.Series:
        # 强制转换数据类型为 float
        high = self.panel_high.astype(float)
        low = self.panel_low.astype(float)
        close = self.panel_close.astype(float)
      
        adx_period = self.params['lookback_adx']
        threshold = self.params['param_adx_threshold']
 
        # 定义一个函数，用于对单只股票（一个Series）计算ADX
        def get_adx_trend(stock_code):
            # 从面板中提取单只股票的数据
            stock_high = high[stock_code].dropna()
            stock_low = low[stock_code].dropna()
            stock_close = close[stock_code].dropna()
 
            # 确保数据对齐
            common_index = stock_high.index.intersection(stock_low.index).intersection(stock_close.index)
            if len(common_index) < adx_period * 2: # ADX需要更长的数据来初始化
                return np.nan
 
            stock_high = stock_high.loc[common_index]
            stock_low = stock_low.loc[common_index]
            stock_close = stock_close.loc[common_index]
 
            # 使用 pandas_ta 计算单只股票的ADX
            adx_result = ta.adx(high=stock_high, low=stock_low, close=stock_close, length=adx_period)
 
            # 检查结果是否有效
            if adx_result is None or adx_result.empty:
                return np.nan
 
            last_row = adx_result.iloc[-1]
            last_adx = last_row.get(f'ADX_{adx_period}')
            last_dmp = last_row.get(f'DMP_{adx_period}')
            last_dmn = last_row.get(f'DMN_{adx_period}')
 
            if pd.isna(last_adx) or pd.isna(last_dmp) or pd.isna(last_dmn):
                return np.nan
 
            if last_adx > threshold and last_dmp > last_dmn:
                return last_adx
            else:
                return 0.0
 
        # 对面板中的每一只股票应用该函数
        results = {stock_code: get_adx_trend(stock_code) for stock_code in self.panel_close.columns}
      
        return pd.Series(results)

    def _calc_factor_x4_roc(self) -> pd.Series:
        roc_panel = self.panel_hfq_close.apply(
        lambda col: ta.roc(close=col, length=self.params['lookback_roc'])
        )
        return roc_panel.iloc[-1]

    def _calc_factor_x5_vol_breakout(self) -> pd.Series:
        vol5 = self.panel_volume.rolling(window=self.params['lookback_ma_fast']).mean()
        vol60 = self.panel_volume.rolling(window=self.params['lookback_ma_slow']).mean()
        ratio = vol5.iloc[-1] / vol60.iloc[-1]
        return ratio.replace([np.inf, -np.inf], np.nan) # 处理分母为0的情况

    def _calc_factor_x6_new_high_momentum(self) -> pd.Series:
        high60 = self.panel_hfq_close.rolling(window=self.params['lookback_new_high']).max()
        ratio = self.panel_hfq_close.iloc[-1] / high60.iloc[-1]
        return ratio

    def _calc_factor_x7_volatility(self) -> pd.Series:
        returns = self.panel_hfq_close.pct_change(fill_method=None)
        volatility = returns.rolling(window=self.params['lookback_volatility']).std()
        return volatility.iloc[-1]

    def _calc_factor_x8_liquidity(self) -> pd.Series:
        liquidity = self.panel_turnover.rolling(window=self.params['lookback_liquidity']).mean()
        return liquidity.iloc[-1]

    # endregion

    # region: --- 4. 评分、预案生成与保存 ---

    def _standardize_factors(self, raw_factors_df: pd.DataFrame) -> pd.DataFrame:
        """
        对原始因子值进行标准化处理 (norm函数)。
        """
        logger.debug("开始对因子值进行标准化...")
        norm_scores_df = pd.DataFrame(index=raw_factors_df.index)
      
        for factor_code, series in raw_factors_df.items():
            direction = self.factor_defs[factor_code]['direction']
          
            p1 = series.quantile(0.01)
            p99 = series.quantile(0.99)
          
          
            epsilon = 1e-9  # 定义一个极小值
            if (p99 - p1) < epsilon:
                norm_scores_df[factor_code] = 0
                continue
          
            # Winsorization (缩尾处理)
            x_prime = series.clip(p1, p99)
          
            # 线性映射
            if direction == 'positive':
                score = ((x_prime - p1) / (p99 - p1)) * 200 - 100
            else: # negative
                score = ((p99 - x_prime) / (p99 - p1)) * 200 - 100
          
            norm_scores_df[factor_code] = score
          
        logger.debug("因子标准化完成。")
        return norm_scores_df

    def _calculate_composite_score(self, norm_scores_df: pd.DataFrame) -> pd.Series:
        """
        计算f(x)综合得分。
        """
        logger.debug("开始计算综合得分 f(x)...")
      
        # 趋势维度
        score_trend = (
            norm_scores_df['MA20_SLOPE'] * self.params['k1'] +
            norm_scores_df['MA_ALIGNMENT'] * self.params['k2'] +
            norm_scores_df['ADX_TREND'] * self.params['k3']
        )
      
        # 动能维度
        score_momentum = (
            norm_scores_df['ROC10'] * self.params['k4'] +
            norm_scores_df['VOL_BREAKOUT'] * self.params['k5'] +
            norm_scores_df['NEW_HIGH_MOMENTUM'] * self.params['k6']
        )
      
        # 质量/风控维度
        score_quality = (
            norm_scores_df['VOLATILITY20'] * self.params['k7'] +
            norm_scores_df['LIQUIDITY20'] * self.params['k8']
        )
      
        # 总分
        final_score = (
            score_trend * self.params['w_trend'] +
            score_momentum * self.params['w_momentum'] +
            score_quality * self.params['w_quality']
        )
      
        logger.debug("综合得分计算完成。")
        return final_score.sort_values(ascending=False)

    def _generate_trading_plan(self, final_scores: pd.Series) -> pd.DataFrame:
        top_n = self.params['param_top_n']
        top_stocks = final_scores.head(top_n)
      
        logger.debug(f"开始为Top {top_n} 股票生成交易预案...")
      
        if top_stocks.empty:
            return pd.DataFrame()
 
        top_stock_codes = top_stocks.index.tolist()
      
        # --- 修改点在这里：需要把完整的ATR计算逻辑加回来 ---
        atr_period = self.params['lookback_atr']
        last_atr_values = {}
        for code in top_stock_codes:
            # 提取单只股票数据并计算ATR
            stock_high = self.panel_high[code].astype(float).dropna()
            stock_low = self.panel_low[code].astype(float).dropna()
            stock_close = self.panel_close[code].astype(float).dropna()
          
            common_index = stock_high.index.intersection(stock_low.index).intersection(stock_close.index)
            if len(common_index) < atr_period:
                last_atr_values[code] = np.nan
                continue
 
            atr_result = ta.atr(
                high=stock_high.loc[common_index],
                low=stock_low.loc[common_index],
                close=stock_close.loc[common_index],
                length=atr_period
            )
            if atr_result is not None and not atr_result.empty:
                last_atr_values[code] = atr_result.iloc[-1]
            else:
                last_atr_values[code] = np.nan
        # --- ATR计算逻辑结束 ---
 
        last_atr = pd.Series(last_atr_values)
      
        # 1. 获取所有需要的数据，并确保它们是Series，且索引为stock_code
        last_close = self.panel_close.iloc[-1]
 
        # 2. 以 top_stocks 为基准，重新索引（reindex）所有数据
        aligned_scores = top_stocks
        aligned_close = last_close.reindex(top_stock_codes)
        aligned_atr = last_atr.reindex(top_stock_codes)
 
        # 3. 在对齐后的数据上进行计算
        k_drop = self.params['k_drop']
        k_gap = self.params['k_gap']
      
        miop = aligned_close * (1 - k_drop * (aligned_atr / aligned_close))
        maop = aligned_close * (1 + k_gap * (aligned_atr / aligned_close))
 
        # 4. 组装预案
        plan_df = pd.DataFrame({
            'stock_code': top_stock_codes,
            'rank': range(1, len(top_stock_codes) + 1),
            'final_score': aligned_scores.values,
            'miop': miop.values,
            'maop': maop.values
        })
 
        # 5. (可选但推荐) 剔除因为数据不足无法生成预案的行
        plan_df.dropna(subset=['miop', 'maop'], inplace=True)
      
        logger.debug("交易预案生成完成。")
        return plan_df

    @transaction.atomic
    def _save_results(self, raw_factors_df, norm_scores_df, trading_plan_df):
        """
        将所有计算结果原子性地保存到数据库。
        """
        logger.debug("开始将结果保存到数据库...")
      
        # 1. 保存每日因子值
        logger.debug(f"  - 正在准备 {len(raw_factors_df) * len(raw_factors_df.columns)} 条因子值数据...")
        factor_values_to_create = []
        for stock_code, row in raw_factors_df.iterrows():
            for factor_code, raw_value in row.items():
                norm_score = norm_scores_df.loc[stock_code, factor_code]
                factor_values_to_create.append(
                    DailyFactorValues(
                        stock_code_id=stock_code,
                        trade_date=self.trade_date,
                        factor_code_id=factor_code,
                        raw_value=Decimal(str(raw_value)),
                        norm_score=Decimal(str(norm_score))
                    )
                )
        DailyFactorValues.objects.bulk_create(factor_values_to_create, ignore_conflicts=True)
        logger.debug(f"  - 成功保存因子值。")

        # 2. 保存每日交易预案
        plan_date = self.trade_date + timedelta(days=1)
        logger.debug(f"  - 正在为 {plan_date} 保存 {len(trading_plan_df)} 条交易预案...")
      
        # 先删除当天的旧预案，以防重复运行
        DailyTradingPlan.objects.filter(plan_date=plan_date).delete()
      
        plans_to_create = []
        for _, row in trading_plan_df.iterrows():
            plans_to_create.append(
                DailyTradingPlan(
                    plan_date=plan_date,
                    stock_code_id=row['stock_code'],
                    rank=row['rank'],
                    final_score=Decimal(str(row['final_score'])),
                    miop=Decimal(str(row['miop'])).quantize(Decimal('0.01')),
                    maop=Decimal(str(row['maop'])).quantize(Decimal('0.01')),
                    status=DailyTradingPlan.StatusChoices.PENDING
                )
            )
        DailyTradingPlan.objects.bulk_create(plans_to_create)
        logger.debug(f"  - 成功保存交易预案。")

        # 3. 将最终选股结果记录到系统日志
        log_message = f"T-1日({self.trade_date})选股完成, T日({plan_date})预案如下:\n"
        log_message += trading_plan_df.to_string(index=False)
        self._log_to_db('INFO', log_message)
      
        logger.debug("所有结果已成功保存到数据库。")

    # endregion


# region: --- 示例用法 ---
# 如何在项目中使用这个服务

def setup_django_env():
    """
    独立脚本运行时，需要配置Django环境。
    在Django项目内部（如management command）调用时，则不需要此函数。
    """
    import os
    import django
    # 替换 'your_project.settings' 为你的项目设置文件
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'your_project.settings')
    django.setup()

if __name__ == '__main__':
    # --- 这是一个演示如何调用服务的示例 ---
    # 1. 首先需要设置Django环境
    # setup_django_env() # 如果是独立脚本，取消此行注释

    # 2. (可选) 第一次运行时，初始化策略定义
    print("="*50)
    print("步骤 1: 初始化策略 (如果需要)")
    SelectionService.initialize_strategy()
    print("="*50)

    # 3. 运行选股流程 (以回测模式为例)
    print("\n" + "="*50)
    print("步骤 2: 运行选股流程")
    # 假设我们想为 2023-10-26 (T日) 生成预案，那么T-1日就是 2023-10-25
    # 注意：请确保你的数据库中有 2023-10-25 及之前足够多的数据
    target_trade_date = date(2023, 10, 25) 
  
    try:
        service = SelectionService(trade_date=target_trade_date, mode='backtest')
        service.run_selection()
    except Exception as e:
        print(f"\n在为日期 {target_trade_date} 运行选股时发生错误: {e}")
  
    print("="*50)
    print("示例运行结束。")

# endregion

####文件结束####

####trade_manager\__init__.py####

####文件结束####

####trade_manager\admin.py####
from django.contrib import admin

# Register your models here.

####文件结束####

####trade_manager\apps.py####
# trade_manager/apps.py

import os
import sys
from django.apps import AppConfig
import logging

logger = logging.getLogger(__name__)

class TradeManagerConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'trade_manager'

    def ready(self):
        # 关键修正：通过检查环境变量 RUN_MAIN 来防止调度器在重载主进程中启动两次
        # 这个环境变量是 Django 的 autoreloader 在启动子进程时设置的。
        # 我们只想在运行实际应用的子进程中启动调度器。
        if os.environ.get('RUN_MAIN'):
            logger.info("检测到 Django 应用工作进程，准备初始化调度器...")
            from .service import scheduler_service
            # 确保调度器只启动一次
            if not scheduler_service.scheduler.running:
                 scheduler_service.start()
            else:
                 logger.warning("调度器已在运行，跳过重复启动。")
        else:
            logger.info("检测到 Django 管理或重载主进程，跳过调度器初始化。")

####文件结束####

####trade_manager\models.py####
from django.db import models

# Create your models here.

####文件结束####

####trade_manager\tests.py####
from django.test import TestCase

# Create your tests here.

####文件结束####

####trade_manager\urls.py####
"""
URL configuration for autoTrade project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path,include
from . import views
urlpatterns = [
    path('beforeFixRun', views.before_fix_run),
    path('initParam',views.initialize_strategy_parameters),
    path('simulateTrade', views.simulate_trade)
]

####文件结束####

####trade_manager\views.py####
from datetime import date,datetime
from django.shortcuts import render
from django.http.response import JsonResponse
from trade_manager.service.before_fix_service import BeforeFixService
from trade_manager.service.decision_order_service import DecisionOrderService
from trade_manager.service.simulate_trade import SimulateTradeService
import json
from django.views.decorators.http import require_http_methods
# Create your views here.
@require_http_methods(["POST"])
def before_fix_run(request):
    if request.method=='POST':
        body= json.loads(request.body)
        selection_date=datetime.strptime(body['date'], "%Y-%m-%d").date()
        service=BeforeFixService(selection_date)
        service.run()
        return JsonResponse({
            'result':'成功'
        })
@require_http_methods(["GET"])
def initialize_strategy_parameters(request):
    if request.method=='GET':
        DecisionOrderService.initialize_strategy_parameters()
        return JsonResponse({
            'result':'成功'
        })

@require_http_methods(["POST"])
def simulate_trade(request):
    if request.method=='POST':
        body= json.loads(request.body)
        start_date=body['startDate']
        end_date=body['endDate']
        service=SimulateTradeService()
        result=service.run_backtest(start_date=start_date,end_date=end_date)
        return JsonResponse(result)
####文件结束####

####trade_manager\management\commands\run_scheduler.py####
# trade_manager/management/commands/run_scheduler.py

from django.core.management.base import BaseCommand
from trade_manager.service import scheduler_service

class Command(BaseCommand):
    help = '启动自动化交易的 APScheduler 调度器'

    def handle(self, *args, **options):
        self.stdout.write(self.style.SUCCESS('正在启动调度器服务...'))
        scheduler_service.start_scheduler()
        self.stdout.write(self.style.SUCCESS('调度器服务已停止。'))


####文件结束####

####trade_manager\service\before_fix_service.py####
# trade_manager/service/before_fix_service.py

import logging
from datetime import date, timedelta, datetime
from decimal import Decimal, ROUND_HALF_UP
from django.utils import timezone
from django.db import transaction
from django.db.models import Q

# 导入项目内的模型
from common.models import (
    CorporateAction,
    DailyTradingPlan,
    Position,
    DailyQuotes,
    SystemLog
)

# 配置日志记录器
logger = logging.getLogger(__name__)


class BeforeFixService:
    """
    T日开盘前校准与预案修正服务。

    职责:
    1. 检查当天是否已成功执行过，防止重复运行。
    2. 获取T日的除权除息事件。
    3. 计算受影响股票的价格调整比率。
    4. 根据比率修正“每日交易预案”中的MIOP和MAOP。
    5. 根据比率修正“持仓信息”中的止盈止损价。
    6. 对近期发生配股的股票进行特殊风险处理。
    """
    MODULE_NAME = '盘前校准与预案修正'
    # 可配置参数
    MAX_PLAN_LOOKBACK_DAYS = 14  # 查找交易预案的最大回溯天数
    RIGHTS_ISSUE_LOOKBACK_DAYS = 30 # 配股事件特殊处理的回溯交易日数

    def __init__(self, execution_date: date = None):
        """
        初始化服务。
        :param execution_date: T日，即执行校准的日期。如果为None，则默认为当天。
        """
        self.t_day = execution_date if execution_date else date.today()
        self.t_minus_1_day = None
        self.adjustment_ratios = {} # 存储 {stock_code: ratio}
        logger.debug(f"[{self.MODULE_NAME}] 服务初始化，目标T日: {self.t_day}")

    def _log_to_db(self, level: str, message: str):
        """辅助方法：将日志写入数据库"""
        try:
            SystemLog.objects.create(
                log_level=level,
                module_name=self.MODULE_NAME,
                message=message
            )
        except Exception as e:
            logger.error(f"无法将日志写入数据库: {e}")

    def _is_trading_day(self, check_date: date) -> bool:
        """检查指定日期是否为交易日"""
        is_trade_day = DailyQuotes.objects.filter(trade_date=check_date).exists()
        logger.info(f"检查日期 {check_date} 是否为交易日: {'是' if is_trade_day else '否'}")
        return is_trade_day

    def _get_last_trading_day(self, from_date: date) -> date | None:
        """获取指定日期之前的最后一个交易日"""
        last_day = DailyQuotes.objects.filter(
            trade_date__lt=from_date
        ).order_by('-trade_date').values_list('trade_date', flat=True).first()
      
        if last_day:
            logger.info(f"{from_date} 的前一个交易日 (T-1) 是: {last_day}")
        else:
            logger.warning(f"无法找到 {from_date} 的前一个交易日。")
        return last_day

    def _find_latest_pending_plan_date(self) -> date | None:
        """从T日开始向前回溯，查找最新的一个包含待执行预案的日期"""
        for i in range(self.MAX_PLAN_LOOKBACK_DAYS):
            check_date = self.t_day - timedelta(days=i)
            if DailyTradingPlan.objects.filter(
                plan_date=check_date,
                status=DailyTradingPlan.StatusChoices.PENDING
            ).exists():
                logger.info(f"找到待执行的交易预案，预案日期为: {check_date}")
                return check_date
        logger.warning(f"在过去 {self.MAX_PLAN_LOOKBACK_DAYS} 天内未找到任何待执行的交易预案。")
        return None

    def _calculate_adjusted_price(self, t_minus_1_close: Decimal, events: list[CorporateAction]) -> Decimal:
        """
        核心算法：根据事件列表计算除权除息参考价。
        处理顺序：1.除息 -> 2.送/转股 -> 3.配股
        """
        adjusted_price = t_minus_1_close
      
        # 按事件类型优先级排序
        event_priority = {
            CorporateAction.EventType.DIVIDEND: 1,
            CorporateAction.EventType.BONUS: 2,
            CorporateAction.EventType.TRANSFER: 2,
            CorporateAction.EventType.SPLIT: 2,
            CorporateAction.EventType.RIGHTS: 3,
        }
        sorted_events = sorted(events, key=lambda e: event_priority.get(e.event_type, 99))

        for event in sorted_events:
            # 1. 现金分红 (除息)
            if event.event_type == CorporateAction.EventType.DIVIDEND and event.dividend_per_share:
                adjusted_price -= event.dividend_per_share
          
            # 2. 送股/转增股/并股/拆股 (除权)
            elif event.event_type in [CorporateAction.EventType.BONUS, CorporateAction.EventType.TRANSFER, CorporateAction.EventType.SPLIT]:
                if event.shares_before and event.shares_after and event.shares_after > 0:
                    adjusted_price = adjusted_price * (event.shares_before / event.shares_after)

            # 3. 配股 (除权) - 注意：按需求，此计算结果不用于常规校准，但逻辑保留
            elif event.event_type == CorporateAction.EventType.RIGHTS:
                if event.shares_before and event.shares_after and event.rights_issue_price is not None and event.shares_after > 0:
                    adjusted_price = (event.shares_before * adjusted_price + (event.shares_after - event.shares_before) * event.rights_issue_price) / event.shares_after
      
        return adjusted_price

    @transaction.atomic
    def run(self):
        """执行盘前校准与修正的主流程"""

        self.t_minus_1_day = self._get_last_trading_day(self.t_day)
        if not self.t_minus_1_day:
            logger.error(f"无法确定T-1日，任务终止。")
            return

        # a. 获取T日所有除权除息信息
        events_on_t_day = CorporateAction.objects.filter(ex_dividend_date=self.t_day)
        if not events_on_t_day.exists():
            logger.debug(f"T日 ({self.t_day}) 无除权除息事件，无需校准。")
            return

        # 按股票代码分组事件
        events_by_stock = {}
        for event in events_on_t_day:
            events_by_stock.setdefault(event.stock_code, []).append(event)
      
        affected_codes = list(events_by_stock.keys())
        logger.info(f"T日共有 {len(affected_codes)} 只股票发生股权事件。")

        # 获取这些股票在T-1日的收盘价
        quotes_qs = DailyQuotes.objects.filter(
            trade_date=self.t_minus_1_day,
            stock_code_id__in=affected_codes
        )
        # 使用字典推导式构建我们需要的映射关系
        quotes_t_minus_1 = {quote.stock_code_id: quote for quote in quotes_qs}

        # b. 计算价格调整比率
        for stock_code, events in events_by_stock.items():
            if stock_code not in quotes_t_minus_1:
                logger.warning(f"股票 {stock_code} 在T-1日({self.t_minus_1_day})无行情数据（可能停牌），跳过校准。")
                continue
          
            close_t_minus_1 = quotes_t_minus_1[stock_code].close
            if close_t_minus_1 <= 0:
                logger.warning(f"股票 {stock_code} 在T-1日收盘价为0或负数，不合理，跳过校准。")
                continue

            adjusted_close = self._calculate_adjusted_price(close_t_minus_1, events)
            ratio = adjusted_close / close_t_minus_1
            self.adjustment_ratios[stock_code] = ratio
            logger.info(f"股票 {stock_code}: T-1收盘价={close_t_minus_1}, 校准后价格={adjusted_close:.2f}, 调整比率={ratio:.6f}")

        # c. 修正交易预案
        self._process_trading_plans()

        # d. 修正持仓风控
        self._process_positions()

        # e. 配股事件特殊处理
        self._handle_rights_issue_special_case()

        logger.info(f"[{self.MODULE_NAME}] 任务成功完成。共处理 {len(self.adjustment_ratios)} 只股票的常规校准。")

    def _process_trading_plans(self):
        """修正交易预案中的MIOP和MAOP"""
        plan_date_to_fix = self._find_latest_pending_plan_date()
        if not plan_date_to_fix:
            return

        plans_to_fix = DailyTradingPlan.objects.filter(
            plan_date=plan_date_to_fix,
            status=DailyTradingPlan.StatusChoices.PENDING,
            stock_code__in=self.adjustment_ratios.keys()
        )

        plans_to_update = []
        for plan in plans_to_fix:
            ratio = self.adjustment_ratios[plan.stock_code_id]
            original_miop = plan.miop
            original_maop = plan.maop
          
            plan.miop = (original_miop * Decimal(str(ratio))).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            plan.maop = (original_maop * Decimal(str(ratio))).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
          
            plans_to_update.append(plan)
            logger.info(f"交易预案修正: {plan.stock_code}, MIOP: {original_miop}->{plan.miop}, MAOP: {original_maop}->{plan.maop}")

        if plans_to_update:
            DailyTradingPlan.objects.bulk_update(plans_to_update, ['miop', 'maop'])
            logger.info(f"成功批量更新 {len(plans_to_update)} 条交易预案。")

    def _process_positions(self):
        """修正持仓中的止盈止损价"""
        positions_to_fix = Position.objects.filter(
            status=Position.StatusChoices.OPEN,
            stock_code__in=self.adjustment_ratios.keys()
        )

        positions_to_update = []
        for pos in positions_to_fix:
            ratio = self.adjustment_ratios[pos.stock_code_id]
            original_sl = pos.current_stop_loss
            original_tp = pos.current_take_profit

            pos.current_stop_loss = (original_sl * Decimal(str(ratio))).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            pos.current_take_profit = (original_tp * Decimal(str(ratio))).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
          
            positions_to_update.append(pos)
            logger.info(f"持仓风控修正: {pos.stock_code}, 止损: {original_sl}->{pos.current_stop_loss}, 止盈: {original_tp}->{pos.current_take_profit}")

        if positions_to_update:
            Position.objects.bulk_update(positions_to_update, ['current_stop_loss', 'current_take_profit'])
            logger.info(f"成功批量更新 {len(positions_to_update)} 条持仓记录。")

    def _handle_rights_issue_special_case(self):
        """处理30个交易日内有配股事件的股票"""
        # 1. 获取过去30个交易日的日期列表
        recent_trading_days = list(
            DailyQuotes.objects.filter(trade_date__lte=self.t_day)
            .order_by('-trade_date')
            .values_list('trade_date', flat=True)[:self.RIGHTS_ISSUE_LOOKBACK_DAYS]
        )
        if not recent_trading_days:
            logger.warning("无法获取最近交易日列表，跳过配股特殊处理。")
            return

        # 2. 查找在此期间发生配股的股票
        rights_issue_stocks = list(
            CorporateAction.objects.filter(
                event_type=CorporateAction.EventType.RIGHTS,
                ex_dividend_date__in=recent_trading_days
            ).values_list('stock_code', flat=True).distinct()
        )
        if not rights_issue_stocks:
            logger.info("近期无配股事件，无需特殊处理。")
            return
      
        logger.warning(f"检测到 {len(rights_issue_stocks)} 只股票近期有配股事件: {rights_issue_stocks}，将进行风险剔除。")

        # 3. 处理交易预案
        plan_date_to_fix = self._find_latest_pending_plan_date()
        if plan_date_to_fix:
            plans_to_void = DailyTradingPlan.objects.filter(
                plan_date=plan_date_to_fix,
                status=DailyTradingPlan.StatusChoices.PENDING,
                stock_code__in=rights_issue_stocks
            )
            plans_to_update = []
            for plan in plans_to_void:
                plan.miop = Decimal('99999.00')
                plan.maop = Decimal('0.00')
                plans_to_update.append(plan)
          
            if plans_to_update:
                DailyTradingPlan.objects.bulk_update(plans_to_update, ['miop', 'maop'])
                logger.info(f"配股风险处理：将 {len(plans_to_update)} 条交易预案的MIOP/MAOP置为无效。")

        # 4. 处理持仓
        positions_to_void = Position.objects.filter(
            status=Position.StatusChoices.OPEN,
            stock_code__in=rights_issue_stocks
        )
        positions_to_update = []
        for pos in positions_to_void:
            pos.current_take_profit = Decimal('0.00')
            pos.current_stop_loss = Decimal('99999.00')
            positions_to_update.append(pos)
      
        if positions_to_update:
            Position.objects.bulk_update(positions_to_update, ['current_take_profit', 'current_stop_loss'])
            logger.info(f"配股风险处理：将 {len(positions_to_update)} 条持仓的止盈/止损置为紧急退出状态。")


# --- 如何在项目中使用这个服务 ---
# 你可以在一个Django Management Command或者定时任务（如Celery）中调用它
#
# from trade_manager.service.before_fix_service import BeforeFixService
#
# def run_daily_premarket_fix():
#     # 默认使用当天日期
#     service = BeforeFixService()
#     service.run()
#
# def run_backtest_premarket_fix(some_date):
#     # 传入指定日期进行回测
#     service = BeforeFixService(execution_date=some_date)
#     service.run()


####文件结束####

####trade_manager\service\decision_order_service.py####
# trade_manager/service/decision_order_service.py

import logging
from datetime import date, timedelta
from decimal import Decimal, ROUND_HALF_UP
import pandas as pd
import pandas_ta as ta

from django.db import transaction
from django.utils import timezone

from common.models import (
    DailyTradingPlan,
    Position,
    TradeLog,
    StrategyParameters,
    DailyQuotes,
    SystemLog
)
from .trade_handler import ITradeHandler

# 配置日志记录器
logger = logging.getLogger(__name__)

class DecisionOrderService:
    """
    开盘决策与下单模块。

    该服务负责在T日开盘后的黄金时间内，根据预案、实际开盘价和账户状态，
    做出最终的买入决策，并执行下单。同时，它也提供了在订单成交后计算
    止盈止损区间的功能。
    """
    MODULE_NAME = '开盘决策与下单'

    def __init__(self, handler: ITradeHandler, execution_date: date = None):
        """
        初始化服务。

        :param handler: 一个实现了 ITradeHandler 接口的实例，用于与交易环境交互。
        :param execution_date: T日，即执行决策的日期。如果为None，则默认为当天。
                               此参数为回测模块提供了设置模拟日期的入口。
        """
        if not isinstance(handler, ITradeHandler):
            raise TypeError("传入的 handler 必须是 ITradeHandler 的一个实例。")
      
        self.handler = handler
        self.execution_date = execution_date if execution_date else date.today()
        self.params = self._load_strategy_parameters()
      
        logger.debug(f"[{self.MODULE_NAME}] 服务初始化。执行T日: {self.execution_date}")
        logger.debug(f"策略参数加载成功: {self.params}")

    def _log_to_db(self, level: str, message: str):
        """辅助方法：将日志写入数据库"""
        SystemLog.objects.create(
            log_level=level,
            module_name=self.MODULE_NAME,
            message=message
        )

    def _load_strategy_parameters(self) -> dict:
        """从数据库加载所有策略参数到内存"""
        params = {}
        # 定义需要加载的参数及其默认值，以防数据库中没有
        required_params = {
            'MAX_POSITIONS': 2,
            'MAX_CAPITAL_PER_POSITION': 25000.00,
            'k_slip': 0.002,
            'Base_Target': 0.07,
            'k_g1': 1.5,
            'Max_Target': 0.20,
            'k_h1': 2.0,
            'k_h2': 3.0,
            'Max_Loss_Percent': 0.08,
            'lookback_atr': 14,
            'lookback_adx': 14,
            'lookback_ma20': 20,
            'param_adx_threshold': 25
        }
      
        db_params = {p.param_name: p.param_value for p in StrategyParameters.objects.all()}
      
        for key, default_value in required_params.items():
            # 优先使用数据库中的值，否则使用默认值
            value = db_params.get(key, Decimal(str(default_value)))
            # 将需要整数的参数转换为int
            if key in ['MAX_POSITIONS', 'lookback_atr', 'lookback_adx', 'lookback_ma20', 'param_adx_threshold']:
                params[key] = int(value)
            else:
                params[key] = Decimal(str(value))
        return params

    # --- 暴露给外部调度的核心函数 ---

    def adjust_trading_plan_daily(self):
        """
        函数一：执行每日交易预案再调整。
        根据实际开盘价与剩余仓位进行二次筛选，关闭不会被选择的交易预案。
        """
        logger.debug(f"开始执行 {self.execution_date} 的交易预案二次筛选...")
      
        plans_today = DailyTradingPlan.objects.filter(
            plan_date=self.execution_date,
            status=DailyTradingPlan.StatusChoices.PENDING
        ).order_by('rank')

        if not plans_today.exists():
            msg = f"在 {self.execution_date} 没有找到待执行的交易预案。"
            logger.warning(msg)
            self._log_to_db('WARNING', msg)
            return

        plans_to_cancel = []
        for plan in plans_today:
            try:
                open_price = self.handler.get_opening_price(plan.stock_code)
                if open_price <= 0:
                    logger.warning(f"股票 {plan.stock_code} 开盘价为0或无效，视为不符合条件。")
                    plan.status = DailyTradingPlan.StatusChoices.CANCELLED
                    plans_to_cancel.append(plan)
                    continue

                if not (plan.miop <= open_price <= plan.maop):
                    msg = (f"预案 {plan.stock_code} (Rank:{plan.rank}) 开盘价 {open_price} "
                           f"不在区间 [{plan.miop}, {plan.maop}] 内，已作废。")
                    logger.debug(msg)
                    plan.status = DailyTradingPlan.StatusChoices.CANCELLED
                    plans_to_cancel.append(plan)

            except Exception as e:
                msg = f"获取 {plan.stock_code} 开盘价时发生错误: {e}，该预案作废。"
                logger.error(msg)
                self._log_to_db('ERROR', msg)
                plan.status = DailyTradingPlan.StatusChoices.CANCELLED
                plans_to_cancel.append(plan)

        if plans_to_cancel:
            with transaction.atomic():
                DailyTradingPlan.objects.bulk_update(plans_to_cancel, ['status'])
            logger.info(f"成功作废 {len(plans_to_cancel)} 条不符合开盘条件的交易预案。")
        else:
            logger.info("所有待执行预案均符合开盘价条件。")

    def execute_orders(self):
        """
        函数二：进行下单。
        读取预案表，选择最优标的，计算仓位和价格，并调用处理器执行下单。
        """
        logger.info(f"开始执行 {self.execution_date} 的下单流程...")

        # 1. 检查剩余仓位
        open_positions_count = Position.objects.filter(status=Position.StatusChoices.OPEN).count()
        remaining_slots = self.params['MAX_POSITIONS'] - open_positions_count

        if remaining_slots <= 0:
            msg = f"当前持仓数 {open_positions_count} 已达上限 {self.params['MAX_POSITIONS']}，今日不进行买入操作。"
            logger.warning(msg)
            self._log_to_db('WARNING', msg)
            return

        #2. 获取所有待处理的候选标的
        candidates = DailyTradingPlan.objects.filter(
            plan_date=self.execution_date,
            status=DailyTradingPlan.StatusChoices.PENDING
        ).order_by('rank')
 
        if not candidates.exists():
            msg = f"在 {self.execution_date} 无符合条件的买入标的。"
            logger.info(msg)
            self._log_to_db('INFO', msg)
            return

        # 3. 遍历所有候选标的，直到成功买入一个
        for candidate in candidates:
            try:
                stock_code = candidate.stock_code
                open_price = self.handler.get_opening_price(stock_code)
              
                # 计算下单限价
                k_slip = self.params['k_slip']
                limit_price = (open_price * (Decimal('1.0') + k_slip)).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
 
                # 计算本次交易可用资金
                available_balance = self.handler.get_available_balance()
                capital_per_slot = available_balance / Decimal(remaining_slots)
                nominal_principal = min(capital_per_slot, self.params['MAX_CAPITAL_PER_POSITION'])
 
                # 计算购入股数
                if limit_price <= 0:
                    logger.warning(f"标的 {stock_code}: 计算出的下单限价无效（{limit_price}），跳过。")
                    continue # 尝试下一个候选
 
                shares_to_buy = int(nominal_principal / limit_price)
                quantity = (shares_to_buy // 100) * 100 # 向下取整到100的倍数
 
                if quantity < 100:
                    msg = (f"标的 {stock_code}: 计算出的名义本金 {nominal_principal:.2f} 不足以购买一手（100股），"
                           f"所需金额约为 {limit_price * 100:.2f}。放弃本次交易。")
                    logger.warning(msg)
                    self._log_to_db('WARNING', msg)
                    continue # 资金不足，尝试下一个候选
 
                # 4. 执行下单
                msg = (f"确定唯一买入标的: {stock_code} (Rank:{candidate.rank})。 "
                       f"计划以限价 {limit_price} 买入 {quantity} 股。")
                logger.info(msg)
                self._log_to_db('INFO', msg)
              
                self.handler.place_buy_order(stock_code, limit_price, quantity)
              
                # 标记预案为已执行
                candidate.status = DailyTradingPlan.StatusChoices.EXECUTED
                candidate.save()
 
                # 成功买入后，立即退出函数，外层循环会决定是否继续买入下一个仓位
                return
 
            except Exception as e:
                msg = f"处理候选股 {candidate.stock_code} 时发生严重错误: {e}"
                logger.error(msg, exc_info=True)
                self._log_to_db('CRITICAL', msg)
                continue # 发生异常，继续尝试下一个候选
 
        # 如果循环正常结束，说明所有候选股都无法买入
        logger.info(f"已尝试所有 {len(candidates)} 个候选标的，均未成功买入。")

    def calculate_stop_profit_loss(self, trade_id: int):
        """
        函数三：止盈止损区间计算 (修正版)。
        在订单成交后，为新持仓计算并更新初始的止盈止损价。
 
        :param trade_id: 已成交的买入交易在 tb_trade_log 中的唯一ID。
        """
        logger.info(f"开始为 trade_id={trade_id} 计算止盈止损区间...")
        try:
            with transaction.atomic():
                # 1. 获取交易和持仓信息
                trade_log = TradeLog.objects.select_for_update().get(
                    trade_id=trade_id,
                    trade_type=TradeLog.TradeTypeChoices.BUY,
                    status=TradeLog.StatusChoices.FILLED
                )
                position = Position.objects.select_for_update().get(pk=trade_log.position_id)
 
                if position.current_stop_loss > 0:
                    logger.warning(f"Position ID {position.position_id} 似乎已计算过止盈止损，将跳过。")
                    return
 
                stock_code = trade_log.stock_code_id
                aep = trade_log.price
                buy_date = trade_log.trade_datetime.date()
              
                # 2. 获取计算所需行情数据 (避免未来函数)
                lookback_days = self.params['lookback_adx'] + 50
                start_date_for_calc = buy_date - timedelta(days=lookback_days * 2)
                end_date_for_calc = buy_date - timedelta(days=1)
 
                quotes_qs = DailyQuotes.objects.filter(
                    stock_code_id=stock_code,
                    trade_date__gte=start_date_for_calc,
                    trade_date__lte=end_date_for_calc
                ).order_by('trade_date')
 
                if len(quotes_qs) < max(self.params['lookback_atr'], self.params['lookback_adx'], self.params['lookback_ma20']):
                    raise ValueError(f"股票 {stock_code} 在 {end_date_for_calc} 前的历史数据不足，无法计算指标。")
 
                df = pd.DataFrame.from_records(quotes_qs.values('high', 'low', 'close'))
                df = df.astype(float)
 
                # 3. 计算所有必需指标
                atr_series = ta.atr(df['high'], df['low'], df['close'], length=self.params['lookback_atr'])
                atr_14_buy = Decimal(str(atr_series.iloc[-1]))
 
                ma20_series = ta.sma(df['close'], length=self.params['lookback_ma20'])
                ma20_buy = Decimal(str(ma20_series.iloc[-1]))
 
                adx_df = ta.adx(df['high'], df['low'], df['close'], length=self.params['lookback_adx'])
                adx_14_buy = Decimal(str(adx_df[f'ADX_{self.params["lookback_adx"]}'].iloc[-1]))
 
                # 4. 计算止盈价 g(y) - 逻辑不变
                profit_margin = min(
                    self.params['Base_Target'] + self.params['k_g1'] * (atr_14_buy / aep),
                    self.params['Max_Target']
                )
                take_profit_price = aep * (Decimal('1.0') + profit_margin)
 
                # 5. 计算止损价 h(z) - 严格按照需求文档逻辑
                # 5.1 根据ADX判断市场状态，选择z_final
                adx_threshold = self.params['param_adx_threshold']
                if adx_14_buy > adx_threshold:
                    # 趋势状态，使用较窄的ATR乘数
                    z_final = aep - self.params['k_h1'] * atr_14_buy
                else:
                    # 震荡状态，使用较宽的ATR乘数
                    z_final = aep - self.params['k_h2'] * atr_14_buy
 
                # 5.2 计算其他止损线
                z2_technical = ma20_buy
                z3_max_loss = aep * (Decimal('1.0') - self.params['Max_Loss_Percent'])
              
                # 5.3 取最严格的止损位（价格最高者）
                stop_loss_price = max(z_final, z2_technical, z3_max_loss)
              
                logger.info(f"[{stock_code}] 止损线比较: 趋势位={z_final:.2f}, 技术位={z2_technical:.2f}, 底线={z3_max_loss:.2f}")
 
                # 6. 更新持仓信息表
                position.current_take_profit = take_profit_price.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
                position.current_stop_loss = stop_loss_price.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
                position.save(update_fields=['current_take_profit', 'current_stop_loss'])
 
                msg = (f"成功计算并更新 Position ID {position.position_id} ({stock_code}) 的风控价格: "
                       f"购入价={aep}, 止盈价={position.current_take_profit}, 止盈率={((Decimal('1.0') + profit_margin)*100):.2f}%, 止损价={position.current_stop_loss}, 止损率={((position.current_stop_loss/aep)*100):.2f}%")
                logger.info(msg)
                self._log_to_db('INFO', msg)
 
        except TradeLog.DoesNotExist:
            logger.error(f"Trade ID {trade_id} 不存在或不满足计算条件（非买入/未成交）。")
        except Position.DoesNotExist:
            logger.error(f"与 Trade ID {trade_id} 关联的 Position 不存在。")
        except Exception as e:
            msg = f"为 Trade ID {trade_id} 计算止盈止损时发生严重错误: {e}"

    # --- 工具函数 ---

    @staticmethod
    def initialize_strategy_parameters():
        """
        工具函数：初始化本模块所需的策略参数到数据库。
        这是一个幂等操作，可以安全地重复运行。
        """
        logger.info("开始初始化[开盘决策与下单模块]的策略参数...")

        params_to_define = {
            # 仓位管理
            'MAX_POSITIONS': {'value': '2', 'group': 'POSITION_MGMT', 'desc': '最大可具备的总仓位数'},
            'MAX_CAPITAL_PER_POSITION': {'value': '25000.00', 'group': 'POSITION_MGMT', 'desc': '每仓最大投入资金数(元)'},
            # 下单参数
            'k_slip': {'value': '0.002', 'group': 'ORDER_EXEC', 'desc': '下单滑点系数, 用于计算限价单价格'},
            # 止盈参数 g(y)
            'Base_Target': {'value': '0.07', 'group': 'TAKE_PROFIT', 'desc': '基础止盈目标百分比'},
            'k_g1': {'value': '1.5', 'group': 'TAKE_PROFIT', 'desc': 'ATR溢价乘数, 用于动态调整止盈目标'},
            'Max_Target': {'value': '0.20', 'group': 'TAKE_PROFIT', 'desc': '最大止盈目标百分比上限'},
            # 止损参数 h(z)
            'k_h1': {'value': '2.0', 'group': 'STOP_LOSS', 'desc': '趋势市ATR止损乘数 (盘中动态使用)'},
            'k_h2': {'value': '3.0', 'group': 'STOP_LOSS', 'desc': '震荡市ATR止损乘数 (用于计算初始止损)'},
            'Max_Loss_Percent': {'value': '0.08', 'group': 'STOP_LOSS', 'desc': '最大回撤容忍度(绝对亏损百分比上限)'},
            # 指标周期
            'lookback_atr': {'value': '14', 'group': 'INDICATORS', 'desc': 'ATR计算周期'},
            'lookback_adx': {'value': '14', 'group': 'INDICATORS', 'desc': 'ADX计算周期'},
            'lookback_ma20': {'value': '20', 'group': 'INDICATORS', 'desc': 'MA20计算周期'},
        }

        with transaction.atomic():
            for name, data in params_to_define.items():
                StrategyParameters.objects.update_or_create(
                    param_name=name,
                    defaults={
                        'param_value': Decimal(data['value']),
                        'group_name': data['group'],
                        'description': data['desc']
                    }
                )
      
        logger.info(f"成功初始化/更新 {len(params_to_define)} 个策略参数。")


####文件结束####

####trade_manager\service\monitor_exit_service.py####
# trade_manager/service/monitor_exit_service.py

import logging
from datetime import date
from django.utils import timezone
from decimal import Decimal

# 导入项目内的模型和接口
from common.models import Position, TradeLog
from .trade_handler import ITradeHandler

persistent_logger = logging.getLogger(__name__)


class MonitorExitService:
    """
    3.5 - 盘中持仓监控与退出模块

    该服务负责在交易时段内，以固定频率轮询，监控所有非当日建仓的持仓。
    当持仓股票的实时价格触及预设的止盈或止损线时，调用交易处理器执行卖出操作。
    """
    MODULE_NAME = '盘中持仓监控与退出'

    def __init__(self, handler: ITradeHandler,execution_date: date = None):
        """
        初始化监控服务。

        :param handler: 一个实现了 ITradeHandler 接口的实例，用于与交易环境交互。
        """
        if not isinstance(handler, ITradeHandler):
            raise TypeError("传入的 handler 必须是 ITradeHandler 的一个实例。")
      
        self.handler = handler
        self.execution_date = execution_date if execution_date else timezone.now().date()
        # 使用特定的logger进行高频、非持久化的日志记录
        self.logger = persistent_logger

    def monitor_and_exit_positions(self):
        """
        执行一次完整的持仓监控与退出检查。
        此函数应由一个定时调度器在交易时段内（09:30:01 - 14:57:00）
        以设定的频率反复调用。
        """
        self.logger.debug(f"[{self.MODULE_NAME}] 任务开始...")

        # 1. 从持仓信息表读取出entry_datetime建仓成交时间不为今天的持仓信息
        today = timezone.now().date()
        positions_to_monitor = Position.objects.filter(
            status=Position.StatusChoices.OPEN
        ).exclude(
            entry_datetime__date=self.execution_date
        )

        if not positions_to_monitor.exists():
            self.logger.debug("当前无需要监控的隔夜持仓。")
            return

        # 2. 循环调用处理器判断是否达到了止盈止损状态
        for position in positions_to_monitor:
            try:
                # 获取实时价格
                current_price = self.handler.get_realtime_price(position.stock_code)

                if current_price is None or current_price <= 0:
                    self.logger.debug(f"无法获取 {position.stock_code} 的有效实时价格，跳过本次检查。")
                    continue
              
                self.logger.debug(
                    f"监控: {position.stock_code}, "
                    f"当前价: {current_price}, "
                    f"止损价: {position.current_stop_loss}, "
                    f"止盈价: {position.current_take_profit}"
                )

                # 检查是否触发止损
                if current_price <= position.current_stop_loss:
                    msg = (f"触发止损条件! 股票: {position.stock_code}, "
                           f"当前价: {current_price} <= 止损价: {position.current_stop_loss}。准备执行卖出。")
                    persistent_logger.info(msg) # 这是一个重要事件，使用可持久化的logger
                    self.handler.sell_stock_by_market_price(position, TradeLog.ReasonChoices.STOP_LOSS)
                    # 卖出后，此持仓在下一次循环中将不再被查询到，无需从当前循环中移除

                # 检查是否触发止盈
                elif current_price >= position.current_take_profit:
                    msg = (f"触发止盈条件! 股票: {position.stock_code}, "
                           f"当前价: {current_price} >= 止盈价: {position.current_take_profit}。准备执行卖出。")
                    persistent_logger.info(msg) # 这是一个重要事件，使用可持久化的logger
                    self.handler.sell_stock_by_market_price(position, TradeLog.ReasonChoices.TAKE_PROFIT)

            except Exception as e:
                # 根据要求，卖出失败等异常只在控制台打印错误日志，等待下一次循环
                self.logger.error(
                    f"处理持仓 {position.position_id} ({position.stock_code}) 时发生错误: {e}",
                    exc_info=False # 在高频场景下，可以关闭traceback以保持日志简洁
                )
                continue
      
        self.logger.debug(f"[{self.MODULE_NAME}] 任务结束。")


####文件结束####

####trade_manager\service\real_trade_handler.py####
# trade_manager/service/real_trade_handler.py

import logging
import json
from decimal import Decimal, ROUND_HALF_UP
from datetime import date, time, datetime, timedelta

import easytrader
import akshare as ak
from django.db import transaction
from django.utils import timezone

from .trade_handler import ITradeHandler
from common.models import Position, TradeLog, DailyQuotes
from trade_manager.service.decision_order_service import DecisionOrderService
from common.config_loader import config_loader # 使用统一的配置加载器

logger = logging.getLogger(__name__)

class ConnectionManager:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(ConnectionManager, cls).__new__(cls, *args, **kwargs)
        return cls._instance

    def __init__(self):
        if not hasattr(self, 'initialized'):
            self.user = None
            self.last_connected_date = None
            self.last_refreshed_time = None # 新增：上次刷新时间
            self.refresh_interval = timedelta(minutes=5) # 新增：刷新间隔
            self.initialized = True
            logger.info("ConnectionManager 已初始化。")

    def get_user(self):
        """获取或创建当天的 easytrader 连接，并按需刷新"""
        config = config_loader.get('easytrader')
        today = date.today()
      
        if not self.user or self.last_connected_date != today:
            logger.info("当天首次连接或连接已失效，正在重新建立 easytrader 连接...")
            try:
                self._connect(config)
                self.last_connected_date = today
                self.last_refreshed_time = datetime.now()
                logger.info("easytrader 连接成功。")
            except Exception as e:
                logger.error(f"连接 easytrader 失败: {e}", exc_info=True)
                self.user = None
                self.last_connected_date = None
                raise
      
        # 检查是否需要刷新
        if datetime.now() - self.last_refreshed_time > self.refresh_interval:
            logger.info("会话超过5分钟未刷新，执行 user.refresh()...")
            try:
                self.user.refresh()
                self.last_refreshed_time = datetime.now()
                logger.info("user.refresh() 执行成功。")
            except Exception as e:
                logger.error(f"执行 user.refresh() 失败: {e}，将尝试断开重连。")
                self.disconnect() # 刷新失败，可能连接已断，强制断开
                # 下次调用 get_user 时会自动重连
                raise # 抛出异常，让当前操作失败
      
        return self.user

    def _connect(self, config: dict):
        client_type = config.get('client_type', 'ht_client')
        user_config_path = config.get('user_config_path')
      
        if client_type == 'ht_client':
            self.user = easytrader.use('ht')
            self.user.prepare(user_config_path)
        else:
            raise NotImplementedError(f"不支持的客户端类型: {client_type}")

    def disconnect(self):
        if self.user:
            try:
                self.user.exit()
                logger.info("easytrader 连接已成功断开。")
            except Exception as e:
                logger.error(f"断开 easytrader 连接时出错: {e}", exc_info=True)
            finally:
                self.user = None
                self.last_connected_date = None
                self.last_refreshed_time = None

connection_manager = ConnectionManager()

class RealTradeHandler(ITradeHandler):
    COMMISSION_RATE = Decimal('0.00025')
    MIN_COMMISSION = Decimal('5')
    STAMP_DUTY_RATE = Decimal('0.001')

    def __init__(self):
        config = config_loader.get_config()
        self.is_simulation = (config.get('trading_mode') == 'real_simulation_observation')
        logger.info(f"RealTradeHandler 初始化。模式: {'实盘模拟观测' if self.is_simulation else '实盘交易'}")

    def _get_user(self):
        return connection_manager.get_user()

    def _api_buy(self, stock_code: str, price: Decimal, quantity: int):
        user = self._get_user()
        ak_code = stock_code.split('.')[-1]
        return user.buy(ak_code, price=float(price), amount=quantity)

    def _api_sell(self, stock_code: str, quantity: int):
        user = self._get_user()
        ak_code = stock_code.split('.')[-1]
        return user.sell(ak_code, amount=quantity)

    def _api_get_orders(self):
        user = self._get_user()
        return user.entrust

    def _api_get_balance(self):
        user = self._get_user()
        return user.balance

    def _api_get_realtime_quote(self, stock_code: str) -> dict:
        ak_code = stock_code.split('.')[-1]
        try:
            df = ak.stock_zh_a_spot_em(symbol=ak_code)
            if not df.empty:
                quote = df.iloc[0]
                return {
                    'open': Decimal(str(quote['今开'])),
                    'price': Decimal(str(quote['最新价'])),
                }
        except Exception as e:
            logger.warning(f"通过 akshare 获取 {stock_code} 实时行情失败: {e}")
        return {}

    def get_opening_price(self, stock_code: str) -> Decimal:
        quote = self._api_get_realtime_quote(stock_code)
        return quote.get('open', Decimal('0.00'))

    def get_realtime_price(self, stock_code: str) -> Decimal | None:
        quote = self._api_get_realtime_quote(stock_code)
        return quote.get('price')

    def get_available_balance(self) -> Decimal:
        if self.is_simulation:
            return Decimal('1000000.00')
      
        balance_info = self._api_get_balance()
        return Decimal(str(balance_info.get('可用金额', '0.00')))

    @transaction.atomic
    def place_buy_order(self, stock_code: str, price: Decimal, quantity: int):
        logger.info(f"准备下单买入: {stock_code}, 价格: {price}, 数量: {quantity}")
      
        entry_datetime = timezone.now()
        position = Position.objects.create(
            stock_code_id=stock_code, entry_datetime=entry_datetime,
            entry_price=price, quantity=quantity,
            current_stop_loss=Decimal('0.00'), current_take_profit=Decimal('0.00'),
            status=Position.StatusChoices.OPEN
        )
        trade_log = TradeLog.objects.create(
            position=position, stock_code_id=stock_code,
            trade_datetime=entry_datetime, trade_type=TradeLog.TradeTypeChoices.BUY,
            order_type=TradeLog.OrderTypeChoices.LIMIT, price=price,
            quantity=quantity, commission=Decimal('0.00'), stamp_duty=Decimal('0.00'),
            reason=TradeLog.ReasonChoices.ENTRY, status=TradeLog.StatusChoices.PENDING
        )

        if self.is_simulation:
            logger.info("[模拟模式] 跳过真实API调用，直接模拟成交。")
            amount = price * quantity
            commission = max(amount * self.COMMISSION_RATE, self.MIN_COMMISSION)
            trade_log.status = TradeLog.StatusChoices.FILLED
            trade_log.commission = commission.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            trade_log.save()
          
            decision_service = DecisionOrderService(self, execution_date=date.today())
            decision_service.calculate_stop_profit_loss(trade_log.trade_id)
        else:
            try:
                order_result = self._api_buy(stock_code, price, quantity)
                logger.info(f"真实买入委托已提交: {order_result}")
                # 关键：保存委托编号
                if order_result and 'entrust_no' in order_result:
                    trade_log.external_order_id = str(order_result['entrust_no'])
                    trade_log.save()
            except Exception as e:
                logger.error(f"提交买入委托失败: {e}", exc_info=True)
                trade_log.status = TradeLog.StatusChoices.FAILED
                trade_log.save()
                position.status = Position.StatusChoices.CLOSED
                position.save()

    @transaction.atomic
    def sell_stock_by_market_price(self, position: Position, reason: str):
        logger.info(f"准备市价卖出: {position.stock_code_id}, 数量: {position.quantity}, 原因: {reason}")

        trade_log = TradeLog.objects.create(
            position=position, stock_code_id=position.stock_code_id,
            trade_datetime=timezone.now(), trade_type=TradeLog.TradeTypeChoices.SELL,
            order_type=TradeLog.OrderTypeChoices.MARKET, price=Decimal('0.00'),
            quantity=position.quantity, commission=Decimal('0.00'), stamp_duty=Decimal('0.00'),
            reason=reason, status=TradeLog.StatusChoices.PENDING
        )

        if self.is_simulation:
            logger.info("[模拟模式] 跳过真实API调用，直接模拟成交。")
            try:
                last_quote = DailyQuotes.objects.filter(stock_code_id=position.stock_code_id).latest('trade_date')
                sell_price = last_quote.close
            except DailyQuotes.DoesNotExist:
                sell_price = position.entry_price

            amount = sell_price * position.quantity
            commission = max(amount * self.COMMISSION_RATE, self.MIN_COMMISSION)
            stamp_duty = amount * self.STAMP_DUTY_RATE

            trade_log.status = TradeLog.StatusChoices.FILLED
            trade_log.price = sell_price
            trade_log.commission = commission.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            trade_log.stamp_duty = stamp_duty.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            trade_log.save()

            position.status = Position.StatusChoices.CLOSED
            position.save()
        else:
            try:
                order_result = self._api_sell(position.stock_code_id, position.quantity)
                logger.info(f"真实卖出委托已提交: {order_result}")
                if order_result and 'entrust_no' in order_result:
                    trade_log.external_order_id = str(order_result['entrust_no'])
                    trade_log.save()
            except Exception as e:
                logger.error(f"提交卖出委托失败: {e}", exc_info=True)
                trade_log.status = TradeLog.StatusChoices.FAILED
                trade_log.save()

####文件结束####

####trade_manager\service\scheduler_service.py####
# trade_manager/service/scheduler_service.py

import logging
import pandas as pd # 修正：导入pandas
from datetime import date, timedelta, datetime

import akshare as ak
from apscheduler.schedulers.background import BackgroundScheduler # 使用BackgroundScheduler
from django.conf import settings
from django.db import transaction
from decimal import Decimal

from selection_manager.service.selection_service import SelectionService
from data_manager.service.corporate_action_service import CorporateActionService
from trade_manager.service.before_fix_service import BeforeFixService
from trade_manager.service.decision_order_service import DecisionOrderService
from trade_manager.service.monitor_exit_service import MonitorExitService
from trade_manager.service.real_trade_handler import RealTradeHandler, connection_manager
from common.models import TradeLog, Position
from common.config_loader import config_loader

logger = logging.getLogger(__name__)

class TradingCalendar:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(TradingCalendar, cls).__new__(cls, *args, **kwargs)
        return cls._instance

    def __init__(self):
        if not hasattr(self, 'initialized'):
            self.trade_dates = set()
            self.last_updated = None
            self.initialized = True
            self._update_calendar()

    def _update_calendar(self):
        logger.info("正在更新交易日历...")
        try:
            df = ak.tool_trade_date_hist_sina()
            self.trade_dates = set(pd.to_datetime(df['trade_date']).dt.date)
            self.last_updated = date.today()
            logger.info(f"交易日历更新成功，共获取 {len(self.trade_dates)} 个交易日。")
        except Exception as e:
            logger.error(f"更新交易日历失败: {e}", exc_info=True)

    def is_trading_day(self, check_date: date) -> bool:
        if date.today() != self.last_updated:
            self._update_calendar()
        return check_date in self.trade_dates

trading_calendar = TradingCalendar()

# --- Job Functions ---

def run_job_wrapper(job_func, job_name, *args, **kwargs):
    scheduler_status = config_loader.get('scheduler', {}).get('status')
    if scheduler_status == 'off': return

    logger.info(f"--- [{job_name}] 任务触发 ---")
    if scheduler_status == 'dry_run':
        logger.info(f"[{job_name}] 空转模式，任务仅打印日志，不执行。")
        return
  
    try:
        job_func(*args, **kwargs)
        logger.info(f"--- [{job_name}] 任务成功执行 ---")
    except Exception as e:
        logger.error(f"--- [{job_name}] 任务执行失败: {e} ---", exc_info=True)

def daily_check():
    today = date.today()
    if not trading_calendar.is_trading_day(today):
        logger.debug(f"{today} 不是交易日，今日主要交易流程任务将跳过。")
        return False
    return True

def selection_job():
    t_minus_1 = date.today() - timedelta(days=1)
    if not trading_calendar.is_trading_day(t_minus_1):
        logger.info(f"昨日({t_minus_1})不是交易日，不执行选股任务。")
        return
    service = SelectionService(trade_date=t_minus_1, mode='realtime')
    service.run_selection()

def premarket_fix_job():
    if not daily_check(): return
    service = BeforeFixService(execution_date=date.today())
    service.run()

def opening_decision_job():
    if not daily_check(): return
    handler = RealTradeHandler()
    service = DecisionOrderService(handler, execution_date=date.today())
  
    logger.info("执行交易预案二次筛选...")
    service.adjust_trading_plan_daily()
  
    logger.info("循环执行下单，尝试填满仓位...")
    max_positions = int(service.params.get('MAX_POSITIONS', 2))

  
    open_positions_count = Position.objects.filter(status=Position.StatusChoices.OPEN).count()
    slots_to_fill = max_positions - open_positions_count
 
    # 3. 循环调用同一个实例的方法
    for i in range(slots_to_fill):
        logger.info(f"尝试填充第 {i+1}/{slots_to_fill} 个仓位...")
        service.execute_orders()

def monitoring_job():
    if not daily_check(): return
    handler = RealTradeHandler()
    service = MonitorExitService(handler, execution_date=date.today())
    service.monitor_and_exit_positions()

def update_order_status_job():
    if not daily_check(): return
    handler = RealTradeHandler()
    if handler.is_simulation: return

    pending_trades = TradeLog.objects.filter(status=TradeLog.StatusChoices.PENDING, external_order_id__isnull=False)
    if not pending_trades.exists(): return
  
    try:
        real_orders = handler._api_get_orders()
        if not real_orders: return
        real_orders_map = {str(o['entrust_no']): o for o in real_orders}

        for trade in pending_trades:
            real_order = real_orders_map.get(trade.external_order_id)
            if not real_order: continue
          
            if real_order['order_status'] in ['已成', '全部成交']:
                with transaction.atomic():
                    trade.status = TradeLog.StatusChoices.FILLED
                    trade.price = Decimal(str(real_order['filled_price']))
                    # 注意：easytrader返回的佣金可能不准确，这里仅为示例
                    trade.commission = Decimal(str(real_order.get('business_balance', '0.0'))) - Decimal(str(real_order.get('clear_balance', '0.0')))
                    trade.save()

                    if trade.trade_type == 'buy':
                        decision_service = DecisionOrderService(handler, execution_date=date.today())
                        decision_service.calculate_stop_profit_loss(trade.trade_id)
                    else: # sell
                        position = trade.position
                        position.status = Position.StatusChoices.CLOSED
                        position.save()
                logger.info(f"订单 {trade.trade_id} (委托号: {trade.external_order_id}) 状态更新为已成交。")

            elif real_order['order_status'] in ['已撤', '废单', '部成已撤']:
                with transaction.atomic():
                    trade.status = TradeLog.StatusChoices.CANCELLED if '撤' in real_order['order_status'] else TradeLog.StatusChoices.FAILED
                    trade.save()
                    if trade.trade_type == 'buy':
                        position = trade.position
                        position.status = Position.StatusChoices.CLOSED
                        position.save()
                logger.info(f"订单 {trade.trade_id} (委托号: {trade.external_order_id}) 状态更新为 {trade.status}。")

    except Exception as e:
        logger.error(f"更新订单状态时出错: {e}", exc_info=True)

def update_corporate_actions_job():
    today = date.today()
    start_date = today - timedelta(days=30)
    end_date = today + timedelta(days=30)
    service = CorporateActionService()
    service.sync_corporate_actions(start_date=start_date.strftime('%Y-%m-%d'), end_date=end_date.strftime('%Y-%m-%d'))

def disconnect_job():
    logger.info("执行每日断开连接任务...")
    connection_manager.disconnect()

scheduler = BackgroundScheduler(timezone='Asia/Shanghai')


def schedule_intraday_jobs():
    """在每个交易日开盘前，添加当天的盘中监控任务。"""
    job_id_monitor = 'intraday_monitoring_job'
    job_id_order_status = 'intraday_order_status_job'
  
    # 为防止重复添加，先尝试移除旧的（如果存在）
    try:
        scheduler.remove_job(job_id_monitor)
        logger.info(f"成功移除旧的盘中监控任务 (ID: {job_id_monitor})。")
    except Exception:
        pass # JobNotFoundError, a normal case
  
    try:
        scheduler.remove_job(job_id_order_status)
        logger.info(f"成功移除旧的订单状态更新任务 (ID: {job_id_order_status})。")
    except Exception:
        pass
 
    if not daily_check(): return
 
    today_str = date.today().isoformat()
    logger.info(f"正在为 {today_str} 添加盘中任务...")
 
    scheduler.add_job(
        run_job_wrapper, 
        'interval', 
        seconds=5, 
        start_date=f'{today_str} 09:30:01', 
        end_date=f'{today_str} 14:57:00', 
        args=[monitoring_job, '盘中监控'],
        id=job_id_monitor, # **给任务一个唯一的ID**
        replace_existing=True # 如果ID已存在，则替换
    )
 
    scheduler.add_job(
        run_job_wrapper, 
        'interval', 
        seconds=10, 
        start_date=f'{today_str} 09:30:00', 
        end_date=f'{today_str} 15:00:00', 
        args=[update_order_status_job, '更新订单状态'],
        id=job_id_order_status, # **给任务一个唯一的ID**
        replace_existing=True
    )
    logger.info("当日盘中任务已成功调度。")
 
 
# 清理任务的函数，虽然 replace_existing=True也能工作，但显式清理更干净
def cleanup_intraday_jobs():
    """收盘后清理，以防万一。"""
    try:
        scheduler.remove_job('intraday_monitoring_job')
        scheduler.remove_job('intraday_order_status_job')
        logger.info("已清理当日盘中任务。")
    except Exception:
        pass


def start():
    """启动调度器的主函数"""
    if config_loader.get('scheduler', {}).get('status') == 'off':
        logger.info("调度器状态为 'off'，不启动。")
        return

    if scheduler.running:
        logger.warning("调度器已在运行中。")
        return

    # 添加任务
    scheduler.add_job(run_job_wrapper, 'cron', day='*', hour=18, minute=0, args=[selection_job, '日终选股'])
    scheduler.add_job(run_job_wrapper, 'cron', day='*', hour=8, minute=30, args=[premarket_fix_job, '盘前校准'])
    scheduler.add_job(run_job_wrapper, 'cron', day='*', hour=9, minute=25, second=5, args=[opening_decision_job, '开盘决策'])
  
    # --- 每日动态任务的调度器 ---
    # 在每个交易日的开盘前（例如9:00）安排好当天的盘中任务
    scheduler.add_job(schedule_intraday_jobs, 'cron', day='*', hour=9, minute=0)
    #在收盘后清理
    scheduler.add_job(cleanup_intraday_jobs, 'cron', day='*', hour=15, minute=5)
  
    # 数据和连接管理任务
    scheduler.add_job(run_job_wrapper, 'cron', day='*', hour=6, minute=0, args=[update_corporate_actions_job, '更新除权除息'])
    scheduler.add_job(run_job_wrapper, 'cron', day='*', hour=15, minute=30, args=[disconnect_job, '断开连接'])

    logger.info("APScheduler 已配置完成，准备在后台启动...")
    scheduler.start()

####文件结束####

####trade_manager\service\simulate_trade.py####
# trade_manager/service/simulate_trade.py

import logging
import shutil
import os
from datetime import date, timedelta
from decimal import Decimal, ROUND_HALF_UP
import numpy as np
import pandas as pd
import time
from django.conf import settings
from django.db import connections, transaction
import sqlite3
from common.models import (
    DailyFactorValues, DailyTradingPlan, Position, TradeLog, SystemLog,
    StrategyParameters, DailyQuotes, CorporateAction
)
from selection_manager.service.selection_service import SelectionService
from trade_manager.service.before_fix_service import BeforeFixService
from trade_manager.service.decision_order_service import DecisionOrderService
from trade_manager.service.monitor_exit_service import MonitorExitService
from .simulate_trade_handler import SimulateTradeHandler

logger = logging.getLogger(__name__)

class SimulateTradeService:
    """
    回测实施服务。
    """
    COMMISSION_RATE = Decimal('0.0002854')
    MIN_COMMISSION = Decimal('5')
    STAMP_DUTY_RATE = Decimal('0.001')
    SELL_SLIPPAGE_RATE = Decimal('0.002')
    ANNUAL_RISK_FREE_RATE = Decimal('0.015')
    TRADING_DAYS_PER_YEAR = 252

    def __init__(self):
        self.start_date: date = None
        self.end_date: date = None
        self.current_date: date = None
        self.initial_capital = Decimal('0.0')
        self.cash_balance = Decimal('0.0')
        self.portfolio_history = []
        self.last_buy_trade_id = None
        self.original_db_config = None
    def _load_db_to_memory(self, source_db_path: str):
        """
        【优化版】使用 SQLite Backup API 高效地将磁盘数据库加载到内存。
        """
        logger.info(f"开始将数据从 {source_db_path} 加载到内存 (使用 Backup API)...")
        start_time = time.time()
      
        # 1. 创建一个到源文件数据库的直接连接 (只读)
        try:
            source_conn = sqlite3.connect(f'file:{source_db_path}?mode=ro', uri=True)
        except sqlite3.OperationalError as e:
            logger.error(f"无法以只读模式打开源数据库 {source_db_path}: {e}")
            raise
 
        # 2. 获取到Django管理的内存数据库的底层连接
        mem_conn = connections['default'].connection
 
        try:
            # 3. 【核心优化】使用 backup 方法
            #    它会以最有效的方式（通常是按数据页）将源数据库内容复制到目标数据库
            source_conn.backup(mem_conn)
          
            duration = time.time() - start_time
            logger.info(f"数据成功加载到内存数据库，耗时: {duration:.2f} 秒。")
 
        except Exception as e:
            logger.error(f"使用 Backup API 加载数据到内存时发生错误: {e}")
            raise
        finally:
            # 4. 关闭连接
            source_conn.close()
            # mem_conn 不需要我们手动关闭，Django会管理它
 


    # def _setup_environment(self):
    #     logger.info("--- 1. 准备回测环境 ---")
      
    #     base_dir = settings.BASE_DIR
    #     source_db = os.path.join(base_dir, 'mainDB.sqlite3')
    #     temp_db = os.path.join(base_dir, 'temp.sqlite3')
      
    #     if os.path.exists(temp_db):
    #         os.remove(temp_db)
    #     shutil.copy2(source_db, temp_db)
    #     logger.info(f"数据库已从 {source_db} 复制到 {temp_db}")

    #     connections.close_all()
    #     # 关键修复：保存原始配置，以便恢复
    #     self.original_db_config = settings.DATABASES['default'].copy()
    #     settings.DATABASES['default']['NAME'] = temp_db
    #     logger.info(f"已将 'default' 数据库连接重定向到 {temp_db}")

    #     tables_to_clear = [
    #         DailyFactorValues, DailyTradingPlan, Position,
    #         TradeLog, SystemLog
    #     ]
    #     with transaction.atomic():
    #         for model in tables_to_clear:
    #             model.objects.all().delete()
    #             logger.info(f"已清空表: {model._meta.db_table}")

    #     params = {p.param_name: p.param_value for p in StrategyParameters.objects.all()}
    #     max_positions = int(params.get('MAX_POSITIONS', Decimal('5')))
    #     max_capital_per_pos = params.get('MAX_CAPITAL_PER_POSITION', Decimal('10000'))
    #     self.initial_capital = Decimal(max_positions) * max_capital_per_pos
    #     self.cash_balance = self.initial_capital
    #     logger.info(f"初始资金已设定为: {self.initial_capital:.2f}")

    # def _cleanup_environment(self):
    #     """在回测结束后恢复原始数据库配置"""
    #     if self.original_db_config:
    #         connections.close_all()
    #         settings.DATABASES['default'] = self.original_db_config
    #         logger.info("已恢复 'default' 数据库连接到原始配置。")
    def _setup_environment(self):
        """
        修正版：调整了操作顺序，先加载数据，再执行ORM操作。
        """
        logger.info("--- 1. 准备回测环境 (内存模式) ---")
      
        base_dir = settings.BASE_DIR
        source_db = os.path.join(base_dir, 'mainDB.sqlite3')
      
        # 1. 关闭所有现有连接
        connections.close_all()
      
        # 2. 保存原始配置，并将 'default' 数据库重定向到内存
        self.original_db_config = settings.DATABASES['default'].copy()
        settings.DATABASES['default']['NAME'] = ':memory:'
        logger.info("已将 'default' 数据库连接重定向到 :memory:")
 
        # 3. 确保Django建立到新内存数据库的连接
        #    这一步至关重要，它会创建一个空的内存数据库实例
        connections['default'].ensure_connection()
      
        # 4. 【核心修正】立即将磁盘数据加载到内存数据库中
        #    此时，内存数据库从空变成了 mainDB.sqlite3 的一个完整克隆
        self._load_db_to_memory(source_db)
 
        # 5. 【顺序调整】现在内存数据库是完整的了，可以安全地执行任何Django ORM操作
      

        #DailyFactorValues, DailyTradingPlan,
        # 清空回测过程中会产生数据的表
        tables_to_clear = [
             Position,
            TradeLog, SystemLog
        ]
        # 使用 transaction.atomic() 来保证操作的原子性
        with transaction.atomic():
            for model in tables_to_clear:
                # 现在 model.objects.all() 可以正常工作了
                model.objects.all().delete()
                logger.info(f"已清空表: {model._meta.db_table}")
 
        # 读取策略参数
        # 现在 StrategyParameters.objects.all() 也可以正常工作了
        params = {p.param_name: p.param_value for p in StrategyParameters.objects.all()}
        max_positions = int(params.get('MAX_POSITIONS', Decimal('5')))
        max_capital_per_pos = params.get('MAX_CAPITAL_PER_POSITION', Decimal('10000'))
        self.initial_capital = Decimal(max_positions) * max_capital_per_pos
        self.cash_balance = self.initial_capital
        logger.info(f"初始资金已设定为: {self.initial_capital:.2f}")
 
    def _cleanup_environment(self):
        """在回测结束后恢复原始数据库配置"""
        if self.original_db_config:
            connections.close_all()
            settings.DATABASES['default'] = self.original_db_config
            # 内存数据库的连接关闭后，其内容会自动销毁，无需手动删除文件
            logger.info("已恢复 'default' 数据库连接到原始配置，内存数据库已释放。")
    def _get_trading_days(self) -> list[date]:
        dates = DailyQuotes.objects.filter(
            trade_date__gte=self.start_date,
            trade_date__lte=self.end_date
        ).values_list('trade_date', flat=True).distinct().order_by('trade_date')
        return list(dates)

    def _calculate_daily_portfolio_value(self):
        open_positions = Position.objects.filter(status=Position.StatusChoices.OPEN)
        market_value = Decimal('0.0')
        for pos in open_positions:
            try:
                quote = DailyQuotes.objects.get(
                    stock_code_id=pos.stock_code_id,
                    trade_date=self.current_date
                )
                market_value += quote.close * pos.quantity
            except DailyQuotes.DoesNotExist:
                market_value += pos.entry_price * pos.quantity
      
        total_value = self.cash_balance + market_value
        self.portfolio_history.append({
            'date': self.current_date,
            'total_value': total_value
        })
        logger.info(f"--- 日终结算 ({self.current_date}) ---")
        logger.info(f"现金: {self.cash_balance:.2f}, 持仓市值: {market_value:.2f}, 总资产: {total_value:.2f}")

    def _calculate_performance_metrics(self) -> dict:
        logger.info("--- 4. 计算回测性能指标 ---")
        if not self.portfolio_history:
            return {}

        df = pd.DataFrame(self.portfolio_history)
        df['total_value'] = df['total_value'].astype(float)
        df['daily_return'] = df['total_value'].pct_change().fillna(0)
      
        final_value = float(df['total_value'].iloc[-1])
        total_return_amount = final_value - float(self.initial_capital)
        total_return_rate = (final_value / float(self.initial_capital)) - 1

        mean_daily_return = df['daily_return'].mean()
        std_daily_return = df['daily_return'].std()
      
        if std_daily_return == 0 or np.isnan(std_daily_return):
            sharpe_ratio = 0.0
        else:
            daily_risk_free_rate = (1 + self.ANNUAL_RISK_FREE_RATE) ** Decimal(1/self.TRADING_DAYS_PER_YEAR) - 1
            sharpe_ratio = (mean_daily_return - float(daily_risk_free_rate)) / std_daily_return
            sharpe_ratio *= np.sqrt(self.TRADING_DAYS_PER_YEAR)

        result = {
            'total_return_amount': round(total_return_amount, 2),
            'total_return_rate': round(total_return_rate, 4),
            'sharpe_ratio': round(float(sharpe_ratio), 4)
        }
        logger.info(f"回测结果: {result}")
        return result

    def run_backtest(self, start_date: str, end_date: str) -> dict:
        try:
            self.start_date = date.fromisoformat(start_date)
            self.end_date = date.fromisoformat(end_date)

            self._setup_environment()

            handler = SimulateTradeHandler(self)
          
            trading_days = self._get_trading_days()
            if not trading_days:
                logger.error("在指定日期范围内未找到任何交易日，回测终止。")
                return {}

            baseline_date = trading_days[0] - timedelta(days=1)
            self.portfolio_history.append({'date': baseline_date, 'total_value': self.initial_capital})

            logger.info(f"--- 2. 开始日度回测循环 ({len(trading_days)}天) ---")
            for i, current_day in enumerate(trading_days):
                self.current_date = current_day
                logger.info(f"\n{'='*20} 模拟日: {self.current_date} ({i+1}/{len(trading_days)}) {'='*20}")

                prev_trading_day = trading_days[i-1] if i > 0 else None
                if prev_trading_day:
                    logger.info(f"-> [T-1 选股] 基于 {prev_trading_day} 的数据...")
                    selection_service = SelectionService(trade_date=prev_trading_day, mode='backtest')
                    selection_service.run_selection()

                logger.info("-> [T日 盘前校准] ...")
                before_fix_service = BeforeFixService(execution_date=self.current_date)
                before_fix_service.run()
              
                dividend_events = CorporateAction.objects.filter(
                    ex_dividend_date=self.current_date, event_type=CorporateAction.EventType.DIVIDEND
                )
                # 按股票代码分组，提高效率
                events_by_stock = {}
                for event in dividend_events:
                    events_by_stock.setdefault(event.stock_code, []).append(event)

                if events_by_stock:
                    # 获取所有可能受影响的持仓
                    open_positions_for_dividend = Position.objects.filter(
                        stock_code_id__in=events_by_stock.keys(),
                        status=Position.StatusChoices.OPEN
                    )
                  
                    for pos in open_positions_for_dividend:
                        # 找到该股票对应的所有分红事件（通常只有一个）
                        stock_events = events_by_stock.get(pos.stock_code_id, [])
                        for event in stock_events:
                            dividend_amount = event.dividend_per_share * pos.quantity
                            self.cash_balance += dividend_amount
                            logger.info(f"除息事件: 持仓ID {pos.position_id} ({pos.stock_code_id}) 获得分红 {dividend_amount:.2f}，现金余额更新为 {self.cash_balance:.2f}")



                logger.info("-> [T日 开盘决策与买入] ...")
                decision_order_service = DecisionOrderService(handler=handler, execution_date=self.current_date)
                decision_order_service.adjust_trading_plan_daily()
              
                while True:
                    open_positions_count = Position.objects.filter(status=Position.StatusChoices.OPEN).count()
                    max_pos = int(StrategyParameters.objects.get(param_name='MAX_POSITIONS').param_value)
                    if open_positions_count >= max_pos:
                        break
                  
                    self.last_buy_trade_id = None
                    decision_order_service.execute_orders()
                  
                    if self.last_buy_trade_id:
                        decision_order_service.calculate_stop_profit_loss(self.last_buy_trade_id)
                    else:
                        break

                # 关键修复：在循环内实例化 MonitorExitService 并传入日期
                monitor_exit_service = MonitorExitService(handler=handler, execution_date=self.current_date)

                logger.info("-> [T日 盘中监控] 模拟价格跌至最低点...")
                handler.current_price_node = 'LOW'
                monitor_exit_service.monitor_and_exit_positions()

                logger.info("-> [T日 盘中监控] 模拟价格涨至最高点...")
                handler.current_price_node = 'HIGH'
                monitor_exit_service.monitor_and_exit_positions()

                self._calculate_daily_portfolio_value()

            logger.info("--- 3. 回测循环结束 ---")
            return self._calculate_performance_metrics()
      
        finally:
            # 确保无论成功还是失败，都清理环境
            self._cleanup_environment()

####文件结束####

####trade_manager\service\simulate_trade_handler.py####
# trade_manager/service/simulate_trade_handler.py

import logging
from datetime import time
from decimal import Decimal, ROUND_HALF_UP

from django.db import transaction
from django.utils import timezone

from .trade_handler import ITradeHandler
from common.models import Position, TradeLog, DailyQuotes

from typing import TYPE_CHECKING, Literal
if TYPE_CHECKING:
    from .simulate_trade import SimulateTradeService

logger = logging.getLogger(__name__)

class SimulateTradeHandler(ITradeHandler):
    """
    模拟交易处理器 (SimulateTradeHandler)。
    """

    def __init__(self, service: 'SimulateTradeService'):
        self.service = service
        self.current_price_node: Literal['OPEN', 'LOW', 'HIGH', 'CLOSE'] = 'CLOSE'

    def get_opening_price(self, stock_code: str) -> Decimal:
        try:
            quote = DailyQuotes.objects.get(
                stock_code_id=stock_code,
                trade_date=self.service.current_date
            )
            return quote.open
        except DailyQuotes.DoesNotExist:
            logger.warning(f"[回测] 无法在 {self.service.current_date} 找到 {stock_code} 的行情数据，返回0。")
            return Decimal('0.00')

    def get_realtime_price(self, stock_code: str) -> Decimal | None:
        try:
            quote = DailyQuotes.objects.get(
                stock_code_id=stock_code,
                trade_date=self.service.current_date
            )
            if self.current_price_node == 'LOW':
                return quote.low
            elif self.current_price_node == 'HIGH':
                return quote.high
            else:
                logger.warning(f"[回测] 在非法的价格节点 {self.current_price_node} 调用了 get_realtime_price。")
                return quote.close
        except DailyQuotes.DoesNotExist:
            logger.warning(f"[回测] 无法在 {self.service.current_date} 找到 {stock_code} 的行情数据，返回 None。")
            return None

    def get_available_balance(self) -> Decimal:
        return self.service.cash_balance

    @transaction.atomic
    def place_buy_order(self, stock_code: str, price: Decimal, quantity: int) -> None:
        amount = price * quantity
        commission = max(amount * self.service.COMMISSION_RATE, self.service.MIN_COMMISSION)
        total_cost = amount + commission

        if self.service.cash_balance < total_cost:
            msg = f"[回测] 资金不足！尝试买入 {stock_code} 需 {total_cost:.2f}，但现金仅剩 {self.service.cash_balance:.2f}。"
            logger.error(msg)
            raise ValueError(msg)

        self.service.cash_balance -= total_cost
        logger.info(f"[回测] 买入 {stock_code} {quantity}股 @{price:.2f}, "
                    f"花费: {amount:.2f}, 佣金: {commission:.2f}, "
                    f"现金余额: {self.service.cash_balance:.2f}")

        # 细节优化：使用更真实的开盘时间
        entry_time = time(9, 30, 1)
        entry_datetime = timezone.make_aware(
            timezone.datetime.combine(self.service.current_date, entry_time)
        )

        new_position = Position.objects.create(
            stock_code=stock_code,
            entry_datetime=entry_datetime,
            entry_price=price,
            quantity=quantity,
            current_stop_loss=Decimal('0.00'),
            current_take_profit=Decimal('0.00'),
            status=Position.StatusChoices.OPEN
        )

        trade_log = TradeLog.objects.create(
            position=new_position,
            stock_code=stock_code,
            trade_datetime=entry_datetime,
            trade_type=TradeLog.TradeTypeChoices.BUY,
            order_type=TradeLog.OrderTypeChoices.LIMIT,
            price=price,
            quantity=quantity,
            commission=commission,
            stamp_duty=Decimal('0.00'),
            reason=TradeLog.ReasonChoices.ENTRY,
            status=TradeLog.StatusChoices.FILLED
        )
      
        self.service.last_buy_trade_id = trade_log.trade_id

    @transaction.atomic
    def sell_stock_by_market_price(self, position: Position, reason: str) -> None:
        if reason == TradeLog.ReasonChoices.STOP_LOSS:
            trigger_price = position.current_stop_loss
        elif reason == TradeLog.ReasonChoices.TAKE_PROFIT:
            trigger_price = position.current_take_profit
        else:
            trigger_price = self.get_opening_price(position.stock_code_id)

        sell_price = trigger_price * (Decimal('1.0') - self.service.SELL_SLIPPAGE_RATE)
        sell_price = sell_price.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)

        amount = sell_price * position.quantity
        commission = max(amount * self.service.COMMISSION_RATE, self.service.MIN_COMMISSION)
        stamp_duty = amount * self.service.STAMP_DUTY_RATE
        net_income = amount - commission - stamp_duty

        self.service.cash_balance += net_income
        logger.info(f"[回测] 卖出 {position.stock_code_id} {position.quantity}股 @{sell_price:.2f} (触发价: {trigger_price:.2f}), "
                    f"收入: {amount:.2f}, 佣金: {commission:.2f}, 印花税: {stamp_duty:.2f}, "
                    f"现金余额: {self.service.cash_balance:.2f}")

        position.status = Position.StatusChoices.CLOSED
        position.save()

        # 细节优化：使用更真实的卖出时间，例如下午2:57
        sell_time = time(14, 57, 0)
        sell_datetime = timezone.make_aware(
            timezone.datetime.combine(self.service.current_date, sell_time)
        )

        TradeLog.objects.create(
            position=position,
            stock_code_id=position.stock_code_id,
            trade_datetime=sell_datetime,
            trade_type=TradeLog.TradeTypeChoices.SELL,
            order_type=TradeLog.OrderTypeChoices.MARKET,
            price=sell_price,
            quantity=position.quantity,
            commission=commission,
            stamp_duty=stamp_duty,
            reason=reason,
            status=TradeLog.StatusChoices.FILLED
        )

####文件结束####

####trade_manager\service\trade_handler.py####
# trade_manager/service/trade_handler.py

from abc import ABC, abstractmethod
from decimal import Decimal
from django.db import transaction
from django.utils import timezone
# 为了类型提示，我们可以从 common.models 导入 Position 和 TradeLog
# 注意：为了避免循环导入，通常在实现类中进行实际导入，这里仅为类型提示
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from common.models import Position, TradeLog



class ITradeHandler(ABC):
    """
    交易处理器抽象基类 (Abstract Base Class)。

    该接口定义了开盘决策与下单模块所需的所有外部交互行为。
    通过依赖此抽象接口而非具体实现，`DecisionOrderService` 可以与不同的
    交易环境（如真实交易接口、回测引擎）解耦。

    - 对于真实交易，实现类将通过API与券商服务器交互。
    - 对于回测，实现类将模拟这些交互，例如从历史数据中读取开盘价、
      模拟订单成交、并管理一个虚拟账户的余额。
    """

    @abstractmethod
    def get_opening_price(self, stock_code: str) -> Decimal:
        """
        获取指定股票在执行日的实际开盘价。

        :param stock_code: 股票代码，格式与 tb_stock_info 表一致 (如 'sh.600000')。
        :return: 当日的开盘价。如果无法获取（例如停牌），应引发异常或返回一个可识别的错误值（如Decimal('0.00')）。
        """
        pass

    @abstractmethod
    def place_buy_order(self, stock_code: str, price: Decimal, quantity: int) -> None:
        """
        提交一个买入订单。

        此方法的实现者负责处理与交易系统的所有交互。根据需求，此方法
        在执行时，需要完成以下数据库操作：
        1. 在 `tb_positions` 表中插入一条新的持仓记录，其中所有非空字段
           （如 current_stop_loss, current_take_profit）可使用哨兵值（如-1）填充，
           等待后续的止盈止损计算任务来更新。
        2. 在 `tb_trade_log` 表中插入一条对应的交易记录，初始状态应为
           'pending'。

        :param stock_code: 股票代码。
        :param price: 预期的买入限价。
        :param quantity: 计划买入的股数（必须是100的整数倍）。
        :return: 无返回值。
        """
        pass

    @abstractmethod
    def get_available_balance(self) -> Decimal:
        """
        查询当前账户的可用资金余额。

        :return: 可用于交易的现金余额。
        """
        pass

  
    @abstractmethod
    def get_realtime_price(self, stock_code: str) -> Decimal | None:
        """
        获取一只股票的实时价格。
 
        :param stock_code: 股票代码，格式如 'sh.600000'。
        :return: 该股票此时此刻的市场价 (Decimal类型)。如果获取失败（如网络问题、股票停牌），
                 应返回 None，以便调用方进行错误处理。
        """
        pass
 
    @abstractmethod
    def sell_stock_by_market_price(self, position: 'Position', reason: str) -> None:
        """
        以市价单全量卖出指定的持仓。
 
        此方法的具体实现需要完成一个原子性的操作流程：
        1. 调用交易API，以市价单卖出 `position.quantity` 数量的 `position.stock_code`。
        2. **在API调用成功返回成交回报后**，执行以下数据库操作：
           a. **更新持仓表 (tb_positions)**: 将传入的 `position` 对象的状态更新为 'closed'。
              `position.status = Position.StatusChoices.CLOSED`
              `position.save()`
           b. **插入交易记录 (tb_trade_log)**: 创建一条新的卖出记录。
              - `position`: 关联到此持仓。
              - `stock_code`: 股票代码。
              - `trade_datetime`: 交易的实际成交时间。
              - `trade_type`: 'sell'。
              - `order_type`: 'market'。
              - `quantity`: 实际成交数量。
              - `price`: 实际的成交均价。从成交回报中获取。如果无法立即获取，
                                            则使用 -1 作为占位符，等待后续任务回补。
              - `commission`, `stamp_duty`: 从成交回报中获取。如果无法立即获取，
                                            则使用 -1 作为占位符，等待后续任务回补。
              - `reason`: 使用传入的 `reason` 参数 ('take_profit' 或 'stop_loss')。
              - `status`: 'filled' (已成交)。
        3. 整个数据库更新过程应该被包裹在一个事务中 (`transaction.atomic`)，确保数据一致性。
 
        :param position: 要卖出的持仓对象 (common.models.positions.Position)。
                         该对象包含了持仓ID、股票代码、持仓数量等所有必要信息。
        :param reason: 卖出原因的字符串，如 'take_profit' 或 'stop_loss'。
                       这个值将用于填充交易记录表的 `reason` 字段。
        :return: 无返回值。如果执行失败（如API调用失败、股票跌停无法卖出），
                 应在方法内部处理异常（如记录日志），并向上层调用者（MonitorExitService）
                 抛出异常或通过其他方式通知失败，以便上层决定是否重试。
        """
        pass
####文件结束####

因子值配置为：
param_name	param_value	group_name	description
w_trend	0.4	WEIGHTS	趋势维度权重
w_momentum	0.4	WEIGHTS	动能维度权重
w_quality	0.2	WEIGHTS	质量/风控维度权重
k1	0.4	TREND_FACTORS	x1: MA20斜率权重
k2	0.3	TREND_FACTORS	x2: 均线排列权重
k3	0.3	TREND_FACTORS	x3: ADX趋势强度权重
k4	0.4	MOMENTUM_FACTORS	x4: ROC10权重
k5	0.3	MOMENTUM_FACTORS	x5: 成交量突破权重
k6	0.3	MOMENTUM_FACTORS	x6: 新高动能权重
k7	0.5	QUALITY_FACTORS	x7: 波动率权重
k8	0.5	QUALITY_FACTORS	x8: 流动性权重
k_drop	0.3	PLAN_PARAMS	MIOP低开容忍系数
k_gap	0.5	PLAN_PARAMS	MAOP高开容忍系数
lookback_new_stock	60	LOOKBACKS	次新股定义天数
lookback_liquidity	20	LOOKBACKS	流动性计算周期
lookback_ma_slow	60	LOOKBACKS	慢速均线周期(如成交量)
lookback_ma_fast	5	LOOKBACKS	快速均线周期(如成交量)
lookback_ma20	20	INDICATORS	MA20计算周期
lookback_ma10	10	LOOKBACKS	MA10周期
lookback_ma5	5	LOOKBACKS	MA5周期
lookback_roc	10	LOOKBACKS	ROC计算周期
lookback_new_high	60	LOOKBACKS	新高动能计算周期
lookback_volatility	20	LOOKBACKS	波动率计算周期
lookback_atr	14	INDICATORS	ATR计算周期
lookback_adx	14	INDICATORS	ADX计算周期
param_min_liquidity	100000000	FILTERS	最低日均成交额(元)
param_top_n	30	SELECTION	最终选取股票数量
param_adx_threshold	25	THRESHOLDS	ADX趋势形成阈值
MAX_POSITIONS	3	POSITION_MGMT	最大可具备的总仓位数
MAX_CAPITAL_PER_POSITION	20000	POSITION_MGMT	每仓最大投入资金数(元)
k_slip	0.002	ORDER_EXEC	下单滑点系数, 用于计算限价单价格
Base_Target	0.07	TAKE_PROFIT	基础止盈目标百分比
k_g1	1.5	TAKE_PROFIT	ATR溢价乘数, 用于动态调整止盈目标
Max_Target	0.2	TAKE_PROFIT	最大止盈目标百分比上限
k_h1	2	STOP_LOSS	趋势市ATR止损乘数 (盘中动态使用)
k_h2	3	STOP_LOSS	震荡市ATR止损乘数 (用于计算初始止损)
Max_Loss_Percent	0.08	STOP_LOSS	最大回撤容忍度(绝对亏损百分比上限)
dynamic_w_m1	0.3	M_WEIGHTS	M(t)指标权重: M1-创60日新高占比
dynamic_w_m2	0.3	M_WEIGHTS	M(t)指标权重: M2-MA60之上占比
dynamic_w_m3	0.25	M_WEIGHTS	M(t)指标权重: M3-60日回报率中位数
dynamic_w_m4	0.15	M_WEIGHTS	M(t)指标权重: M4-20日平均波动率
dynamic_m_lookback	750	M_PARAMS	M(t)历史回看周期(约3年)
dynamic_c_MT	1	N_ATTRACTION	吸引力函数强度系数: 趋势动能
dynamic_c_BO	1	N_ATTRACTION	吸引力函数强度系数: 强势突破
dynamic_c_QD	1	N_ATTRACTION	吸引力函数强度系数: 质量防御
dynamic_c_MR	1	N_ATTRACTION	吸引力函数强度系数: 均值回归
dynamic_sigma_MR	0.3	N_PARAMS	均值回归策略适用范围宽度
dynamic_tau	0.5	N_PARAMS	Softmax温度系数(控制切换灵敏度)
dynamic_k_MT1	0.4	K_WEIGHTS_MT	趋势动能-MA20斜率权重
dynamic_k_MT2	0.3	K_WEIGHTS_MT	趋势动能-均线排列权重
dynamic_k_MT3	0.3	K_WEIGHTS_MT	趋势动能-ADX确认权重
dynamic_k_BO1	0.4	K_WEIGHTS_BO	强势突破-突破强度权重
dynamic_k_BO2	0.4	K_WEIGHTS_BO	强势突破-成交量激增权重
dynamic_k_BO3	0.2	K_WEIGHTS_BO	强势突破-动能加速度权重
dynamic_k_MR1	0.4	K_WEIGHTS_MR	均值回归-RSI超卖权重
dynamic_k_MR2	0.3	K_WEIGHTS_MR	均值回归-负向偏离度权重
dynamic_k_MR3	0.3	K_WEIGHTS_MR	均值回归-布林下轨支撑权重
dynamic_k_QD1	0.4	K_WEIGHTS_QD	质量防御-低波动率权重
dynamic_k_QD2	0.3	K_WEIGHTS_QD	质量防御-最大回撤权重
dynamic_k_QD3	0.3	K_WEIGHTS_QD	质量防御-下行风险权重
dynamic_k_drop	0.3	PLAN_PARAMS	MIOP低开容忍系数
dynamic_k_gap	0.5	PLAN_PARAMS	MAOP高开容忍系数
dynamic_lookback_new_stock	60	FILTERS	次新股定义天数(自然日)
dynamic_min_liquidity	100000000	FILTERS	最低日均成交额(元)
dynamic_top_n	30	SELECTION	最终选取股票数量


回测日志为：
INFO 2025-08-08 13:16:53,097 apps 58528 45720 检测到 Django 管理或重载主进程，跳过调度器初始化。
INFO 2025-08-08 13:16:54,063 apps 67176 60588 检测到 Django 应用工作进程，准备初始化调度器...
INFO 2025-08-08 13:16:56,522 config_loader 67176 60588 ConfigLoader: config.json 加载成功。
INFO 2025-08-08 13:16:56,523 real_trade_handler 67176 60588 ConnectionManager 已初始化。
INFO 2025-08-08 13:16:56,523 scheduler_service 67176 60588 正在更新交易日历...
INFO 2025-08-08 13:16:56,874 scheduler_service 67176 60588 交易日历更新成功，共获取 8555 个交易日。
INFO 2025-08-08 13:16:56,882 scheduler_service 67176 60588 调度器状态为 'off'，不启动。
INFO 2025-08-08 13:16:56,927 autoreload 67176 60588 Watching for file changes with StatReloader
INFO 2025-08-08 13:17:07,437 simulate_trade 67176 66768 --- 1. 准备回测环境 (内存模式) ---
INFO 2025-08-08 13:17:07,438 simulate_trade 67176 66768 已将 'default' 数据库连接重定向到 :memory:
INFO 2025-08-08 13:17:07,439 simulate_trade 67176 66768 开始将数据从 D:\project\autoTrade\autoTrade\mainDB.sqlite3 加载到内存 (使用 Backup API)...
INFO 2025-08-08 13:17:09,407 simulate_trade 67176 66768 数据成功加载到内存数据库，耗时: 1.97 秒。
INFO 2025-08-08 13:17:09,409 simulate_trade 67176 66768 已清空表: tb_positions
INFO 2025-08-08 13:17:09,409 simulate_trade 67176 66768 已清空表: tb_trade_log
INFO 2025-08-08 13:17:09,410 simulate_trade 67176 66768 已清空表: tb_system_log
INFO 2025-08-08 13:17:09,412 simulate_trade 67176 66768 初始资金已设定为: 60000.00
INFO 2025-08-08 13:17:10,236 simulate_trade 67176 66768 --- 2. 开始日度回测循环 (143天) ---
INFO 2025-08-08 13:17:10,238 simulate_trade 67176 66768 
==================== 模拟日: 2025-01-02 (1/143) ====================
INFO 2025-08-08 13:17:10,238 simulate_trade 67176 66768 -> [T日 盘前校准] ...
INFO 2025-08-08 13:17:10,986 before_fix_service 67176 66768 2025-01-02 的前一个交易日 (T-1) 是: 2024-12-31
INFO 2025-08-08 13:17:10,990 simulate_trade 67176 66768 -> [T日 开盘决策与买入] ...
WARNING 2025-08-08 13:17:10,994 decision_order_service 67176 66768 在 2025-01-02 没有找到待执行的交易预案。
INFO 2025-08-08 13:17:10,997 decision_order_service 67176 66768 开始执行 2025-01-02 的下单流程...
INFO 2025-08-08 13:17:10,998 decision_order_service 67176 66768 在 2025-01-02 无符合条件的买入标的。
INFO 2025-08-08 13:17:10,999 simulate_trade 67176 66768 -> [T日 盘中监控] 模拟价格跌至最低点...
INFO 2025-08-08 13:17:11,001 simulate_trade 67176 66768 -> [T日 盘中监控] 模拟价格涨至最高点...
INFO 2025-08-08 13:17:11,003 simulate_trade 67176 66768 --- 日终结算 (2025-01-02) ---
INFO 2025-08-08 13:17:11,004 simulate_trade 67176 66768 现金: 60000.00, 持仓市值: 0.00, 总资产: 60000.00
INFO 2025-08-08 13:17:11,005 simulate_trade 67176 66768 
==================== 模拟日: 2025-01-03 (2/143) ====================
INFO 2025-08-08 13:17:11,005 simulate_trade 67176 66768 -> [T-1 选股] 基于 2025-01-02 的数据...
INFO 2025-08-08 13:17:11,056 selection_service 67176 66768 剔除科创版和ST和次新股后，剩余 4341 只股票。
INFO 2025-08-08 13:17:11,826 selection_service 67176 66768 剔除低流动性股后，最终剩余 2952 只股票进入精选池。
INFO 2025-08-08 13:17:13,664 selection_service 67176 66768 M(t) 计算完成，值为: -0.4720，并已存入缓存。
WARNING 2025-08-08 13:17:50,878 selection_service 67176 66768 问题可能出在以下因子中，它们的NaN数量较多: 
dynamic_NEG_DEV         59
dynamic_MA20_SLOPE      34
dynamic_BOLL_LB         21
dynamic_MOM_ACCEL       17
dynamic_BREAKOUT_PWR     6
dynamic_VOLUME_SURGE     6
dtype: int64
INFO 2025-08-08 13:17:56,574 selection_service 67176 66768 动态选股流程成功完成。M(t)=-0.4720, 生成 30 条交易预案。
INFO 2025-08-08 13:17:56,575 simulate_trade 67176 66768 -> [T日 盘前校准] ...
INFO 2025-08-08 13:17:57,355 before_fix_service 67176 66768 2025-01-03 的前一个交易日 (T-1) 是: 2025-01-02
INFO 2025-08-08 13:17:57,357 before_fix_service 67176 66768 T日共有 1 只股票发生股权事件。
INFO 2025-08-08 13:17:57,358 before_fix_service 67176 66768 股票 sz.002810: T-1收盘价=12.68, 校准后价格=12.53, 调整比率=0.988170
INFO 2025-08-08 13:17:57,359 before_fix_service 67176 66768 找到待执行的交易预案，预案日期为: 2025-01-03
INFO 2025-08-08 13:17:58,129 before_fix_service 67176 66768 近期无配股事件，无需特殊处理。
INFO 2025-08-08 13:17:58,130 before_fix_service 67176 66768 [盘前校准与预案修正] 任务成功完成。共处理 1 只股票的常规校准。
INFO 2025-08-08 13:17:58,132 simulate_trade 67176 66768 -> [T日 开盘决策与买入] ...
INFO 2025-08-08 13:17:58,165 decision_order_service 67176 66768 所有待执行预案均符合开盘价条件。
INFO 2025-08-08 13:17:58,166 decision_order_service 67176 66768 开始执行 2025-01-03 的下单流程...
INFO 2025-08-08 13:17:58,170 decision_order_service 67176 66768 确定唯一买入标的: 兴齐眼药(sz.300573) (Rank:1)。 计划以限价 68.78 买入 200 股。
INFO 2025-08-08 13:17:58,171 simulate_trade_handler 67176 66768 [回测] 买入 兴齐眼药(sz.300573) 200股 @68.78, 花费: 13756.00, 佣金: 5.00, 现金余额: 46239.00
INFO 2025-08-08 13:17:58,174 decision_order_service 67176 66768 开始为 trade_id=1 计算止盈止损区间...
INFO 2025-08-08 13:17:58,188 decision_order_service 67176 66768 [sz.300573] 止损线比较: 趋势位=60.46, 技术位=78.32, 底线=63.28
INFO 2025-08-08 13:17:58,189 decision_order_service 67176 66768 成功计算并更新 Position ID 1 (sz.300573) 的风控价格: 购入价=68.78, 止盈价=77.75, 止盈率=113.05%, 止损价=78.32, 止损率=113.87%
INFO 2025-08-08 13:17:58,192 decision_order_service 67176 66768 开始执行 2025-01-03 的下单流程...
INFO 2025-08-08 13:17:58,195 decision_order_service 67176 66768 确定唯一买入标的: 坤彩科技(sh.603826) (Rank:2)。 计划以限价 19.29 买入 1000 股。
INFO 2025-08-08 13:17:58,197 simulate_trade_handler 67176 66768 [回测] 买入 坤彩科技(sh.603826) 1000股 @19.29, 花费: 19290.00, 佣金: 5.51, 现金余额: 26943.49
INFO 2025-08-08 13:17:58,199 decision_order_service 67176 66768 开始为 trade_id=2 计算止盈止损区间...
INFO 2025-08-08 13:17:58,209 decision_order_service 67176 66768 [sh.603826] 止损线比较: 趋势位=17.82, 技术位=21.67, 底线=17.75
INFO 2025-08-08 13:17:58,211 decision_order_service 67176 66768 成功计算并更新 Position ID 2 (sh.603826) 的风控价格: 购入价=19.29, 止盈价=21.74, 止盈率=112.70%, 止损价=21.67, 止损率=112.34%
INFO 2025-08-08 13:17:58,213 decision_order_service 67176 66768 开始执行 2025-01-03 的下单流程...
INFO 2025-08-08 13:17:58,217 decision_order_service 67176 66768 确定唯一买入标的: 贝泰妮(sz.300957) (Rank:3)。 计划以限价 42.24 买入 400 股。
INFO 2025-08-08 13:17:58,218 simulate_trade_handler 67176 66768 [回测] 买入 贝泰妮(sz.300957) 400股 @42.24, 花费: 16896.00, 佣金: 5.00, 现金余额: 10042.49
INFO 2025-08-08 13:17:58,220 decision_order_service 67176 66768 开始为 trade_id=3 计算止盈止损区间...
INFO 2025-08-08 13:17:58,231 decision_order_service 67176 66768 [sz.300957] 止损线比较: 趋势位=37.82, 技术位=46.69, 底线=38.86
INFO 2025-08-08 13:17:58,233 decision_order_service 67176 66768 成功计算并更新 Position ID 3 (sz.300957) 的风控价格: 购入价=42.24, 止盈价=47.41, 止盈率=112.23%, 止损价=46.69, 止损率=110.54%
INFO 2025-08-08 13:17:58,235 simulate_trade 67176 66768 -> [T日 盘中监控] 模拟价格跌至最低点...
INFO 2025-08-08 13:17:58,236 simulate_trade 67176 66768 -> [T日 盘中监控] 模拟价格涨至最高点...
INFO 2025-08-08 13:17:58,240 simulate_trade 67176 66768 --- 日终结算 (2025-01-03) ---
INFO 2025-08-08 13:17:58,241 simulate_trade 67176 66768 现金: 10042.49, 持仓市值: 49906.00, 总资产: 59948.49
INFO 2025-08-08 13:17:58,242 simulate_trade 67176 66768 
==================== 模拟日: 2025-01-06 (3/143) ====================
INFO 2025-08-08 13:17:58,242 simulate_trade 67176 66768 -> [T-1 选股] 基于 2025-01-03 的数据...
INFO 2025-08-08 13:17:58,275 selection_service 67176 66768 剔除科创版和ST和次新股后，剩余 4341 只股票。
INFO 2025-08-08 13:17:59,083 selection_service 67176 66768 剔除低流动性股后，最终剩余 2942 只股票进入精选池。
INFO 2025-08-08 13:18:00,866 selection_service 67176 66768 M(t) 计算完成，值为: -0.5297，并已存入缓存。
WARNING 2025-08-08 13:18:37,825 selection_service 67176 66768 问题可能出在以下因子中，它们的NaN数量较多: 
dynamic_NEG_DEV         58
dynamic_MA20_SLOPE      32
dynamic_BOLL_LB         21
dynamic_MOM_ACCEL       16
dynamic_BREAKOUT_PWR     6
dynamic_VOLUME_SURGE     6
dtype: int64
INFO 2025-08-08 13:18:43,770 selection_service 67176 66768 动态选股流程成功完成。M(t)=-0.5297, 生成 30 条交易预案。
INFO 2025-08-08 13:18:43,771 simulate_trade 67176 66768 -> [T日 盘前校准] ...
INFO 2025-08-08 13:18:44,507 before_fix_service 67176 66768 2025-01-06 的前一个交易日 (T-1) 是: 2025-01-03
INFO 2025-08-08 13:18:44,509 before_fix_service 67176 66768 T日共有 2 只股票发生股权事件。
INFO 2025-08-08 13:18:44,511 before_fix_service 67176 66768 股票 sh.688603: T-1收盘价=114.05, 校准后价格=78.66, 调整比率=0.689655
INFO 2025-08-08 13:18:44,511 before_fix_service 67176 66768 股票 sz.000591: T-1收盘价=4.60, 校准后价格=4.54, 调整比率=0.987630
INFO 2025-08-08 13:18:44,513 before_fix_service 67176 66768 找到待执行的交易预案，预案日期为: 2025-01-04
INFO 2025-08-08 13:18:45,270 before_fix_service 67176 66768 近期无配股事件，无需特殊处理。
INFO 2025-08-08 13:18:45,271 before_fix_service 67176 66768 [盘前校准与预案修正] 任务成功完成。共处理 2 只股票的常规校准。
INFO 2025-08-08 13:18:45,273 simulate_trade 67176 66768 -> [T日 开盘决策与买入] ...
WARNING 2025-08-08 13:18:45,275 decision_order_service 67176 66768 在 2025-01-06 没有找到待执行的交易预案。
INFO 2025-08-08 13:18:45,277 simulate_trade 67176 66768 -> [T日 盘中监控] 模拟价格跌至最低点...
INFO 2025-08-08 13:18:45,280 monitor_exit_service 67176 66768 触发止损条件! 股票: 兴齐眼药(sz.300573), 当前价: 66.81 <= 止损价: 78.32。准备执行卖出。
INFO 2025-08-08 13:18:45,281 simulate_trade_handler 67176 66768 [回测] 卖出 sz.300573 200股 @78.16 (触发价: 78.32), 收入: 15632.00, 佣金: 5.00, 印花税: 15.63, 现金余额: 25653.86
INFO 2025-08-08 13:18:45,284 monitor_exit_service 67176 66768 触发止损条件! 股票: 坤彩科技(sh.603826), 当前价: 19.31 <= 止损价: 21.67。准备执行卖出。
INFO 2025-08-08 13:18:45,285 simulate_trade_handler 67176 66768 [回测] 卖出 sh.603826 1000股 @21.63 (触发价: 21.67), 收入: 21630.00, 佣金: 6.17, 印花税: 21.63, 现金余额: 47256.06
INFO 2025-08-08 13:18:45,288 monitor_exit_service 67176 66768 触发止损条件! 股票: 贝泰妮(sz.300957), 当前价: 40.60 <= 止损价: 46.69。准备执行卖出。
INFO 2025-08-08 13:18:45,289 simulate_trade_handler 67176 66768 [回测] 卖出 sz.300957 400股 @46.60 (触发价: 46.69), 收入: 18640.00, 佣金: 5.32, 印花税: 18.64, 现金余额: 65872.10
INFO 2025-08-08 13:18:45,291 simulate_trade 67176 66768 -> [T日 盘中监控] 模拟价格涨至最高点...
INFO 2025-08-08 13:18:45,293 simulate_trade 67176 66768 --- 日终结算 (2025-01-06) ---
INFO 2025-08-08 13:18:45,294 simulate_trade 67176 66768 现金: 65872.10, 持仓市值: 0.00, 总资产: 65872.10
INFO 2025-08-08 13:18:45,294 simulate_trade 67176 66768 
==================== 模拟日: 2025-01-07 (4/143) ====================
INFO 2025-08-08 13:18:45,295 simulate_trade 67176 66768 -> [T-1 选股] 基于 2025-01-06 的数据...
INFO 2025-08-08 13:18:45,324 selection_service 67176 66768 剔除科创版和ST和次新股后，剩余 4341 只股票。
INFO 2025-08-08 13:18:46,068 selection_service 67176 66768 剔除低流动性股后，最终剩余 2884 只股票进入精选池。
INFO 2025-08-08 13:18:47,914 selection_service 67176 66768 M(t) 计算完成，值为: -0.5462，并已存入缓存。
WARNING 2025-08-08 13:19:24,001 selection_service 67176 66768 问题可能出在以下因子中，它们的NaN数量较多: 
dynamic_NEG_DEV         57
dynamic_MA20_SLOPE      33
dynamic_BOLL_LB         21
dynamic_MOM_ACCEL       18
dynamic_BREAKOUT_PWR     7
dynamic_VOLUME_SURGE     7
dtype: int64
INFO 2025-08-08 13:19:29,755 selection_service 67176 66768 动态选股流程成功完成。M(t)=-0.5462, 生成 30 条交易预案。
INFO 2025-08-08 13:19:29,756 simulate_trade 67176 66768 -> [T日 盘前校准] ...
INFO 2025-08-08 13:19:30,532 before_fix_service 67176 66768 2025-01-07 的前一个交易日 (T-1) 是: 2025-01-06
INFO 2025-08-08 13:19:30,535 before_fix_service 67176 66768 T日共有 6 只股票发生股权事件。
INFO 2025-08-08 13:19:30,537 before_fix_service 67176 66768 股票 sh.601398: T-1收盘价=6.75, 校准后价格=6.61, 调整比率=0.978756
INFO 2025-08-08 13:19:30,537 before_fix_service 67176 66768 股票 sh.688498: T-1收盘价=127.46, 校准后价格=127.36, 调整比率=0.999215
INFO 2025-08-08 13:19:30,538 before_fix_service 67176 66768 股票 sz.002270: T-1收盘价=15.98, 校准后价格=15.92, 调整比率=0.996496
INFO 2025-08-08 13:19:30,539 before_fix_service 67176 66768 股票 sz.002817: T-1收盘价=6.16, 校准后价格=6.13, 调整比率=0.995617
INFO 2025-08-08 13:19:30,539 before_fix_service 67176 66768 股票 sz.002968: T-1收盘价=8.77, 校准后价格=8.67, 调整比率=0.988597
INFO 2025-08-08 13:19:30,540 before_fix_service 67176 66768 股票 sz.002998: T-1收盘价=6.02, 校准后价格=5.87, 调整比率=0.975083
INFO 2025-08-08 13:19:30,541 before_fix_service 67176 66768 找到待执行的交易预案，预案日期为: 2025-01-07
INFO 2025-08-08 13:19:31,301 before_fix_service 67176 66768 近期无配股事件，无需特殊处理。
INFO 2025-08-08 13:19:31,301 before_fix_service 67176 66768 [盘前校准与预案修正] 任务成功完成。共处理 6 只股票的常规校准。
INFO 2025-08-08 13:19:31,303 simulate_trade 67176 66768 -> [T日 开盘决策与买入] ...
INFO 2025-08-08 13:19:31,334 decision_order_service 67176 66768 所有待执行预案均符合开盘价条件。
INFO 2025-08-08 13:19:31,335 decision_order_service 67176 66768 开始执行 2025-01-07 的下单流程...
INFO 2025-08-08 13:19:31,339 decision_order_service 67176 66768 确定唯一买入标的: 兴齐眼药(sz.300573) (Rank:1)。 计划以限价 67.98 买入 200 股。
INFO 2025-08-08 13:19:31,340 simulate_trade_handler 67176 66768 [回测] 买入 兴齐眼药(sz.300573) 200股 @67.98, 花费: 13596.00, 佣金: 5.00, 现金余额: 52271.10
INFO 2025-08-08 13:19:31,342 decision_order_service 67176 66768 开始为 trade_id=7 计算止盈止损区间...
INFO 2025-08-08 13:19:31,353 decision_order_service 67176 66768 [sz.300573] 止损线比较: 趋势位=60.03, 技术位=76.63, 底线=62.54
INFO 2025-08-08 13:19:31,354 decision_order_service 67176 66768 成功计算并更新 Position ID 4 (sz.300573) 的风控价格: 购入价=67.98, 止盈价=76.71, 止盈率=112.84%, 止损价=76.63, 止损率=112.72%
INFO 2025-08-08 13:19:31,357 decision_order_service 67176 66768 开始执行 2025-01-07 的下单流程...
INFO 2025-08-08 13:19:31,362 decision_order_service 67176 66768 确定唯一买入标的: 贝泰妮(sz.300957) (Rank:2)。 计划以限价 41.33 买入 400 股。
INFO 2025-08-08 13:19:31,364 simulate_trade_handler 67176 66768 [回测] 买入 贝泰妮(sz.300957) 400股 @41.33, 花费: 16532.00, 佣金: 5.00, 现金余额: 35734.10
INFO 2025-08-08 13:19:31,365 decision_order_service 67176 66768 开始为 trade_id=8 计算止盈止损区间...
INFO 2025-08-08 13:19:31,376 decision_order_service 67176 66768 [sz.300957] 止损线比较: 趋势位=38.45, 技术位=45.92, 底线=38.02
INFO 2025-08-08 13:19:31,377 decision_order_service 67176 66768 成功计算并更新 Position ID 5 (sz.300957) 的风控价格: 购入价=41.33, 止盈价=46.39, 止盈率=112.23%, 止损价=45.92, 止损率=111.11%
INFO 2025-08-08 13:19:31,380 decision_order_service 67176 66768 开始执行 2025-01-07 的下单流程...
INFO 2025-08-08 13:19:31,383 decision_order_service 67176 66768 确定唯一买入标的: 坤彩科技(sh.603826) (Rank:3)。 计划以限价 19.45 买入 1000 股。
INFO 2025-08-08 13:19:31,384 simulate_trade_handler 67176 66768 [回测] 买入 坤彩科技(sh.603826) 1000股 @19.45, 花费: 19450.00, 佣金: 5.55, 现金余额: 16278.55
INFO 2025-08-08 13:19:31,386 decision_order_service 67176 66768 开始为 trade_id=9 计算止盈止损区间...
INFO 2025-08-08 13:19:31,397 decision_order_service 67176 66768 [sh.603826] 止损线比较: 趋势位=17.93, 技术位=21.42, 底线=17.89
INFO 2025-08-08 13:19:31,398 decision_order_service 67176 66768 成功计算并更新 Position ID 6 (sh.603826) 的风控价格: 购入价=19.45, 止盈价=21.95, 止盈率=112.87%, 止损价=21.42, 止损率=110.13%
INFO 2025-08-08 13:19:31,401 simulate_trade 67176 66768 -> [T日 盘中监控] 模拟价格跌至最低点...
INFO 2025-08-08 13:19:31,402 simulate_trade 67176 66768 -> [T日 盘中监控] 模拟价格涨至最高点...
INFO 2025-08-08 13:19:31,406 simulate_trade 67176 66768 --- 日终结算 (2025-01-07) ---
INFO 2025-08-08 13:19:31,407 simulate_trade 67176 66768 现金: 16278.55, 持仓市值: 49476.00, 总资产: 65754.55
INFO 2025-08-08 13:19:31,408 simulate_trade 67176 66768 
==================== 模拟日: 2025-01-08 (5/143) ====================
INFO 2025-08-08 13:19:31,408 simulate_trade 67176 66768 -> [T-1 选股] 基于 2025-01-07 的数据...
INFO 2025-08-08 13:19:31,440 selection_service 67176 66768 剔除科创版和ST和次新股后，剩余 4343 只股票。
INFO 2025-08-08 13:19:32,310 selection_service 67176 66768 剔除低流动性股后，最终剩余 2843 只股票进入精选池。
INFO 2025-08-08 13:19:34,167 selection_service 67176 66768 M(t) 计算完成，值为: -0.4788，并已存入缓存。
WARNING 2025-08-08 13:20:10,971 selection_service 67176 66768 问题可能出在以下因子中，它们的NaN数量较多: 
dynamic_NEG_DEV         55
dynamic_MA20_SLOPE      33
dynamic_BOLL_LB         20
dynamic_MOM_ACCEL       17
dynamic_BREAKOUT_PWR     5
dynamic_VOLUME_SURGE     5
dtype: int64
INFO 2025-08-08 13:20:16,578 selection_service 67176 66768 动态选股流程成功完成。M(t)=-0.4788, 生成 30 条交易预案。
INFO 2025-08-08 13:20:16,580 simulate_trade 67176 66768 -> [T日 盘前校准] ...
INFO 2025-08-08 13:20:17,349 before_fix_service 67176 66768 2025-01-08 的前一个交易日 (T-1) 是: 2025-01-07
INFO 2025-08-08 13:20:17,351 before_fix_service 67176 66768 T日共有 9 只股票发生股权事件。
INFO 2025-08-08 13:20:17,354 before_fix_service 67176 66768 股票 sh.600116: T-1收盘价=6.81, 校准后价格=6.76, 调整比率=0.992658
INFO 2025-08-08 13:20:17,355 before_fix_service 67176 66768 股票 sh.601288: T-1收盘价=5.26, 校准后价格=5.14, 调整比率=0.977871
INFO 2025-08-08 13:20:17,356 before_fix_service 67176 66768 股票 sh.601658: T-1收盘价=5.59, 校准后价格=5.44, 调整比率=0.973578
INFO 2025-08-08 13:20:17,357 before_fix_service 67176 66768 股票 sh.601677: T-1收盘价=11.95, 校准后价格=11.90, 调整比率=0.995816
INFO 2025-08-08 13:20:17,357 before_fix_service 67176 66768 股票 sh.605488: T-1收盘价=19.47, 校准后价格=19.37, 调整比率=0.994864
INFO 2025-08-08 13:20:17,358 before_fix_service 67176 66768 股票 sz.000617: T-1收盘价=6.68, 校准后价格=6.62, 调整比率=0.991018
INFO 2025-08-08 13:20:17,359 before_fix_service 67176 66768 股票 sz.000680: T-1收盘价=9.70, 校准后价格=9.67, 调整比率=0.996907
INFO 2025-08-08 13:20:17,359 before_fix_service 67176 66768 股票 sz.001296: T-1收盘价=17.46, 校准后价格=17.26, 调整比率=0.988545
INFO 2025-08-08 13:20:17,360 before_fix_service 67176 66768 股票 sz.301345: T-1收盘价=65.55, 校准后价格=65.05, 调整比率=0.992372
INFO 2025-08-08 13:20:17,361 before_fix_service 67176 66768 找到待执行的交易预案，预案日期为: 2025-01-08
INFO 2025-08-08 13:20:18,118 before_fix_service 67176 66768 近期无配股事件，无需特殊处理。
INFO 2025-08-08 13:20:18,119 before_fix_service 67176 66768 [盘前校准与预案修正] 任务成功完成。共处理 9 只股票的常规校准。
INFO 2025-08-08 13:20:18,121 simulate_trade 67176 66768 -> [T日 开盘决策与买入] ...
INFO 2025-08-08 13:20:18,155 decision_order_service 67176 66768 所有待执行预案均符合开盘价条件。
INFO 2025-08-08 13:20:18,156 simulate_trade 67176 66768 -> [T日 盘中监控] 模拟价格跌至最低点...
INFO 2025-08-08 13:20:18,159 monitor_exit_service 67176 66768 触发止损条件! 股票: 兴齐眼药(sz.300573), 当前价: 65.03 <= 止损价: 76.63。准备执行卖出。
INFO 2025-08-08 13:20:18,160 simulate_trade_handler 67176 66768 [回测] 卖出 sz.300573 200股 @76.48 (触发价: 76.63), 收入: 15296.00, 佣金: 5.00, 印花税: 15.30, 现金余额: 31554.25
INFO 2025-08-08 13:20:18,163 monitor_exit_service 67176 66768 触发止损条件! 股票: 贝泰妮(sz.300957), 当前价: 40.05 <= 止损价: 45.92。准备执行卖出。
INFO 2025-08-08 13:20:18,164 simulate_trade_handler 67176 66768 [回测] 卖出 sz.300957 400股 @45.83 (触发价: 45.92), 收入: 18332.00, 佣金: 5.23, 印花税: 18.33, 现金余额: 49862.69
INFO 2025-08-08 13:20:18,167 monitor_exit_service 67176 66768 触发止损条件! 股票: 坤彩科技(sh.603826), 当前价: 18.73 <= 止损价: 21.42。准备执行卖出。
INFO 2025-08-08 13:20:18,168 simulate_trade_handler 67176 66768 [回测] 卖出 sh.603826 1000股 @21.38 (触发价: 21.42), 收入: 21380.00, 佣金: 6.10, 印花税: 21.38, 现金余额: 71215.21
INFO 2025-08-08 13:20:18,170 simulate_trade 67176 66768 -> [T日 盘中监控] 模拟价格涨至最高点...
INFO 2025-08-08 13:20:18,172 simulate_trade 67176 66768 --- 日终结算 (2025-01-08) ---
INFO 2025-08-08 13:20:18,172 simulate_trade 67176 66768 现金: 71215.21, 持仓市值: 0.00, 总资产: 71215.21
INFO 2025-08-08 13:20:18,173 simulate_trade 67176 66768 
==================== 模拟日: 2025-01-09 (6/143) ====================
INFO 2025-08-08 13:20:18,174 simulate_trade 67176 66768 -> [T-1 选股] 基于 2025-01-08 的数据...
INFO 2025-08-08 13:20:18,205 selection_service 67176 66768 剔除科创版和ST和次新股后，剩余 4343 只股票。
INFO 2025-08-08 13:20:18,977 selection_service 67176 66768 剔除低流动性股后，最终剩余 2771 只股票进入精选池。
INFO 2025-08-08 13:20:20,790 selection_service 67176 66768 M(t) 计算完成，值为: -0.4884，并已存入缓存。
WARNING 2025-08-08 13:20:55,805 selection_service 67176 66768 问题可能出在以下因子中，它们的NaN数量较多: 
dynamic_NEG_DEV         52
dynamic_MA20_SLOPE      33
dynamic_BOLL_LB         19
dynamic_MOM_ACCEL       13
dynamic_BREAKOUT_PWR     5
dynamic_VOLUME_SURGE     5
dtype: int64
INFO 2025-08-08 13:21:01,250 selection_service 67176 66768 动态选股流程成功完成。M(t)=-0.4884, 生成 30 条交易预案。
INFO 2025-08-08 13:21:01,252 simulate_trade 67176 66768 -> [T日 盘前校准] ...
INFO 2025-08-08 13:21:02,011 before_fix_service 67176 66768 2025-01-09 的前一个交易日 (T-1) 是: 2025-01-08
INFO 2025-08-08 13:21:02,013 before_fix_service 67176 66768 T日共有 4 只股票发生股权事件。
INFO 2025-08-08 13:21:02,015 before_fix_service 67176 66768 股票 sh.600727: T-1收盘价=7.20, 校准后价格=7.15, 调整比率=0.993056
INFO 2025-08-08 13:21:02,015 before_fix_service 67176 66768 股票 sh.600768: T-1收盘价=8.62, 校准后价格=8.52, 调整比率=0.988399
INFO 2025-08-08 13:21:02,016 before_fix_service 67176 66768 股票 sh.603313: T-1收盘价=6.55, 校准后价格=6.50, 调整比率=0.992366
INFO 2025-08-08 13:21:02,017 before_fix_service 67176 66768 股票 sz.300683: T-1收盘价=22.22, 校准后价格=22.09, 调整比率=0.994149
INFO 2025-08-08 13:21:02,018 before_fix_service 67176 66768 找到待执行的交易预案，预案日期为: 2025-01-09
INFO 2025-08-08 13:21:02,783 before_fix_service 67176 66768 近期无配股事件，无需特殊处理。
INFO 2025-08-08 13:21:02,784 before_fix_service 67176 66768 [盘前校准与预案修正] 任务成功完成。共处理 4 只股票的常规校准。
INFO 2025-08-08 13:21:02,786 simulate_trade 67176 66768 -> [T日 开盘决策与买入] ...
INFO 2025-08-08 13:21:02,816 decision_order_service 67176 66768 所有待执行预案均符合开盘价条件。
INFO 2025-08-08 13:21:02,818 decision_order_service 67176 66768 开始执行 2025-01-09 的下单流程...
INFO 2025-08-08 13:21:02,821 decision_order_service 67176 66768 确定唯一买入标的: 贝泰妮(sz.300957) (Rank:1)。 计划以限价 41.05 买入 400 股。
INFO 2025-08-08 13:21:02,823 simulate_trade_handler 67176 66768 [回测] 买入 贝泰妮(sz.300957) 400股 @41.05, 花费: 16420.00, 佣金: 5.00, 现金余额: 54790.21
INFO 2025-08-08 13:21:02,824 decision_order_service 67176 66768 开始为 trade_id=13 计算止盈止损区间...
INFO 2025-08-08 13:21:02,837 decision_order_service 67176 66768 [sz.300957] 止损线比较: 趋势位=38.28, 技术位=45.13, 底线=37.77
INFO 2025-08-08 13:21:02,838 decision_order_service 67176 66768 成功计算并更新 Position ID 7 (sz.300957) 的风控价格: 购入价=41.05, 止盈价=46.00, 止盈率=112.06%, 止损价=45.13, 止损率=109.94%
INFO 2025-08-08 13:21:02,842 decision_order_service 67176 66768 开始执行 2025-01-09 的下单流程...
INFO 2025-08-08 13:21:02,845 decision_order_service 67176 66768 确定唯一买入标的: 兴齐眼药(sz.300573) (Rank:2)。 计划以限价 66.46 买入 300 股。
INFO 2025-08-08 13:21:02,847 simulate_trade_handler 67176 66768 [回测] 买入 兴齐眼药(sz.300573) 300股 @66.46, 花费: 19938.00, 佣金: 5.69, 现金余额: 34846.52
INFO 2025-08-08 13:21:02,850 decision_order_service 67176 66768 开始为 trade_id=14 计算止盈止损区间...
INFO 2025-08-08 13:21:02,862 decision_order_service 67176 66768 [sz.300573] 止损线比较: 趋势位=61.21, 技术位=74.95, 底线=61.14
INFO 2025-08-08 13:21:02,863 decision_order_service 67176 66768 成功计算并更新 Position ID 8 (sz.300573) 的风控价格: 购入价=66.46, 止盈价=75.05, 止盈率=112.93%, 止损价=74.95, 止损率=112.77%
INFO 2025-08-08 13:21:02,865 decision_order_service 67176 66768 开始执行 2025-01-09 的下单流程...
INFO 2025-08-08 13:21:02,869 decision_order_service 67176 66768 确定唯一买入标的: 康泰生物(sz.300601) (Rank:3)。 计划以限价 15.14 买入 1300 股。
INFO 2025-08-08 13:21:02,871 simulate_trade_handler 67176 66768 [回测] 买入 康泰生物(sz.300601) 1300股 @15.14, 花费: 19682.00, 佣金: 5.62, 现金余额: 15158.90
INFO 2025-08-08 13:21:02,873 decision_order_service 67176 66768 开始为 trade_id=15 计算止盈止损区间...
INFO 2025-08-08 13:21:02,884 decision_order_service 67176 66768 [sz.300601] 止损线比较: 趋势位=13.37, 技术位=17.56, 底线=13.93
INFO 2025-08-08 13:21:02,885 decision_order_service 67176 66768 成功计算并更新 Position ID 9 (sz.300601) 的风控价格: 购入价=15.14, 止盈价=17.09, 止盈率=112.85%, 止损价=17.56, 止损率=115.98%
INFO 2025-08-08 13:21:02,887 simulate_trade 67176 66768 -> [T日 盘中监控] 模拟价格跌至最低点...
INFO 2025-08-08 13:21:02,889 simulate_trade 67176 66768 -> [T日 盘中监控] 模拟价格涨至最高点...
INFO 2025-08-08 13:21:02,893 simulate_trade 67176 66768 --- 日终结算 (2025-01-09) ---
INFO 2025-08-08 13:21:02,894 simulate_trade 67176 66768 现金: 15158.90, 持仓市值: 55730.00, 总资产: 70888.90
INFO 2025-08-08 13:21:02,894 simulate_trade 67176 66768 
==================== 模拟日: 2025-01-10 (7/143) ====================
INFO 2025-08-08 13:21:02,895 simulate_trade 67176 66768 -> [T-1 选股] 基于 2025-01-09 的数据...
INFO 2025-08-08 13:21:02,926 selection_service 67176 66768 剔除科创版和ST和次新股后，剩余 4343 只股票。
INFO 2025-08-08 13:21:03,689 selection_service 67176 66768 剔除低流动性股后，最终剩余 2719 只股票进入精选池。
INFO 2025-08-08 13:21:05,523 selection_service 67176 66768 M(t) 计算完成，值为: -0.4890，并已存入缓存。
