======= 项目文件树 =======

📂 ./
    📄 .env
    📄 .env.example
    📄 M值关系分析.py
    📄 M值分析报告.txt
    📄 backtest.sh
    📄 backtest_m.sh
    📄 config.json
    📄 m_value_csi300.csv
    📄 manage.py
    📄 requirements.txt
    📄 restart.sh
    📄 trade_report.html
    📄 user.json
    📄 uwsgi.ini
    📄 互相关分析.py
    📄 互相关分析.txt
    📄 交易变化.html
    📄 回测简单日志.txt
    📄 回测简单日志_v2.1.txt
    📄 回测简单日志_v2.2.txt
    📄 提取日志.py
    📄 日志分析提示词.txt
    📄 测试akshare.py
    📄 测试easytrader.py
    📄 资金变化图.png
    📂 autoTrade/
        📄 __init__.py
        📄 asgi.py
        📄 settings.py
        📄 urls.py
        📄 wsgi.py
    📂 common/
        📄 __init__.py
        📄 admin.py
        📄 apps.py
        📄 config_loader.py
        📄 tests.py
        📄 views.py
        📂 models/
            📄 __init__.py
            📄 backtest_logs.py
            📄 corporate_action.py
            📄 daily_factor_values.py
            📄 daily_quotes.py
            📄 daily_trading_plan.py
            📄 factor_definitions.py
            📄 index_quotes_csi300.py
            📄 positions.py
            📄 stock_info.py
            📄 strategy_parameters.py
            📄 system_log.py
            📄 trade_log.py
    📂 data_manager/
        📄 __init__.py
        📄 admin.py
        📄 apps.py
        📄 models.py
        📄 tests.py
        📄 urls.py
        📄 views.py
        📂 management/
            📂 commands/
                📄 backfill_csi300_data.py
                📄 calibrate_m_value_anchors.py
                📄 full_update_stocks.py
                📄 migrate_to_pg.py
                📄 reset_sequences.py
        📂 service/
            📄 corporate_action_service.py
            📄 db_service.py
            📄 email_handler.py
            📄 email_service.py
            📄 stock_service.py
    📂 selection_manager/
        📄 __init__.py
        📄 admin.py
        📄 apps.py
        📄 models.py
        📄 tests.py
        📄 urls.py
        📄 views.py
        📂 service/
            📄 m_value_service.py
            📄 ml.example
            📄 selection_service copy.old_v4
            📄 selection_service copy.py.old_v5
            📄 selection_service.py
            📄 selection_service.py.old
            📄 selection_service.py.old_v2
            📄 selection_service.py.old_v3
            📄 selection_service.py.old_v6
            📄 stock_value_service.py
        📂 management/
            📂 commands/
                📄 generate_m_value_csv.py
                📄 prepare_csi300_features.py
                📄 prepare_stock_features.py
                📄 train_csi300_model_test.py
                📄 train_stock_model.py
        📂 ml_models/
            📄 csi300_cnn_final_model.h5
            📄 csi300_features_gen2.pkl
            📄 csi300_features_lgbm.pkl
            📄 csi300_lgbm_config.json
            📄 csi300_lgbm_model.joblib
            📄 csi300_model_config.json
            📄 m_value_dataset.pkl
            📄 m_value_lgbm_model.joblib
            📄 m_value_model_config.json
            📄 stock_features_dataset.pkl
            📄 stock_lgbm_model.joblib
            📄 stock_model_config.json
    📂 trade_manager/
        📄 __init__.py
        📄 admin.py
        📄 apps.py
        📄 models.py
        📄 tests.py
        📄 urls.py
        📄 views.py
        📂 management/
            📂 commands/
                📄 run_backtest.py
                📄 run_m_distribution_backtest.py
                📄 run_scheduler.py
        📂 service/
            📄 backtest_reporter.py
            📄 before_fix_service.py
            📄 db_utils.py
            📄 decision_order_service.py
            📄 decision_order_service_old.py
            📄 m_distribution_backtest_service.py
            📄 m_distribution_reporter.py
            📄 monitor_exit_service.py
            📄 position_monitor_logic.py
            📄 real_trade_handler.py
            📄 scheduler_service.py
            📄 simulate_trade.py
            📄 simulate_trade_handler.py
            📄 simulate_trade_old.py
            📄 trade_handler.py
    📂 logs/
        📄 .__django.lock
        📄 django.log

========================

======= Python文件内容 =======

####M值关系分析.py####
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime

# --- 配置区 ---

# 设置中文字体，以防图表和报告中的中文乱码
plt.rcParams['font.sans-serif'] = ['SimHei']  # 'SimHei' 是黑体，适用于Windows
# plt.rcParams['font.sans-serif'] = ['Arial Unicode MS'] # 适用于 Mac
plt.rcParams['axes.unicode_minus'] = False  # 解决负号'-'显示为方块的问题

# --- 功能函数区 ---

def load_data(file_path):
    """
    加载数据文件，并自动处理常见的编码问题 (UTF-8, GBK)。
    """
    try:
        # 优先尝试UTF-8编码
        df = pd.read_csv(file_path, parse_dates=['日期'])
        print("文件以 UTF-8 编码成功加载。")
    except UnicodeDecodeError:
        try:
            # 如果UTF-8失败，尝试GBK编码
            df = pd.read_csv(file_path, parse_dates=['日期'], encoding='gbk')
            print("文件以 GBK 编码成功加载。")
        except Exception as e:
            print(f"尝试多种编码后，读取文件失败: {e}")
            return None
    except Exception as e:
        print(f"读取或解析文件时出错: {e}")
        return None
        
    df = df.set_index('日期').sort_index()
    return df

def analyze_m_value_predictiveness(df, horizons=[1,5, 20, 60]):
    """
    分析M值对未来沪深300指数收益和波动性的预测能力。
    """
    # 1. 计算未来的N日涨跌幅
    for h in horizons:
        df[f'fwd_return_{h}d'] = (df['沪深300收盘指数'].shift(-h) / df['沪深300收盘指数']) - 1

    df.dropna(inplace=True)

    # 2. 对M值进行分箱
    bins = np.arange(-1.0, 1.10, 0.1)
    # 确保标签和bins的长度匹配
    labels = [f"[{i:.1f}, {i+0.1:.1f})" for i in bins[:-1]]
    df['m_bin'] = pd.cut(df['m值'], bins=bins, labels=labels, right=False, include_lowest=True)

    print("M值分箱完成，开始进行分组统计...")

    # 3. 按M值分箱进行分组统计
    results = {}
    for h in horizons:
        agg_funcs = {
            f'fwd_return_{h}d': [
                ('平均涨跌幅(%)', lambda x: x.mean() * 100),
                ('涨跌幅标准差(%)', lambda x: x.std() * 100),
                ('样本数', 'count')
            ]
        }
        grouped_stats = df.groupby('m_bin').agg(agg_funcs)
        grouped_stats.columns = grouped_stats.columns.droplevel(0)
        results[h] = grouped_stats
    
    return results

def generate_text_report(results, file_path, df_info):
    """
    生成结构化的文本分析报告。
    """
    report_content = []
    report_content.append("="*80)
    report_content.append(" M(t) 指标有效性分析报告")
    report_content.append("="*80)
    report_content.append(f"报告生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    report_content.append(f"数据源文件: {file_path}")
    report_content.append(f"数据时间范围: {df_info['start_date']} 到 {df_info['end_date']}")
    report_content.append(f"总样本数: {df_info['total_samples']}")
    report_content.append("\n")

    for horizon, data in results.items():
        report_content.append("-" * 80)
        report_content.append(f" 分析维度：未来 {horizon} 交易日市场表现")
        report_content.append("-" * 80)
        
        # 添加数据表
        report_content.append("【详细数据统计】\n")
        report_content.append(data.to_string())
        report_content.append("\n")

        # 添加自动解读
        report_content.append("【核心洞察解读】\n")
        
        # 1. 趋势性分析
        high_m_returns = data[data.index.str.startswith('[0.')]['平均涨跌幅(%)']
        low_m_returns = data[data.index.str.startswith('[-')]['平均涨跌幅(%)']
        
        if not high_m_returns.empty and not low_m_returns.empty:
            avg_high_return = high_m_returns.mean()
            avg_low_return = low_m_returns.mean()
            if avg_high_return > 0 and avg_low_return < 0 and avg_high_return > avg_low_return:
                report_content.append(f"  - 趋势预测性: 表现良好。M值为正时平均收益为 {avg_high_return:.2f}%，M值为负时平均收益为 {avg_low_return:.2f}%。M值越高，未来收益期望越高。")
            else:
                report_content.append(f"  - 趋势预测性: 表现不明显或存在反常。M值为正时平均收益 {avg_high_return:.2f}%，M值为负时平均收益 {avg_low_return:.2f}%。")
        
        # 2. 波动性/风险分析
        min_std_bin = data['涨跌幅标准差(%)'].idxmin()
        min_std_val = data['涨跌幅标准差(%)'].min()
        report_content.append(f"  - 风险指示性: 市场不确定性最低（最可预测）的区间出现在 M值 {min_std_bin}，其未来涨跌幅标准差仅为 {min_std_val:.2f}%。")

        # 3. 策略建议
        report_content.append("\n【策略应用建议】\n")
        if avg_high_return > 0.5: # 阈值可调
             report_content.append("  - 当 M 值较高时 (如 > 0.3)，未来市场上涨概率较大，适合加大【趋势动能】和【强势突破】策略的权重。")
        if avg_low_return < -0.5: # 阈值可调
             report_content.append("  - 当 M 值较低时 (如 < -0.3)，未来市场下跌风险较高，适合加大【质量防御】策略的权重。")
        if '[-0.2, -0.1)' in min_std_bin or '[0.0, 0.1)' in min_std_bin or '[-0.1, 0.0)' in min_std_bin:
             report_content.append("  - 当 M 值接近 0 时，若波动率显著降低，表明市场进入震荡期，适合加大【均值回归】策略的权重。")
        
        report_content.append("\n\n")

    report_filename = "M值分析报告.txt"
    with open(report_filename, 'w', encoding='utf-8') as f:
        f.write("\n".join(report_content))
    
    print(f"分析报告已成功保存至: {report_filename}")


def plot_analysis_results(results):
    """
    将分析结果可视化。
    """
    for horizon, data in results.items():
        fig, ax1 = plt.subplots(figsize=(14, 7))

        x_labels = data.index.astype(str)
        mean_returns = data['平均涨跌幅(%)']
        std_devs = data['涨跌幅标准差(%)']
        counts = data['样本数']

        color = 'tab:blue'
        ax1.set_xlabel('M值区间', fontsize=12)
        ax1.set_ylabel(f'未来{horizon}日平均涨跌幅 (%)', color=color, fontsize=12)
        bars = ax1.bar(x_labels, mean_returns, color=color, alpha=0.7)
        ax1.tick_params(axis='y', labelcolor=color)
        plt.setp(ax1.get_xticklabels(), rotation=45, ha="right")
        ax1.axhline(0, color='gray', linewidth=0.8, linestyle='--')

        for i, bar in enumerate(bars):
            yval = bar.get_height()
            # 使用整数索引 i 从 counts 中获取正确的样本数值
            count_val = counts.iloc[i]
            ax1.text(bar.get_x() + bar.get_width()/2.0, yval + np.sign(yval)*0.1, f"n={int(count_val)}", ha='center', va='bottom', fontsize=8)

        ax2 = ax1.twinx()
        color = 'tab:red'
        ax2.set_ylabel(f'未来{horizon}日涨跌幅标准差 (%)', color=color, fontsize=12)
        ax2.plot(x_labels, std_devs, color=color, marker='o', linestyle='-')
        ax2.tick_params(axis='y', labelcolor=color)

        fig.tight_layout()
        plt.title(f'M值区间与未来 {horizon} 交易日市场表现关系', fontsize=16)
        plt.grid(True, axis='y', linestyle='--', alpha=0.6)
        plt.show()

# --- 主程序入口 ---
if __name__ == "__main__":
    # 1. 定义文件路径和分析参数
    csv_file_path = 'm_value_csi300.csv'  # <--- 请确保这是您的文件名
    analysis_horizons = [1,5, 20, 60]

    # 2. 加载数据
    df_raw = load_data(csv_file_path)

    if df_raw is not None:
        # 3. 提取数据信息用于报告
        df_info = {
            'start_date': df_raw.index.min().strftime('%Y-%m-%d'),
            'end_date': df_raw.index.max().strftime('%Y-%m-%d'),
            'total_samples': len(df_raw)
        }
        
        # 4. 执行核心分析
        analysis_results = analyze_m_value_predictiveness(df_raw.copy(), horizons=analysis_horizons)
        
        # 5. 生成文本报告
        generate_text_report(analysis_results, csv_file_path, df_info)
        
        # 6. 生成可视化图表
        plot_analysis_results(analysis_results)


####文件结束####

####manage.py####
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys
import dotenv

def main():
    """Run administrative tasks."""
    dotenv.load_dotenv()
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'autoTrade.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()

####文件结束####

####互相关分析.py####
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import pearsonr

# 设置matplotlib以正确显示中文
plt.rcParams['font.sans-serif'] = ['SimHei']  # 'SimHei' 是一个常用的中文字体
plt.rcParams['axes.unicode_minus'] = False  # 正确显示负号

# --- 1. 加载和准备数据 ---
def load_and_prepare_data(filepath):
    """加载CSV数据，并进行基本预处理"""
    df = pd.read_csv(filepath)
    
    # 将'日期'列转换为datetime对象，并设为索引
    df['日期'] = pd.to_datetime(df['日期'])
    df = df.set_index('日期')
    
    # 按日期排序，确保时间序列是连续的
    df = df.sort_index()
    
    print("原始数据预览：")
    print(df.head())
    print("\n")
    
    return df

# --- 2. 计算日收益率 ---
def calculate_returns(df):
    """
    计算日收益率。在金融分析中，分析收益率比分析原始价格更常见。
    这有助于序列的平稳化，并关注相对变化。
    """
    # # 使用 .pct_change() 计算百分比变化
    # df_returns = df.pct_change()
    
    # # m值本身可能就是变化率，如果m值已经是类似收益率的指标，可以跳过对m值的处理
    # # 这里我们假设m值也需要处理，如果不需要，可以注释掉下面这行
    # # df_returns['m值'] = df['m值'] # 如果m值本身就是变化率，直接使用原始值
    
    # # 删除第一行，因为其没有前一天的值，计算结果为NaN
    # df_returns = df_returns.dropna()
    df_processed = pd.DataFrame(index=df.index)
    
    # 只对价格序列计算百分比变化
    df_processed['沪深300指数_returns'] = df['沪深300收盘指数'].pct_change()
    
    # 直接使用m值，因为它可能已经是变化率
    df_processed['m值'] = df['m值']
    
    # 删除第一行，因为收益率计算结果为NaN
    df_processed = df_processed.dropna()
    print("日收益率数据预览：")
    print(df_processed.head())
    print("\n")
    
    return df_processed

# --- 3. 互相关分析核心函数 ---
def cross_correlation_analysis(series1, series2, max_lag):
    """
    计算两个时间序列在指定最大滞后范围内的互相关性。
    
    参数:
    series1 (pd.Series): 第一个时间序列 (例如 m值的变化)
    series2 (pd.Series): 第二个时间序列 (例如 沪深300的变化)
    max_lag (int): 要测试的最大正负滞后天数
    
    返回:
    lags (list): 滞后天数列表
    corrs (list): 对应的相关系数列表
    """
    lags = []
    corrs = []
    
    # 遍历从 -max_lag 到 +max_lag 的所有滞后期
    for lag in range(-max_lag, max_lag + 1):
        # 对 series1 进行移位操作
        # lag > 0: series1 向前移动 (用未来的值对齐现在的series2)，代表series2领先
        # lag < 0: series1 向后移动 (用过去的值对齐现在的series2)，代表series1领先
        shifted_series1 = series1.shift(lag)
        
        # 将两个序列对齐，并移除因移位产生的NaN值
        # 这会确保我们只在两个序列都有数据的日期上计算相关性
        temp_df = pd.concat([shifted_series1, series2], axis=1)
        temp_df.columns = ['s1_shifted', 's2']
        temp_df = temp_df.dropna()
        
        if not temp_df.empty:
            # 计算皮尔逊相关系数
            corr, _ = pearsonr(temp_df['s1_shifted'], temp_df['s2'])
            lags.append(lag)
            corrs.append(corr)
            
    return lags, corrs

def plot_and_interpret(lags, corrs, series1_name, series2_name):
    """绘制互相关图，解读结果，并生成txt报告"""
    
    # 找到最大相关性及其对应的滞后期
    max_corr = max(corrs)
    best_lag = lags[np.argmax(corrs)]
    
    # --- 生成解读文本 ---
    if best_lag > 0:
        interpretation_text = f"解读: {series2_name} 的变化趋势平均领先于 {series1_name} {best_lag} 天。"
    elif best_lag < 0:
        interpretation_text = f"解读: {series1_name} 的变化趋势平均领先于 {series2_name} {-best_lag} 天。"
    else:
        interpretation_text = f"解读: {series1_name} 和 {series2_name} 的变化趋势基本同步。"
    # --- 在控制台打印结果 ---
    print("--- 分析结果 ---")
    print(f"最大相关系数为: {max_corr:.4f}")
    print(f"对应的最佳滞后期为: {best_lag} 天")
    print(interpretation_text)
    print("----------------\n")
    # --- 生成并保存TXT报告 ---
    report_filename = '互相关分析.txt'
    report_content = f"""
互相关分析报告
================================
分析对象:
- 序列1: {series1_name}
- 序列2: {series2_name}
核心发现:
--------------------------------
- 最大相关系数: {max_corr:.4f}
- 最佳滞后期: {best_lag} 天
结论:
--------------------------------
{interpretation_text}
================================
报告生成于: {pd.Timestamp.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
    try:
        with open(report_filename, 'w', encoding='utf-8') as f:
            f.write(report_content)
        print(f"分析报告已成功保存为: {report_filename}")
    except Exception as e:
        print(f"保存报告失败: {e}")
    # --- 绘制互相关图 ---
    plt.figure(figsize=(12, 6))
    # 使用修改后的代码，移除 use_line_collection
    plt.stem(lags, corrs) 
    plt.axvline(best_lag, color='r', linestyle='--', label=f'最佳滞后期: {best_lag}天')
    plt.title(f'{series1_name} 与 {series2_name} 的互相关分析')
    plt.xlabel('滞后期 (天)')
    plt.ylabel('相关系数')
    plt.grid(True)
    plt.legend()
    plt.show()


# --- 主程序 ---
if __name__ == '__main__':

    # 1. 加载数据
    df_raw = load_and_prepare_data('m_value_csi300.csv')
    
    # 2. 计算收益率
    # 注意：如果你的'm值'本身就是一种变化率或指标，而不是价格，你可能不需要对它计算pct_change()
    # 在这种情况下，你需要调整 calculate_returns 函数
    df_returns = calculate_returns(df_raw)
    
    # 3. 执行互相关分析
    # 我们将分析 'm值' 与 '沪深300收盘指数' 的收益率之间的关系
    # 设置一个合理的最大滞后期，比如30个交易日
    max_lag_days = 30
    
    # 注意这里的参数顺序：
    # series1是m值，series2是沪深300。
    # 结果中的正滞后意味着沪深300领先，负滞后意味着m值领先。
    lags, corrs = cross_correlation_analysis(
        df_returns['m值'], 
        df_returns['沪深300指数_returns'], 
        max_lag_days
    )
    
    # 4. 可视化和解读
    plot_and_interpret(lags, corrs, 'm值', '沪深300指数')


####文件结束####

####提取日志.py####
import re
import html
import matplotlib.pyplot as plt
from collections import defaultdict
import os

# ==============================================================================
# 配置区域
# ==============================================================================
LOG_FILE_PATH = '回测简单日志.txt'
PLOT_OUTPUT_PATH = '资金变化图.png'
HTML_REPORT_PATH = '交易变化.html'


# ==============================================================================
# 1. 日志解析
# ==============================================================================
def parse_log_file(file_path):
    """
    解析日志文件，提取绘图和报告所需的数据。
    """
    # 用于存储每日资产
    asset_dates = []
    asset_values = []
    
    # 用于存储每日的日志块
    daily_logs = []
    
    # 用于计算每支股票的盈亏
    # 结构: {'sz.002364': {'spent': 1000, 'received': 1100, 'dividends': 10, 'name': '中恒电气'}}
    stock_profits = defaultdict(lambda: {'spent': 0, 'received': 0, 'dividends': 0, 'name': ''})

    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            current_day_block = None
            for line in f:
                line = line.strip()
                if not line:
                    continue

                # 匹配新的一天
                day_match = re.search(r"模拟日: ([\d-]+)", line)
                if day_match:
                    if current_day_block:
                        daily_logs.append(current_day_block)
                    date_str = day_match.group(1)
                    current_day_block = {'date': date_str, 'logs': [line]}
                    continue
                
                if not current_day_block:
                    continue

                current_day_block['logs'].append(line)

                # 匹配总资产
                asset_match = re.search(r"总资产: ([\d.]+)", line)
                if asset_match:
                    asset_dates.append(current_day_block['date'])
                    asset_values.append(float(asset_match.group(1)))

                # 匹配买入操作
                buy_match = re.search(r"买入 (.+?)\((.+?)\).*?花费: ([\d.]+)", line)
                if buy_match:
                    name, code, cost = buy_match.groups()
                    stock_profits[code]['spent'] += float(cost)
                    if not stock_profits[code]['name']: # 首次记录股票名称
                        stock_profits[code]['name'] = name

                # 匹配卖出操作
                sell_match = re.search(r"卖出 (.+?) .*?收入: ([\d.]+)", line)
                if sell_match:
                    code, income = sell_match.groups()
                    stock_profits[code]['received'] += float(income)

                # 匹配分红事件
                dividend_match = re.search(r"持仓ID \d+ \((.+?)\) 获得分红 ([\d.]+)", line)
                if dividend_match:
                    code, dividend = dividend_match.groups()
                    stock_profits[code]['dividends'] += float(dividend)


            if current_day_block: # 添加最后一天的数据
                daily_logs.append(current_day_block)

    except FileNotFoundError:
        print(f"错误: 日志文件 '{file_path}' 未找到。")
        return None, None, None, None
    
    return asset_dates, asset_values, daily_logs, stock_profits

# ==============================================================================
# 2. 生成资金曲线图
# ==============================================================================
def generate_asset_plot(dates, assets, output_path):
    """
    使用matplotlib生成资金曲线图并保存。
    """
    if not dates or not assets:
        print("没有足够的资产数据来生成图表。")
        return

    print("正在生成资金变化图...")
    
    # 设置中文字体，以防乱码
    plt.rcParams['font.sans-serif'] = ['SimHei', 'Microsoft YaHei']
    plt.rcParams['axes.unicode_minus'] = False

    # 创建一个较大尺寸的图形
    fig, ax = plt.subplots(figsize=(18, 9))

    ax.plot(dates, assets, marker='.', linestyle='-', color='b')

    # 设置图表标题和标签
    ax.set_title('策略回测资金曲线', fontsize=20)
    ax.set_xlabel('模拟日期', fontsize=14)
    ax.set_ylabel('总资产 (元)', fontsize=14)
    ax.grid(True, linestyle='--', alpha=0.6)

    # 自动调整x轴标签以避免重叠
    fig.autofmt_xdate(rotation=45)
    
    # 格式化y轴为货币格式
    ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: format(int(x), ',')))

    # 确保布局紧凑，所有元素都可见
    plt.tight_layout()

    # 保存图表
    plt.savefig(output_path, dpi=150)
    plt.close()
    print(f"资金变化图已成功保存到: {output_path}")

# ==============================================================================
# 3. 生成HTML报告
# ==============================================================================
def generate_html_report(daily_logs, stock_profits, output_path):
    """
    生成包含高亮日志和盈亏汇总的HTML报告。
    """
    if not daily_logs or not stock_profits:
        print("没有足够的数据来生成HTML报告。")
        return
        
    print("正在生成HTML报告...")

    # --- 计算并排序股票盈亏 ---
    profit_summary = []
    for code, data in stock_profits.items():
        total_profit = data['received'] + data['dividends'] - data['spent']
        profit_summary.append({
            'code': code,
            'name': data['name'] or '未知名称',
            'profit': total_profit
        })
    
    # 从大到小排序
    sorted_profits = sorted(profit_summary, key=lambda x: x['profit'], reverse=True)

    # --- 构建HTML内容 ---
    html_content = """
    <!DOCTYPE html>
    <html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
        <title>回测交易日志报告</title>
        <style>
            body { font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif; line-height: 1.6; margin: 20px; background-color: #f4f4f4; color: #333; }
            h1, h2 { color: #0056b3; border-bottom: 2px solid #0056b3; padding-bottom: 10px; }
            .container { max-width: 1200px; margin: auto; background: #fff; padding: 20px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
            .summary-table { width: 100%; border-collapse: collapse; margin-bottom: 30px; }
            .summary-table th, .summary-table td { border: 1px solid #ddd; padding: 12px; text-align: left; }
            .summary-table th { background-color: #007bff; color: white; }
            .summary-table tr:nth-child(even) { background-color: #f2f2f2; }
            .profit { color: #d9534f; } /* 红色 */
            .loss { color: #5cb85c; } /* 绿色 */
            .day-block { border: 1px solid #ccc; border-radius: 5px; margin-bottom: 20px; padding: 15px; background-color: #fafafa; }
            .day-block h3 { margin-top: 0; color: #555; }
            .log-entry { font-family: 'Courier New', Courier, monospace; white-space: pre-wrap; word-wrap: break-word; }
            .log-profit-sell { color: #d9534f; font-weight: bold; } /* 止盈卖出 - 红色 */
            .log-stop-loss { color: #5cb85c; font-weight: bold; } /* 止损卖出 - 绿色 */
        </style>
    </head>
    <body>
        <div class="container">
            <h1>回测交易日志报告</h1>
            
            <h2>各股盈亏汇总 (从高到低)</h2>
            <table class="summary-table">
                <thead>
                    <tr>
                        <th>排名</th>
                        <th>股票名称</th>
                        <th>股票代码</th>
                        <th>总盈亏 (元)</th>
                    </tr>
                </thead>
                <tbody>
    """

    # 填充盈亏汇总表格
    for i, item in enumerate(sorted_profits):
        profit_class = 'profit' if item['profit'] >= 0 else 'loss'
        html_content += f"""
                    <tr>
                        <td>{i + 1}</td>
                        <td>{html.escape(item['name'])}</td>
                        <td>{html.escape(item['code'])}</td>
                        <td class="{profit_class}">{item['profit']:.2f}</td>
                    </tr>
        """
    
    html_content += """
                </tbody>
            </table>

            <h2>详细日志记录</h2>
    """

    # 填充详细日志
    for day in daily_logs:
        html_content += f"""
            <div class="day-block">
                <h3>{html.escape(day['date'])}</h3>
                <div class="log-entry">
        """
        for log_line in day['logs']:
            escaped_line = html.escape(log_line)
            if '触发止盈' in log_line or '止盈卖出' in log_line:
                html_content += f'<span class="log-profit-sell">{escaped_line}</span>\n'
            elif '触发止损' in log_line or '止损卖出' in log_line:
                html_content += f'<span class="log-stop-loss">{escaped_line}</span>\n'
            else:
                html_content += f'{escaped_line}\n'
        html_content += """
                </div>
            </div>
        """

    html_content += """
        </div>
    </body>
    </html>
    """

    # 写入文件
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(html_content)
    print(f"HTML报告已成功保存到: {output_path}")

# ==============================================================================
# 主执行函数
# ==============================================================================
def main():
    """主函数，协调所有操作。"""
    print("开始处理回测日志...")
    symbol=['==================== 模拟日','触发','[回测] 卖出',' [回测] 买入','总资产: ','获得分红','风控价格','M(t)','确定唯一买入标的']
    log_prefix_pattern = re.compile(r"^[A-Z]+\s+[\d\-\s:,]+\s+\w+\s+\d+\s+\d+\s+(.*)")
 
    clean_log_content = []
    
    # 使用 'with' 语句能更好地处理文件，并且更安全
    # 注意：如果你的原始日志文件不是gbk编码，请修改这里的 encoding
    try:
        with open('logs/django.log', "r", encoding="gbk") as f:
            for line in f:
                # 检查该行是否包含我们关心的关键字
                should_keep = False
                for keyword in symbol:
                    if keyword in line:
                        should_keep = True
                        break
                
                if should_keep:
                    # 去掉行首行尾的空白字符
                    stripped_line = line.strip()
                    
                    # 尝试用正则表达式匹配并去除前缀
                    match = log_prefix_pattern.match(stripped_line)
                    if match:
                        # 如果匹配成功，只取括号里捕获的内容 (核心日志)
                        clean_line = match.group(1)
                    else:
                        # 如果不匹配 (比如 "==== 模拟日..." 这种行)，就保留原样
                        clean_line = stripped_line
                    
                    clean_log_content.append(clean_line)
    except FileNotFoundError:
        print("错误: 原始日志文件 'logs/django.log' 未找到。")
        return
    except Exception as e:
        print(f"读取原始日志时发生错误: {e}")
        return
 
    # 将处理过的、干净的日志内容写入到简单日志文件中
    with open(LOG_FILE_PATH, 'w', encoding='utf-8') as f:
        f.write('\n'.join(clean_log_content))

    # 1. 解析日志
    asset_dates, asset_values, daily_logs, stock_profits = parse_log_file(LOG_FILE_PATH)

    if asset_dates is None: # 如果解析失败
        print("日志处理终止。")
        return

    # 2. 生成图表
    generate_asset_plot(asset_dates, asset_values, PLOT_OUTPUT_PATH)

    # 3. 生成HTML报告
    generate_html_report(daily_logs, stock_profits, HTML_REPORT_PATH)
    
    print("\n所有任务完成！")
    print(f" - 图表文件: {os.path.abspath(PLOT_OUTPUT_PATH)}")
    print(f" - 报告文件: {os.path.abspath(HTML_REPORT_PATH)}")


if __name__ == '__main__':
    main()
main()
####文件结束####

####测试akshare.py####
import akshare as ak
index_zh_a_hist_df = ak.index_zh_a_hist(symbol="000300", period="daily", start_date="20180101", end_date="20250815")
print(index_zh_a_hist_df)
####文件结束####

####测试easytrader.py####
import easytrader
import json
f=open('config.json','r',encoding='utf-8')
t=""
for line in f:
    line = line.strip()
    t=t+line
    if not line:
        continue
f.close()
config=json.loads(t)
print(config)
user = easytrader.use('ht_client')
user.connect(config['easytrader']['client_path'])
user.prepare(config['easytrader']['user'])
user.refresh()
print(user.balance)
user.exit()
####文件结束####

####遍历文件.py####
import os

# --- 配置 ---
# 要扫描的根目录，'.' 表示当前目录
ROOT_DIR = '.'
# 输出文件名
OUTPUT_FILE = 'result.txt'
# 要忽略的目录（使用集合以提高查找效率）
IGNORE_DIRS = {'.git', '__pycache__', 'venv', '.vscode', 'node_modules','migrations'}
# 要忽略的文件
IGNORE_FILES = {'.DS_Store', OUTPUT_FILE,'遍历文件.py'} # 确保不把输出文件本身包含进去

def generate_file_tree(root_dir, ignore_dirs, ignore_files):
    """生成项目文件树结构"""
    tree_lines = []
    for root, dirs, files in os.walk(root_dir, topdown=True):
        # 在遍历前，从dirs列表中移除要忽略的目录
        dirs[:] = [d for d in dirs if d not in ignore_dirs]
        
        # 计算当前深度，用于生成前缀
        level = root.replace(root_dir, '').count(os.sep)
        indent = ' ' * 4 * level
        
        # 添加目录名到树
        # os.path.basename(root) 用于获取当前目录名
        tree_lines.append(f"{indent}📂 {os.path.basename(root)}/")

        # 添加文件到树
        sub_indent = ' ' * 4 * (level + 1)
        for f in sorted(files): # 对文件进行排序
            if f not in ignore_files:
                tree_lines.append(f"{sub_indent}📄 {f}")
                
    return "\n".join(tree_lines)

def get_python_file_contents(root_dir, ignore_dirs):
    """获取所有.py文件的内容并格式化"""
    py_contents = []
    for root, dirs, files in os.walk(root_dir, topdown=True):
        # 同样，忽略指定目录
        dirs[:] = [d for d in dirs if d not in ignore_dirs]
        
        for file in sorted(files):
            if file.endswith('.py'):
                file_path = os.path.join(root, file)
                # 使用相对路径，让输出更清晰
                relative_path = os.path.relpath(file_path, root_dir)
                
                header = f"####{relative_path}####"
                footer = "####文件结束####"
                
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                    py_contents.append(f"{header}\n{content}\n{footer}\n")
                except Exception as e:
                    py_contents.append(f"{header}\n无法读取文件内容: {e}\n{footer}\n")
                    
    return "\n".join(py_contents)

def main():
    """主函数，执行所有操作"""
    print("开始生成项目文件树...")
    file_tree = generate_file_tree(ROOT_DIR, IGNORE_DIRS, IGNORE_FILES)
    
    print("开始读取所有.py文件内容...")
    python_contents = get_python_file_contents(ROOT_DIR, IGNORE_DIRS)
    
    print(f"正在将结果写入 {OUTPUT_FILE}...")
    
    # 将所有内容合并写入文件
    with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
        f.write("======= 项目文件树 =======\n\n")
        f.write(file_tree)
        f.write("\n\n========================\n\n")
        f.write("======= Python文件内容 =======\n\n")
        f.write(python_contents)
        
    print(f"✅ 成功！项目结构和代码已保存到 {OUTPUT_FILE}")

if __name__ == '__main__':
    main()

####文件结束####

####autoTrade\__init__.py####

####文件结束####

####autoTrade\asgi.py####
"""
ASGI config for autoTrade project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'autoTrade.settings')

application = get_asgi_application()

####文件结束####

####autoTrade\settings.py####
"""
Django settings for autoTrade project.

Generated by 'django-admin startproject' using Django 5.2.4.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""

from pathlib import Path
import os
import dotenv
# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent
dotenv.load_dotenv(os.path.join(BASE_DIR, '.env'))


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!

# SECURITY WARNING: don't run with debug turned on in production!

SECRET_KEY = os.getenv('SECRET_KEY', 'default-secret-key-for-dev')
ENVIRONMENT = os.getenv('ENVIRONMENT', 'development')
DEBUG = (ENVIRONMENT == 'development')
if ENVIRONMENT == 'production':
    # 请将 'your_domain.com' 和服务器的公网/内网IP填入
    ALLOWED_HOSTS = ['your_domain.com', '1.15.100.196', '10.0.4.15','10.0.12.10','127.0.0.1','0.0.0.0']
else:
    ALLOWED_HOSTS = ['*']


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'data_manager',
    'selection_manager',
    'trade_manager',
    'common'
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    #'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'autoTrade.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'autoTrade.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.getenv('DB_NAME', 'maindb'),
        'USER': os.getenv('DB_USER', 'xyx'),
        'PASSWORD': os.getenv('DB_PASSWORD', 'xyx123'),
        'HOST': os.getenv('DB_HOST', 'localhost'), # 默认使用 localhost
        'PORT': os.getenv('DB_PORT', '5432'),
        'OPTIONS': {
            'keepalives': 1,
            'keepalives_idle': 60,
            'keepalives_interval': 10,
            'keepalives_count': 6,
        }
    },
    'local_sqlite': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': 'D:/project/mainDB.sqlite3', # 注意：在Python字符串中，路径最好使用正斜杠'/'
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'Asia/Shanghai'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'


LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,  # 不要禁用已存在的日志器，否则 Django 自带的日志会失效
    
    # 1. 定义日志格式
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
        'simple': {
            'format': '{levelname} {message}',
            'style': '{',
        },
    },
    
    # 2. 定义处理器 (日志去哪里)
    'handlers': {
        # 输出到控制台
        'console': {
            'level': 'DEBUG',  # 处理 DEBUG 及以上级别的日志
            'class': 'logging.StreamHandler',
            'formatter': 'verbose', # 使用 verbose 格式
        },
        # 输出到文件
        'file': {
            'level': 'DEBUG',  # 处理 INFO 及以上级别的日志
            'class': 'concurrent_log_handler.ConcurrentRotatingFileHandler',
            'filename': os.path.join(BASE_DIR, 'logs/django.log'), # 日志文件路径
            'maxBytes': 1024 * 1024 * 10,  # 5 MB
            'backupCount': 5, # 最多保留 5 个备份文件
            'formatter': 'verbose', # 使用 verbose 格式
        },
    },
    
    # 3. 定义记录器 (哪些日志需要处理)
    'loggers': {
        # Django 框架自身的日志
        'django': {
            'handlers': ['console', 'file'],
            'level': 'INFO',
            'propagate': True,
        },
        # 你自己应用的日志
        'data_manager': { # 这里使用你的 app 名称
            'handlers': ['console','file'],
            'level': 'DEBUG', # 在开发时设为 DEBUG，可以看到所有信息
            'propagate': False, # 不向上传递给 root logger
        },
        'selection_manager': { # 这里使用你的 app 名称
            'handlers': ['console','file'],
            'level': 'DEBUG', # 在开发时设为 DEBUG，可以看到所有信息
            'propagate': False, # 不向上传递给 root logger
        },
        'trade_manager': { # 这里使用你的 app 名称
            'handlers': ['console','file'],
            'level': 'DEBUG', # 在开发时设为 DEBUG，可以看到所有信息
            'propagate': False, # 不向上传递给 root logger
        },
        # 你可以为任何模块定义 logger
        'common': {
            'handlers': ['console', 'file'],
            'level': 'DEBUG',
            'propagate': False,
        },
        # --- 新增日志清理配置 ---
        'sqlalchemy.engine': {
            'handlers': ['console', 'file'],
            'level': 'WARNING',  # <-- 只显示 WARNING 及以上级别的日志，过滤掉SQL语句
            'propagate': False,
        },
        'psycopg2': {
            'handlers': ['console', 'file'],
            'level': 'WARNING',  # <-- 过滤掉 psycopg2 的低级别日志
            'propagate': False,
        },
        'apscheduler': {
            'handlers': ['console', 'file'],
            'level': 'WARNING', # <-- 过滤掉 apscheduler 的 INFO 日志
            'propagate': False,
        }

    }
}
 
# 确保 logs 目录存在
LOGS_DIR = os.path.join(BASE_DIR, 'logs')
if not os.path.exists(LOGS_DIR):
    os.makedirs(LOGS_DIR)
####文件结束####

####autoTrade\urls.py####
"""
URL configuration for autoTrade project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path,include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('dataManager/', include('data_manager.urls')),
    path('selectionManager/', include('selection_manager.urls')),
    path('tradeManager/', include('trade_manager.urls'))
]

####文件结束####

####autoTrade\wsgi.py####
"""
WSGI config for autoTrade project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'autoTrade.settings')

application = get_wsgi_application()

####文件结束####

####common\__init__.py####

####文件结束####

####common\admin.py####
# common/admin.py

from django.contrib import admin
from .models import (
    StockInfo, DailyQuotes, FactorDefinitions, DailyFactorValues,
    StrategyParameters, DailyTradingPlan, Position, TradeLog,
    SystemLog, CorporateAction
)

# -----------------------------------------------------------------------------
# 1. 基础数据管理 (股票信息、行情、股权事件)
# -----------------------------------------------------------------------------

@admin.register(StockInfo)
class StockInfoAdmin(admin.ModelAdmin):
    """股票基础信息管理"""
    list_display = ('stock_code', 'stock_name', 'listing_date', 'status', 'updated_at')
    search_fields = ('stock_code', 'stock_name')
    list_filter = ('status', 'listing_date')
    ordering = ('stock_code',)
    readonly_fields = ('created_at', 'updated_at')

@admin.register(DailyQuotes)
class DailyQuotesAdmin(admin.ModelAdmin):
    """日线行情管理"""
    list_display = ('trade_date', 'stock_code', 'open', 'close', 'volume', 'turnover', 'hfq_close')
    search_fields = ('stock_code__stock_code', 'stock_code__stock_name')
    list_filter = ('trade_date',)
    ordering = ('-trade_date', 'stock_code')
    # 关键性能优化：对于有成千上万条记录的外键，使用 raw_id_fields 替代下拉框
    raw_id_fields = ('stock_code',)
    readonly_fields = ('hfq_close',)
    list_per_page = 25 # 设置每页显示条数

class CorporateActionAdmin(admin.ModelAdmin):
    """股权事件管理"""
    list_display = ('ex_dividend_date', 'stock_code', 'event_type', 'dividend_per_share', 'shares_before', 'shares_after', 'rights_issue_price')
    # 修正：直接搜索本表的 stock_code 字段即可
    search_fields = ('stock_code',) 
    list_filter = ('event_type', 'ex_dividend_date')
    ordering = ('-ex_dividend_date', 'stock_code')
    # raw_id_fields = ('stock_code',)

# -----------------------------------------------------------------------------
# 2. 策略与因子定义管理
# -----------------------------------------------------------------------------

@admin.register(FactorDefinitions)
class FactorDefinitionsAdmin(admin.ModelAdmin):
    """因子定义管理"""
    list_display = ('factor_code', 'factor_name', 'direction', 'is_active', 'description')
    search_fields = ('factor_code', 'factor_name')
    list_filter = ('direction', 'is_active')
    ordering = ('factor_code',)

@admin.register(StrategyParameters)
class StrategyParametersAdmin(admin.ModelAdmin):
    """策略参数管理"""
    list_display = ('param_name', 'param_value', 'group_name', 'description')
    search_fields = ('param_name', 'group_name')
    list_filter = ('group_name',)
    ordering = ('group_name', 'param_name')
    # 核心功能：允许在列表页直接编辑参数值，非常方便调参
    list_editable = ('param_value',)

@admin.register(DailyFactorValues)
class DailyFactorValuesAdmin(admin.ModelAdmin):
    """每日因子值管理"""
    list_display = ('trade_date', 'stock_code', 'factor_code', 'raw_value', 'norm_score')
    search_fields = ('stock_code__stock_code', 'factor_code__factor_code')
    list_filter = ('trade_date', 'factor_code')
    ordering = ('-trade_date', 'stock_code')
    # 关键性能优化
    raw_id_fields = ('stock_code', 'factor_code')
    list_per_page = 25

# -----------------------------------------------------------------------------
# 3. 交易流程管理 (预案、持仓、记录)
# -----------------------------------------------------------------------------

@admin.register(DailyTradingPlan)
class DailyTradingPlanAdmin(admin.ModelAdmin):
    """每日交易预案管理"""
    list_display = ('plan_date', 'stock_code', 'rank', 'final_score', 'miop', 'maop', 'status')
    search_fields = ('stock_code__stock_code',)
    list_filter = ('plan_date', 'status')
    ordering = ('-plan_date', 'rank')
    raw_id_fields = ('stock_code',)
    list_per_page = 20

@admin.register(Position)
class PositionAdmin(admin.ModelAdmin):
    """持仓信息管理"""
    list_display = ('position_id', 'stock_code', 'entry_datetime', 'entry_price', 'quantity', 'current_stop_loss', 'current_take_profit', 'status')
    search_fields = ('stock_code__stock_code',)
    list_filter = ('status', 'entry_datetime')
    ordering = ('-entry_datetime',)
    raw_id_fields = ('stock_code',)

@admin.register(TradeLog)
class TradeLogAdmin(admin.ModelAdmin):
    """交易记录管理"""
    list_display = ('trade_id', 'position', 'stock_code', 'trade_datetime', 'trade_type', 'price', 'quantity', 'reason', 'status')
    search_fields = ('stock_code__stock_code', 'position__position_id')
    list_filter = ('trade_type', 'status', 'reason', 'trade_datetime')
    ordering = ('-trade_datetime',)
    raw_id_fields = ('position', 'stock_code')
    list_per_page = 25

# -----------------------------------------------------------------------------
# 4. 系统与日志管理
# -----------------------------------------------------------------------------

@admin.register(SystemLog)
class SystemLogAdmin(admin.ModelAdmin):
    """系统日志管理"""
    list_display = ('log_time', 'log_level', 'module_name', 'message_summary')
    list_filter = ('log_level', 'module_name', 'log_time')
    search_fields = ('message', 'module_name')
    ordering = ('-log_time',)
    # 日志应该是不可变的，所以设为只读
    readonly_fields = ('log_time', 'log_level', 'module_name', 'message')
    list_per_page = 30

    def message_summary(self, obj):
        """在列表页显示截断的日志信息"""
        return (obj.message[:80] + '...') if len(obj.message) > 80 else obj.message
    message_summary.short_description = '日志摘要'

    def has_add_permission(self, request):
        # 禁止在Admin后台手动添加日志
        return False

    def has_change_permission(self, request, obj=None):
        # 禁止在Admin后台修改日志
        return False

####文件结束####

####common\apps.py####
from django.apps import AppConfig


class CommonConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'common'

####文件结束####

####common\config_loader.py####
# common/config_loader.py

import json
import os
import logging
from django.conf import settings

logger = logging.getLogger(__name__)

class ConfigLoader:
    _instance = None
    _config = None

    def __new__(cls):
        if not cls._instance:
            cls._instance = super(ConfigLoader, cls).__new__(cls)
        return cls._instance

    def __init__(self):
        if self._config is None:
            self._load_config()

    def _load_config(self):
        config_path = os.path.join(settings.BASE_DIR, 'config.json')
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                self._config = json.load(f)
            logger.info("ConfigLoader: config.json 加载成功。")
        except (FileNotFoundError, json.JSONDecodeError) as e:
            logger.critical(f"ConfigLoader: 无法加载或解析 config.json: {e}。系统将无法正常运行。")
            self._config = {} # 返回一个空字典以避免后续调用出错

    def get_config(self):
        """获取完整的配置字典"""
        return self._config

    def get(self, key, default=None):
        """获取指定键的配置值"""
        return self._config.get(key, default)

# 创建一个全局实例，供项目各处调用
config_loader = ConfigLoader()

####文件结束####

####common\tests.py####
from django.test import TestCase

# Create your tests here.

####文件结束####

####common\views.py####
from django.shortcuts import render

# Create your views here.

####文件结束####

####common\models\__init__.py####
# my_strategy_app/__init__.py

from .stock_info import StockInfo
from .daily_quotes import DailyQuotes
from .factor_definitions import FactorDefinitions
from .daily_factor_values import DailyFactorValues
from .strategy_parameters import StrategyParameters
from .daily_trading_plan import DailyTradingPlan
from .positions import Position
from .trade_log import TradeLog
from .system_log import SystemLog
from .corporate_action import CorporateAction
from .backtest_logs import BacktestDailyLog,BacktestOperationLog
from .index_quotes_csi300 import IndexQuotesCsi300

__all__ = [
    'StockInfo',
    'DailyQuotes',
    'FactorDefinitions',
    'DailyFactorValues',
    'StrategyParameters',
    'DailyTradingPlan',
    'Position',
    'TradeLog',
    'SystemLog',
    'CorporateAction',
    'BacktestDailyLog',
    'BacktestOperationLog',
    "MDistributionBacktestLog",
    'IndexQuotesCsi300'
]

####文件结束####

####common\models\backtest_logs.py####
# ==============================================================================
# 描述: 定义回测日志相关的新模型。
# ==============================================================================
from django.db import models

class BacktestDailyLog(models.Model):
    """
    回测每日日志表
    
    说明: 记录每一次回测运行中，每个交易日结束后的资金、持仓和市场状态。
    这张表用于生成资金曲线图和关键的回撤指标。
    """
    backtest_run_id = models.CharField(
        max_length=50,
        db_index=True,
        help_text="回测运行的唯一标识符, 如 'backtest_20231027_153000'"
    )
    trade_date = models.DateField(
        help_text="交易日期"
    )
    total_assets = models.DecimalField(
        max_digits=20,
        decimal_places=4,
        help_text="当日日终总资产 (现金 + 持仓市值)"
    )
    cash = models.DecimalField(
        max_digits=20,
        decimal_places=4,
        help_text="当日日终现金余额"
    )
    holdings_value = models.DecimalField(
        max_digits=20,
        decimal_places=4,
        help_text="当日日终持仓市值"
    )
    market_m_value = models.DecimalField(
        max_digits=18,
        decimal_places=10,
        null=True,
        blank=True,
        help_text="当日的市场状态M(t)值"
    )
    created_at = models.DateTimeField(
        auto_now_add=True,
        help_text="记录创建时间"
    )

    class Meta:
        db_table = 'tb_trade_manager_backtest_daily_log'
        verbose_name = '回测每日日志'
        verbose_name_plural = verbose_name
        ordering = ['backtest_run_id', 'trade_date']
        # 为常用查询添加索引
        indexes = [
            models.Index(fields=['backtest_run_id', 'trade_date']),
        ]

class BacktestOperationLog(models.Model):
    """
    回测操作记录表
    
    说明: 增量记录回测过程中的每一次买入和卖出操作。
    这张表用于计算胜率、收益贡献等交易层面的指标。
    """
    class Direction(models.TextChoices):
        BUY = 'BUY', '买入'
        SELL = 'SELL', '卖出'

    class ExitReason(models.TextChoices):
        TAKE_PROFIT = 'TAKE_PROFIT', '止盈'
        STOP_LOSS = 'STOP_LOSS', '止损'

    backtest_run_id = models.CharField(
        max_length=50,
        db_index=True,
        help_text="回测运行的唯一标识符"
    )
    position_id_ref = models.BigIntegerField(
        db_index=True,
        help_text="关联的持仓ID (tb_positions.position_id)，用于反查"
    )
    stock_code = models.CharField(
        max_length=50,
        help_text="股票代码, 如 'sh.600000'"
    )
    stock_name = models.CharField(
        max_length=50,
        help_text="股票名称"
    )
    trade_date = models.DateField(
        help_text="交易发生的日期"
    )
    direction = models.CharField(
        max_length=10,
        choices=Direction.choices,
        help_text="买卖方向"
    )
    exit_reason = models.CharField(
        max_length=20,
        choices=ExitReason.choices,
        null=True,
        blank=True,
        help_text="止盈/止损方向 (仅卖出时有效)"
    )
    profit_rate = models.DecimalField(
        max_digits=10,
        decimal_places=4,
        null=True,
        blank=True,
        help_text="该笔交易设置的止盈率"
    )
    loss_rate = models.DecimalField(
        max_digits=10,
        decimal_places=4,
        null=True,
        blank=True,
        help_text="该笔交易设置的止损率"
    )
    buy_date_m_value = models.DecimalField(
        max_digits=18,
        decimal_places=10,
        null=True,
        blank=True,
        help_text="买入决策所依据的T-1日市场M(t)值"
    )
    factor_scores = models.TextField(
        help_text="买入时各因子得分, 格式: factor1:score1|factor2:score2"
    )
    price = models.DecimalField(
        max_digits=10,
        decimal_places=2,
        help_text="成交价格"
    )
    quantity = models.BigIntegerField(
        help_text="成交数量"
    )
    amount = models.DecimalField(
        max_digits=20,
        decimal_places=4,
        help_text="成交总金额"
    )
    created_at = models.DateTimeField(
        auto_now_add=True,
        help_text="记录创建时间"
    )

    class Meta:
        db_table = 'tb_trade_manager_backtest_operation_log'
        verbose_name = '回测操作记录'
        verbose_name_plural = verbose_name
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['backtest_run_id', 'stock_code']),
            models.Index(fields=['backtest_run_id', 'position_id_ref']),
        ]

class MDistributionBacktestLog(models.Model):
    """
    M值胜率分布回测的专用日志表。
    
    说明: 每一条记录代表一次完整的模拟交易（从预案生成到最终平仓）。
    这张表是M值胜率分布回测报告的唯一数据源。
    """
    class ExitReason(models.TextChoices):
        TAKE_PROFIT = 'TAKE_PROFIT', '止盈'
        STOP_LOSS = 'STOP_LOSS', '止损'
        END_OF_PERIOD = 'END_OF_PERIOD', '达到最大持有期'
    backtest_run_id = models.CharField(
        max_length=50,
        db_index=True,
        help_text="回测运行的唯一标识符"
    )
    plan_date = models.DateField(
        help_text="预案生成日期 (T-1日)"
    )
    stock_code = models.CharField(
        max_length=50,
        help_text="股票代码"
    )
    stock_name = models.CharField(
        max_length=50,
        help_text="股票名称"
    )
    m_value_at_plan = models.DecimalField(
        max_digits=18,
        decimal_places=10,
        help_text="预案生成日的市场M(t)值"
    )
    strategy_dna = models.CharField(
        max_length=255,
        help_text="策略DNA贡献度, 格式: MT:0.70|BO:0.20|MR:0.05|QD:0.05"
    )
    entry_date = models.DateField(
        help_text="模拟入场日期 (T日)"
    )
    entry_price = models.DecimalField(
        max_digits=10,
        decimal_places=2,
        help_text="模拟入场价格 (T日开盘价)"
    )
    exit_date = models.DateField(
        help_text="模拟出场日期"
    )
    exit_price = models.DecimalField(
        max_digits=10,
        decimal_places=2,
        help_text="模拟出场价格"
    )
    exit_reason = models.CharField(
        max_length=20,
        choices=ExitReason.choices,
        help_text="平仓原因"
    )
    holding_period = models.IntegerField(
        help_text="持有天数（交易日）"
    )
    # 预设的止盈止损率，用于计算期望收益
    preset_take_profit_rate = models.DecimalField(
        max_digits=10,
        decimal_places=4,
        help_text="根据策略计算出的预设止盈率"
    )
    preset_stop_loss_rate = models.DecimalField(
        max_digits=10,
        decimal_places=4,
        help_text="根据策略计算出的预设止损率"
    )
    # 实际收益率
    actual_return_rate = models.DecimalField(
        max_digits=10,
        decimal_places=4,
        help_text="该笔交易的实际收益率 ( (exit_price / entry_price) - 1 )"
    )

    one_stratage_mode = models.CharField(
        max_length=10,
        null=True,
        blank=True,
        db_index=True, # 为GROUP BY和查询优化添加索引
        help_text="单策略模式下使用的策略名 (MT, BO, QD, MR), 为空则为M动态策略"
    )

    created_at = models.DateTimeField(
        auto_now_add=True
    )
    class Meta:
        db_table = 'tb_m_distribution_backtest_log'
        verbose_name = 'M值分布回测日志'
        verbose_name_plural = verbose_name
        indexes = [
            models.Index(fields=['backtest_run_id', 'plan_date']),
            models.Index(fields=['backtest_run_id', 'one_stratage_mode'])
        ]
####文件结束####

####common\models\corporate_action.py####
from django.db import models

class CorporateAction(models.Model):
    """
    股权事件表 (tb_corporate_actions)
    
    说明: 存储所有影响股价非交易性变动的股权事件，是盘前校准模块和回测引擎的核心数据源。
    
    例子:
    10送5：event_type='bonus', shares_before=10, shares_after=15
    10转3：event_type='transfer', shares_before=10, shares_after=13
    10配3，配股价8元：event_type='rights', shares_before=10, shares_after=13, rights_issue_price=8
    1拆2：event_type='split', shares_before=1, shares_after=2 (理解为在1股基础上增加1股)
    10并1：event_type='split', shares_before=10, shares_after=1 (理解为在10股基础上减少9股)
    派1元：event_type='dividend', dividend_per_share=0.1
    """

    # 使用 Django 推荐的 TextChoices 来定义事件类型的枚举
    class EventType(models.TextChoices):
        DIVIDEND = 'dividend', '分红'
        BONUS = 'bonus', '送股'
        TRANSFER = 'transfer', '转股'
        RIGHTS = 'rights', '配股'
        SPLIT = 'split', '拆股/并股'

    # 字段定义
    event_id = models.BigAutoField(
        primary_key=True,
        help_text="事件唯一ID"
    )
    stock_code = models.CharField(
        max_length=50,
        null=False,
        blank=False,
        help_text="股票代码, 格式如 'sh.600000'"
    )
    ex_dividend_date = models.DateField(
        null=False,
        db_index=True,
        help_text="除权除息日 (策略判断的基准日期)，对于配股来说，实际为股权登记日而非除权日"
    )
    record_date = models.DateField(
        null=True,
        blank=True,
        help_text="股权登记日"
    )
    notice_date = models.DateField(
        null=True,
        blank=True,
        help_text="公告日期"
    )
    event_type = models.CharField(
        max_length=20,
        choices=EventType.choices,
        null=False,
        blank=False,
        help_text="事件类型。枚举: dividend(分红), bonus(送股), transfer(转股),rights(配股), split(拆股/并股)"
    )
    dividend_per_share = models.DecimalField(
        max_digits=10,
        decimal_places=4,
        null=True,
        blank=True,
        help_text="每股派息(税前, 元，分红专用)"
    )
    shares_before = models.DecimalField(
        max_digits=10,
        decimal_places=4,
        null=True,
        blank=True,
        help_text="基准股数 (如“10送5”，此值为10，送股/转股/拆股/并股专用)"
    )
    shares_after = models.DecimalField(
        max_digits=10,
        decimal_places=4,
        null=True,
        blank=True,
        help_text="变动股数 (如“10送5”，此值为15，送股/转股/拆股/并股专用)"
    )
    rights_issue_price = models.DecimalField(
        max_digits=10,
        decimal_places=2,
        null=True,
        blank=True,
        help_text="配股价格，配股专用"
    )
    created_at = models.DateTimeField(
        auto_now_add=True,
        null=False,
        help_text="记录创建时间"
    )

    class Meta:
        # 显式指定数据库中的表名
        db_table = 'tb_corporate_actions'
        # 在 Django Admin 中显示的名称
        verbose_name = '股权事件'
        verbose_name_plural = '股权事件'
        # 默认排序规则
        ordering = ['-ex_dividend_date', 'stock_code']

    def __str__(self):
        # 提供一个易于阅读的对象表示形式
        return f"{self.stock_code} on {self.ex_dividend_date}: {self.get_event_type_display()}"


####文件结束####

####common\models\daily_factor_values.py####
from django.db import models
from .stock_info import StockInfo
from .factor_definitions import FactorDefinitions

class DailyFactorValues(models.Model):
    """
    2.2. 每日因子值表 (tb_daily_factor_values)
    说明: (核心设计) 存储每只股票在每个交易日计算出的所有因子原始值和标准化分值。
    """
    stock_code = models.ForeignKey(
        StockInfo, 
        on_delete=models.CASCADE, 
        db_column='stock_code',
        help_text="股票代码"
    )
    trade_date = models.DateField(
        help_text="交易日期"
    )
    factor_code = models.ForeignKey(
        FactorDefinitions, 
        on_delete=models.CASCADE, 
        db_column='factor_code',
        help_text="因子代码"
    )
    raw_value = models.DecimalField(
        max_digits=20, 
        decimal_places=10, 
        help_text="因子计算出的原始值"
    )
    norm_score = models.DecimalField(
        max_digits=10, 
        decimal_places=4, 
        null=True, 
        blank=True,
        help_text="经过norm()函数标准化后的分值 (-100到100)"
    )

    def __str__(self):
        return f"{self.stock_code} - {self.factor_code} on {self.trade_date}"

    class Meta:
        db_table = 'tb_daily_factor_values'
        # 使用 unique_together 实现复合主键的唯一性约束
        unique_together = (('stock_code', 'trade_date', 'factor_code'),)
        verbose_name = '每日因子值'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\daily_quotes.py####
from django.db import models
from .stock_info import StockInfo

class DailyQuotes(models.Model):
    """
    1.2. 日线行情表 (tb_daily_quotes)
    说明: 存储从数据源获取的最原始的日线行情数据，是所有计算的基石。
    """
    stock_code = models.ForeignKey(
        StockInfo, 
        on_delete=models.CASCADE, 
        db_column='stock_code',
        help_text="股票代码"
    )
    trade_date = models.DateField(
        help_text="交易日期"
    )
    open = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="不复权开盘价"
    )
    high = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="不复权最高价"
    )
    low = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="不复权最低价"
    )
    close = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="不复权收盘价"
    )
    volume = models.BigIntegerField(
        help_text="成交量 (股)"
    )
    turnover = models.DecimalField(
        max_digits=20, 
        decimal_places=2, 
        help_text="成交额 (元)"
    )
    adjust_factor = models.DecimalField(
        max_digits=20, 
        decimal_places=10, 
        help_text="截至当日的后复权因子"
    )
    # (要求1) 计算列 hfq_close
    hfq_close = models.DecimalField(
        max_digits=20, 
        decimal_places=10, 
        editable=False,
        help_text="后复权收盘价，公式: close * adjust_factor"
    )

    def save(self, *args, **kwargs):
        # 在保存模型前计算 hfq_close 的值
        self.hfq_close = self.close * self.adjust_factor
        super().save(*args, **kwargs)

    def __str__(self):
        return f"{self.stock_code} on {self.trade_date}"

    class Meta:
        db_table = 'tb_daily_quotes'
        # 使用 unique_together 实现复合主键的唯一性约束
        unique_together = (('stock_code', 'trade_date'),)
        verbose_name = '日线行情'
        verbose_name_plural = verbose_name
        indexes = [
            models.Index(fields=['trade_date'], name='dailyquotes_tradedate_idx'), # <--- 在这里添加
        ]

####文件结束####

####common\models\daily_trading_plan.py####
from django.db import models
from .stock_info import StockInfo

class DailyTradingPlan(models.Model):
    """
    3.1. 每日交易预案表 (tb_daily_trading_plan)
    说明: 存储 T-1 日终选股模块生成的“次日观察池”及相关交易预案。
    """
    class StatusChoices(models.TextChoices):
        PENDING = 'pending', '待执行'
        EXECUTED = 'executed', '已执行买入'
        CANCELLED = 'cancelled', '当日未满足条件作废'

    plan_date = models.DateField(
        help_text="预案执行日期 (T日)"
    )
    stock_code = models.ForeignKey(
        StockInfo, 
        on_delete=models.CASCADE, 
        db_column='stock_code',
        help_text="候选股票代码"
    )
    rank = models.IntegerField(
        help_text="综合得分排名 (1-10)"
    )
    final_score = models.DecimalField(
        max_digits=10, 
        decimal_places=4, 
        help_text="f(x)选股综合得分"
    )
    miop = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="最低可接受开盘价 (Minimum Acceptable Open Price)"
    )
    maop = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="最高可接受开盘价 (Maximum Acceptable Open Price)"
    )
    status = models.CharField(
        max_length=20, 
        choices=StatusChoices.choices, 
        default=StatusChoices.PENDING,
        help_text="预案状态。枚举: pending(待执行), executed(已执行买入), cancelled(当日未满足条件作废)"
    )
    strategy_dna = models.CharField(
        max_length=255,
        null=True,  # 允许为空，确保对旧数据和现有代码的兼容性
        blank=True, # 允许为空
        help_text="策略DNA贡献度, 格式: MT:0.70|BO:0.20|MR:0.05|QD:0.05"
    )
    def __str__(self):
        return f"Plan for {self.stock_code} on {self.plan_date} (Rank: {self.rank})"

    class Meta:
        db_table = 'tb_daily_trading_plan'
        # 使用 unique_together 实现复合主键的唯一性约束
        unique_together = (('plan_date', 'stock_code'),)
        verbose_name = '每日交易预案'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\factor_definitions.py####
from django.db import models

class FactorDefinitions(models.Model):
    """
    2.1. 因子定义表 (tb_factor_definitions)
    说明: (核心设计) 用于定义所有策略中使用的因子，实现因子的可插拔。新增因子只需在此表增加一条记录。
    """
    class DirectionChoices(models.TextChoices):
        POSITIVE = 'positive', '正向, 值越大越好'
        NEGATIVE = 'negative', '负向, 值越小越好'

    factor_code = models.CharField(
        max_length=50, 
        primary_key=True, 
        help_text="因子唯一英文代码, 如 'MA20_SLOPE'"
    )
    factor_name = models.CharField(
        max_length=100, 
        help_text="因子中文名称, 如 '20日均线斜率'"
    )
    description = models.TextField(
        blank=True, 
        null=True, 
        help_text="详细描述因子的计算逻辑和业务含义"
    )
    direction = models.CharField(
        max_length=10, 
        choices=DirectionChoices.choices,
        help_text="因子方向性。枚举: positive(正向, 值越大越好), negative(负向, 值越小越好)"
    )
    is_active = models.BooleanField(
        default=True, 
        help_text="是否启用该因子"
    )

    def __str__(self):
        return f"{self.factor_name} ({self.factor_code})"

    class Meta:
        db_table = 'tb_factor_definitions'
        verbose_name = '因子定义'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\index_quotes_csi300.py####
# common/models/index_quotes_csi300.py
from django.db import models
from decimal import Decimal

class IndexQuotesCsi300(models.Model):
    """
    沪深300指数日线行情表

    说明: 存储沪深300指数的日线行情数据，作为市场状态函数 M(t) 的计算基石。
    数据通过 akshare 的 index_zh_a_hist 接口获取。
    """
    trade_date = models.DateField(
        primary_key=True,
        help_text="交易日期"
    )
    open = models.DecimalField(
        max_digits=10, decimal_places=2, help_text="开盘价"
    )
    close = models.DecimalField(
        max_digits=10, decimal_places=2, help_text="收盘价"
    )
    high = models.DecimalField(
        max_digits=10, decimal_places=2, help_text="最高价"
    )
    low = models.DecimalField(
        max_digits=10, decimal_places=2, help_text="最低价"
    )
    volume = models.BigIntegerField(
        help_text="成交量 (股)"
    )
    amount = models.DecimalField(
        max_digits=20, decimal_places=2, help_text="成交额 (元)"
    )
    amplitude = models.DecimalField(
        max_digits=8, decimal_places=4, help_text="振幅 (%)"
    )
    pct_change = models.DecimalField(
        max_digits=8, decimal_places=4, help_text="涨跌幅 (%)"
    )
    change_amount = models.DecimalField(
        max_digits=10, decimal_places=2, help_text="涨跌额"
    )
    turnover_rate = models.DecimalField(
        max_digits=8, decimal_places=4, null=True, blank=True, help_text="换手率 (%)"
    )

    class Meta:
        db_table = 'tb_index_quotes_csi300'
        verbose_name = '沪深300指数行情'
        verbose_name_plural = verbose_name
        ordering = ['-trade_date']

    def __str__(self):
        return f"CSI300 on {self.trade_date}: {self.close}"

####文件结束####

####common\models\positions.py####
from django.db import models
from .stock_info import StockInfo

class Position(models.Model):
    """
    3.2. 持仓信息表 (tb_positions)
    说明: 存储当前所有持仓的详细信息，是盘中监控模块的核心数据依据。
    """
    class StatusChoices(models.TextChoices):
        OPEN = 'open', '持仓中'
        CLOSED = 'closed', '已平仓'

    position_id = models.BigAutoField(
        primary_key=True, 
        help_text="持仓唯一ID"
    )
    stock_code = models.ForeignKey(
        StockInfo, 
        on_delete=models.PROTECT, # 保护，防止意外删除关联股票信息
        db_column='stock_code',
        help_text="股票代码"
    )
    entry_datetime = models.DateTimeField(
        help_text="建仓成交时间"
    )
    entry_price = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="实际成交均价 (AEP)"
    )
    quantity = models.BigIntegerField(
        help_text="持仓数量 (股)"
    )
    current_stop_loss = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="当前止损价"
    )
    current_take_profit = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="当前止盈价"
    )
    status = models.CharField(
        max_length=20, 
        choices=StatusChoices.choices, 
        default=StatusChoices.OPEN,
        help_text="持仓状态。枚举: open(持仓中), closed(已平仓)"
    )

    def __str__(self):
        return f"Position {self.position_id}: {self.quantity} of {self.stock_code}"

    class Meta:
        db_table = 'tb_positions'
        verbose_name = '持仓信息'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\stock_info.py####
from django.db import models
from django.utils import timezone

class StockInfo(models.Model):
    """
    1.1. 股票基础信息表 (tb_stock_info)
    说明: 存储所有A股股票的基本信息，如代码、名称、上市日期等，作为其他数据表的关联基础。
    """
    class StatusChoices(models.TextChoices):
        LISTING = 'listing', '上市'
        DELISTED = 'delisted', '退市'
        SUSPENDED = 'suspended', '停牌'

    stock_code = models.CharField(
        max_length=50, 
        primary_key=True, 
        help_text="股票代码, 格式如 'sh.600000'"
    )
    stock_name = models.CharField(
        max_length=50, 
        help_text="股票名称"
    )
    listing_date = models.DateField(
        help_text="上市日期, 用于剔除次新股"
    )
    status = models.CharField(
        max_length=20, 
        choices=StatusChoices.choices,
        help_text="股票状态。枚举: listing(上市), delisted(退市), suspended(停牌)"
    )
    created_at = models.DateTimeField(
        default=timezone.now, 
        editable=False,
        help_text="记录创建时间"
    )
    updated_at = models.DateTimeField(
        auto_now=True,
        help_text="记录更新时间"
    )

    def __str__(self):
        return f"{self.stock_name}({self.stock_code})"

    class Meta:
        db_table = 'tb_stock_info'
        verbose_name = '股票基础信息'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\strategy_parameters.py####
from django.db import models

class StrategyParameters(models.Model):
    """
    2.3. 策略参数表 (tb_strategy_parameters)
    说明: 存储所有策略中可优化的参数，如权重、系数等，方便回测与优化模块进行读取和修改。
    """
    param_name = models.CharField(
        max_length=50, 
        primary_key=True, 
        help_text="参数唯一英文名, 如 'w_trend', 'k_h1'"
    )
    param_value = models.DecimalField(
        max_digits=20, 
        decimal_places=10, 
        help_text="参数的数值"
    )
    group_name = models.CharField(
        max_length=50, 
        blank=True, 
        null=True, 
        help_text="参数所属分组, 如 'WEIGHTS', 'STOP_LOSS'"
    )
    description = models.TextField(
        blank=True, 
        null=True, 
        help_text="参数的详细说明"
    )

    def __str__(self):
        return f"{self.param_name} = {self.param_value}"

    class Meta:
        db_table = 'tb_strategy_parameters'
        verbose_name = '策略参数'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\system_log.py####
from django.db import models
from django.utils import timezone

class SystemLog(models.Model):
    """
    4.1. 系统日志表 (tb_system_log)
    说明: 记录系统运行过程中的关键信息、警告和错误，便于监控和调试。
    """
    class LogLevelChoices(models.TextChoices):
        INFO = 'INFO', 'INFO'
        WARNING = 'WARNING', 'WARNING'
        ERROR = 'ERROR', 'ERROR'
        CRITICAL = 'CRITICAL', 'CRITICAL'

    log_id = models.BigAutoField(
        primary_key=True, 
        help_text="日志唯一ID"
    )
    log_time = models.DateTimeField(
        default=timezone.now, 
        editable=False,
        help_text="日志记录时间"
    )
    log_level = models.CharField(
        max_length=10, 
        choices=LogLevelChoices.choices,
        help_text="日志级别。枚举: INFO, WARNING, ERROR, CRITICAL"
    )
    module_name = models.CharField(
        max_length=50, 
        blank=True, 
        null=True,
        help_text="产生日志的模块名, 如 '日终选股', '开盘决策'"
    )
    message = models.TextField(
        help_text="日志内容, 如 '无合适买点', '下单API请求失败'"
    )

    def __str__(self):
        return f"[{self.log_time.strftime('%Y-%m-%d %H:%M:%S')}] [{self.log_level}] {self.message[:80]}"

    class Meta:
        db_table = 'tb_system_log'
        verbose_name = '系统日志'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\trade_log.py####
from django.db import models
from .stock_info import StockInfo

class TradeLog(models.Model):
    """
    3.3. 交易记录表 (tb_trade_log)
    说明: 记录每一次买入和卖出的详细信息，用于成本核算、业绩分析和问题排查。
    """
    class TradeTypeChoices(models.TextChoices):
        BUY = 'buy', '买入'
        SELL = 'sell', '卖出'

    class OrderTypeChoices(models.TextChoices):
        LIMIT = 'limit', '限价'
        MARKET = 'market', '市价'

    class ReasonChoices(models.TextChoices):
        ENTRY = 'entry', '策略入场'
        TAKE_PROFIT = 'take_profit', '止盈'
        STOP_LOSS = 'stop_loss', '止损'
        MANUAL = 'manual', '人工干预'

    class StatusChoices(models.TextChoices):
        FILLED = 'filled', '已成交'
        FAILED = 'failed', '失败'
        CANCELLED = 'cancelled', '已撤销'
        PENDING = 'pending','待执行'

    trade_id = models.BigAutoField(
        primary_key=True, 
        help_text="交易唯一ID"
    )
    # 注意：这里使用字符串 'positions.Position' 来避免循环导入问题
    # related_name='trade_logs' 允许从 Position 对象反向访问其所有交易记录
    position = models.ForeignKey(
        'Position', 
        on_delete=models.CASCADE, # 如果持仓被删除，关联的交易记录也应删除
        related_name='trade_logs',
        help_text="关联的持仓ID (买入时生成, 卖出时引用)"
    )
    stock_code = models.ForeignKey(
        StockInfo, 
        on_delete=models.PROTECT,
        db_column='stock_code',
        help_text="股票代码"
    )
    trade_datetime = models.DateTimeField(
        help_text="交易成交时间"
    )
    trade_type = models.CharField(
        max_length=10, 
        choices=TradeTypeChoices.choices,
        help_text="交易类型。枚举: buy(买入), sell(卖出)"
    )
    order_type = models.CharField(
        max_length=10, 
        choices=OrderTypeChoices.choices,
        help_text="订单类型。枚举: limit(限价), market(市价)"
    )
    price = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="成交均价"
    )
    quantity = models.BigIntegerField(
        help_text="成交数量"
    )
    commission = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="佣金"
    )
    stamp_duty = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        default=0,
        help_text="印花税 (仅卖出时有)"
    )
    reason = models.CharField(
        max_length=50, 
        choices=ReasonChoices.choices, 
        blank=True, 
        null=True,
        help_text="交易原因。枚举: entry(策略入场), take_profit(止盈), stop_loss(止损), manual(人工干预)"
    )
    status = models.CharField(
        max_length=20, 
        choices=StatusChoices.choices,
        help_text="订单状态。枚举: filled(已成交), failed(失败), cancelled(已撤销),pending(待执行)"
    )

    external_order_id = models.CharField(
        max_length=50, 
        null=True, 
        blank=True, 
        db_index=True,
        help_text="外部交易系统的订单ID，如券商的委托编号"
    )

    def __str__(self):
        return f"Trade {self.trade_id}: {self.trade_type.upper()} {self.quantity} of {self.stock_code}"

    class Meta:
        db_table = 'tb_trade_log'
        verbose_name = '交易记录'
        verbose_name_plural = verbose_name

####文件结束####

####data_manager\__init__.py####

####文件结束####

####data_manager\admin.py####
from django.contrib import admin

# Register your models here.

####文件结束####

####data_manager\apps.py####
from django.apps import AppConfig


class DataManagerConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'data_manager'

####文件结束####

####data_manager\models.py####
from django.db import models

# Create your models here.

####文件结束####

####data_manager\tests.py####
from django.test import TestCase

# Create your tests here.

####文件结束####

####data_manager\urls.py####
"""
URL configuration for autoTrade project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path,include
from . import views
urlpatterns = [
    path('test', views.test_get),
    path('updateLocalStock', views.update_local_a_shares),
    path('syncCorporateActions', views.sync_corporate_actions),
    path('sendEmail', views.email_send),
    path('updateCSI300', views.update_csi300_index_data)
]

####文件结束####

####data_manager\views.py####
from django.http.response import JsonResponse
from django.shortcuts import render
from common.models import StockInfo
from data_manager.service.stock_service import StockService
from data_manager.service.corporate_action_service import CorporateActionService
from data_manager.service.email_service import EmailNotificationService
from django.views.decorators.http import require_http_methods
import json
from datetime import date,datetime
# Create your views here.
def test_get(request):
    result={}
    if request.method=='GET':
        result=  {'method':'get'}
    if request.method=='POST':
        result= {'methods':'post'}
    # service=StockService()
    # service.clear_all_data()
    # service.update_local_a_shares(start_date="2025-01-01",end_date="2025-08-04")
    # service.update_local_a_shares(start_date="2024-01-01",end_date="2024-12-31")
    # service.update_local_a_shares(start_date="2023-01-01",end_date="2023-12-31")
    # service.update_local_a_shares(start_date="2022-01-01",end_date="2022-12-31")
    # service.update_local_a_shares(start_date="2021-01-01",end_date="2021-12-31")
    return JsonResponse(result)

@require_http_methods(["POST"])
def update_local_a_shares(request):
    body= json.loads(request.body)
    service=StockService()
    service.update_local_a_shares(stock_codes=body['stockCodes'],start_date=body['startDate'],end_date=body['endDate'])
    return JsonResponse({"result":"success"})

@require_http_methods(["POST"])
def sync_corporate_actions(request):
    body= json.loads(request.body)
    service=CorporateActionService()
    service.sync_corporate_actions(start_date=body['startDate'],end_date=body['endDate'])
    return JsonResponse({"result":"success"})

@require_http_methods(["POST"])
def email_send(request):
    body= json.loads(request.body)
    service=EmailNotificationService(t_day=datetime.strptime(body['date'], "%Y-%m-%d").date())
    service.runEmailSend()
    return JsonResponse({"result":"success"})

def update_csi300_index_data(request):
    body= json.loads(request.body)
    service=StockService()
    service.update_csi300_index_data(start_date=body['startDate'],end_date=body['endDate'])
    return JsonResponse({"result":"success"})
####文件结束####

####data_manager\management\commands\backfill_csi300_data.py####
# data_manager/management/commands/backfill_csi300_data.py
import logging
import time
from datetime import date, timedelta
import pandas as pd
import akshare as ak
from django.core.management.base import BaseCommand, CommandParser
from django.db import transaction
from decimal import Decimal

from common.models.index_quotes_csi300 import IndexQuotesCsi300

logger = logging.getLogger(__name__)

class Command(BaseCommand):
    help = '一次性回填沪深300指数的历史日线数据。'

    def add_arguments(self, parser: CommandParser):
        parser.add_argument(
            '--years',
            type=int,
            default=15,
            help='要回填的历史数据年数，默认为15年。'
        )

    def handle(self, *args, **options):
        years_to_backfill = options['years']
        end_date = date.today()
        start_date = end_date - timedelta(days=years_to_backfill * 365)

        self.stdout.write(self.style.SUCCESS(f"===== 开始回填沪深300指数历史数据 ====="))
        self.stdout.write(f"数据范围: {start_date.strftime('%Y%m%d')} to {end_date.strftime('%Y%m%d')}")

        try:
            # 1. 拉取数据
            self.stdout.write("正在从akshare获取数据...")
            df = ak.index_zh_a_hist(
                symbol="000300",
                period="daily",
                start_date=start_date.strftime('%Y%m%d'),
                end_date=end_date.strftime('%Y%m%d')
            )
            self.stdout.write(f"成功获取 {len(df)} 条数据。")

            if df.empty:
                self.stdout.write(self.style.WARNING("未获取到任何数据，任务终止。"))
                return

            # 2. 数据清洗和转换
            df.rename(columns={
                '日期': 'trade_date', '开盘': 'open', '收盘': 'close', '最高': 'high', '最低': 'low',
                '成交量': 'volume', '成交额': 'amount', '振幅': 'amplitude',
                '涨跌幅': 'pct_change', '涨跌额': 'change_amount', '换手率': 'turnover_rate'
            }, inplace=True)
            
            # 成交量从“手”转换为“股”
            df['volume'] = df['volume'] * 100
            df['turnover_rate'] = pd.to_numeric(df['turnover_rate'], errors='coerce')


            # 3. 批量入库
            records_to_create = []
            for _, row in df.iterrows():
                records_to_create.append(
                    IndexQuotesCsi300(
                        trade_date=row['trade_date'],
                        open=Decimal(str(row['open'])),
                        close=Decimal(str(row['close'])),
                        high=Decimal(str(row['high'])),
                        low=Decimal(str(row['low'])),
                        volume=int(row['volume']),
                        amount=Decimal(str(row['amount'])),
                        amplitude=Decimal(str(row['amplitude'])),
                        pct_change=Decimal(str(row['pct_change'])),
                        change_amount=Decimal(str(row['change_amount'])),
                        turnover_rate=Decimal(str(row['turnover_rate'])) if pd.notna(row['turnover_rate']) else None
                    )
                )
            
            self.stdout.write("正在将数据写入数据库 (update_or_create)...")
            # with transaction.atomic():
            #     for record in records_to_create:
            #         IndexQuotesCsi300.objects.update_or_create(
            #             trade_date=record.trade_date,
            #             defaults={
            #                 'open': record.open, 'close': record.close, 'high': record.high, 'low': record.low,
            #                 'volume': record.volume, 'amount': record.amount, 'amplitude': record.amplitude,
            #                 'pct_change': record.pct_change, 'change_amount': record.change_amount,
            #                 'turnover_rate': record.turnover_rate
            #             }
            #         )
            # 【用这段代码替换上面删除的部分】
            self.stdout.write("正在将数据批量写入数据库...")
            # 定义需要更新的字段列表
            update_fields = [
                'open', 'close', 'high', 'low', 'volume', 'amount', 
                'amplitude', 'pct_change', 'change_amount', 'turnover_rate'
            ]
            # 使用 bulk_create 进行批量“更新或创建”
            IndexQuotesCsi300.objects.bulk_create(
                records_to_create,
                batch_size=10000,  # 推荐设置批次大小，防止内存占用过高
                update_conflicts=True,
                unique_fields=['trade_date'],  # 冲突判断的唯一键
                update_fields=update_fields  # 发生冲突时需要更新的字段
            )
            
            self.stdout.write(self.style.SUCCESS("===== 沪深300数据回填成功！ ====="))

        except Exception as e:
            self.stdout.write(self.style.ERROR(f"回填过程中发生错误: {e}"))
            logger.error("回填沪深300数据失败", exc_info=True)

####文件结束####

####data_manager\management\commands\calibrate_m_value_anchors.py####
# data_manager/management/commands/calibrate_m_value_anchors.py
import logging
import pandas as pd
from django.core.management.base import BaseCommand, CommandParser
from django.db import transaction
from decimal import Decimal

from common.models import IndexQuotesCsi300, StrategyParameters

logger = logging.getLogger(__name__)

class Command(BaseCommand):
    help = '一次性校准M值计算所需的固定分位锚点参数。'

    def add_arguments(self, parser: CommandParser):
        parser.add_argument(
            '--start-date',
            type=str,
            default=None,  # 或者设置为 None
            help='用于校准的起始日期 (格式: YYYY-MM-DD)。'
        )
        parser.add_argument(
            '--end-date',
            type=str,
            default=None,  # 或者设置为 None
            help='用于校准的截止日期 (格式: YYYY-MM-DD)。'
        )

    def handle(self, *args, **options):
        self.stdout.write(self.style.SUCCESS("===== 开始校准M值固定分位锚点 ====="))
        
        # 1. 加载数据
        # df = pd.DataFrame.from_records(IndexQuotesCsi300.objects.all().values())
        start_date = options['start_date']
        end_date = options['end_date']
        queryset = IndexQuotesCsi300.objects.all()
        if start_date:
            queryset = queryset.filter(trade_date__gte=start_date)
        if end_date:
            queryset = queryset.filter(trade_date__lte=end_date)
        # 可以在这里加一句日志，方便确认
        self.stdout.write(f"使用数据范围: 从 {start_date or '最早'} 到 {end_date or '最新'}")
        df = pd.DataFrame.from_records(queryset.values())
        if df.empty:
            self.stdout.write(self.style.ERROR("数据库中没有沪深300指数数据，请先执行 backfill_csi300_data。"))
            return
        
        df.set_index('trade_date', inplace=True)
        df.sort_index(inplace=True)
        columns_to_convert = ['open', 'high', 'low', 'close', 'turnover_rate']
        for col in columns_to_convert:
            df[col] = pd.to_numeric(df[col], errors='coerce')
        # 2. 计算四个基础指标的完整历史序列
        self.stdout.write("正在计算基础指标的历史序列...")
        df['ma60'] = df['close'].rolling(60).mean()
        df['m1_trend'] = (df['close'] - df['ma60']) / df['ma60']
        df['m2_momentum'] = df['close'].pct_change(20)
        df['daily_return'] = df['close'].pct_change()
        df['m3_volatility'] = df['daily_return'].rolling(20).std()
        avg_turnover_20 = df['turnover_rate'].rolling(20).mean()
        avg_turnover_60 = df['turnover_rate'].rolling(60).mean()
        df['m4_turnover'] = avg_turnover_20 / avg_turnover_60
        
        indicators_df = df[['m1_trend', 'm2_momentum', 'm3_volatility', 'm4_turnover']].dropna()
        self.stdout.write(f"指标历史计算完成，有效数据点: {len(indicators_df)}。")

        # 3. 计算分位锚点并准备参数
        params_to_update = {}
        quantiles = [0.10, 0.50, 0.90]
        indicator_map = {
            'm1_trend': 'trend',
            'm2_momentum': 'momentum',
            'm3_volatility': 'volatility',
            'm4_turnover': 'turnover'
        }

        for col, name in indicator_map.items():
            percentiles = indicators_df[col].quantile(quantiles)
            for q in quantiles:
                param_name = f"dynamic_m_csi300_anchor_{name}_p{int(q*100)}"
                param_value = Decimal(str(percentiles[q]))
                params_to_update[param_name] = param_value
                self.stdout.write(f"计算出锚点: {param_name} = {param_value:.4f}")

        # 4. 写入数据库
        self.stdout.write("正在将锚点参数写入数据库...")
        with transaction.atomic():
            for name, value in params_to_update.items():
                StrategyParameters.objects.update_or_create(
                    param_name=name,
                    defaults={
                        'param_value': value,
                        'group_name': 'M_CSI300_ANCHORS',
                        'description': f'沪深300的M值计算-指标{name.split("_p")[0].split("_")[-1]}-锚点P{name.split("_p")[-1]}'
                    }
                )
        
        self.stdout.write(self.style.SUCCESS(f"===== 成功更新 {len(params_to_update)} 个锚点参数！ ====="))

####文件结束####

####data_manager\management\commands\full_update_stocks.py####
# data_manager/management/commands/full_update_stocks.py

from django.core.management.base import BaseCommand
from data_manager.service.stock_service import StockService
from selection_manager.service.selection_service import SelectionService
import time
from datetime import date,datetime
class Command(BaseCommand):
    help = '清空并重新获取过去五年的全部A股数据'

    def handle(self, *args, **options):
        total_start_time = time.time()
        self.stdout.write(self.style.SUCCESS('===== 开始执行全量数据更新任务 ====='))
        
        service = StockService()
        
        # 1. 清空所有旧数据
        self.stdout.write('正在清空所有历史数据...')
        #service.clear_all_data()
        self.stdout.write(self.style.SUCCESS('历史数据已清空。'))
        
        # 2. 按年份顺序获取数据
        #service.clear_all_data()
        service.update_local_a_shares(start_date="2025-08-06",end_date="2025-08-08")
        service.update_local_a_shares(start_date="2018-01-01",end_date="2019-12-31")
        # service.update_local_a_shares(start_date="2023-01-01",end_date="2023-12-31")
        # service.update_local_a_shares(start_date="2022-01-01",end_date="2022-12-31")
        # service.update_local_a_shares(start_date="2021-01-01",end_date="2021-12-31")
        total_end_time = time.time()
        self.stdout.write(self.style.SUCCESS(f'\n===== 所有年份数据更新完毕！总耗时: {(total_end_time - total_start_time) / 3600:.2f} 小时 ====='))
        self.stdout.write('开始预热M值...')
        service=SelectionService(datetime.strptime('2025-08-08', "%Y-%m-%d").date())
        service.run_selection()
        total_end_time_2 = time.time()

####文件结束####

####data_manager\management\commands\migrate_to_pg.py####
# data_manager/management/commands/migrate_to_pg.py

from django.core.management.base import BaseCommand
from data_manager.service.db_service import DbMigrationService

class Command(BaseCommand):
    help = '将整个SQLite数据库的结构和数据迁移到PostgreSQL'

    def handle(self, *args, **options):
        self.stdout.write(self.style.SUCCESS('开始执行数据库迁移任务...'))
        
        try:
            service = DbMigrationService()
            service.migrate()
            self.stdout.write(self.style.SUCCESS('数据库迁移任务已成功完成。'))
        except Exception as e:
            self.stdout.write(self.style.ERROR(f'数据库迁移失败: {e}'))


####文件结束####

####data_manager\management\commands\reset_sequences.py####
# data_manager/management/commands/reset_sequences.py (V2 - 修正版)
import logging
from django.core.management.base import BaseCommand
from django.db import connection, models
from django.apps import apps

logger = logging.getLogger(__name__)

class Command(BaseCommand):
    help = 'Resets PostgreSQL sequences for integer AutoFields to the max value of their primary key columns.'

    def handle(self, *args, **options):
        self.stdout.write(self.style.SUCCESS('===== 开始智能重置数据库序列 (仅处理自增整数主键) ====='))
        
        all_models = apps.get_models()
        
        with connection.cursor() as cursor:
            for model in all_models:
                table_name = model._meta.db_table
                pk_field = model._meta.pk
                
                # --- 核心修正：增加类型检查 ---
                # 1. 检查主键是否存在且是否为自增字段
                if not pk_field or not isinstance(pk_field, models.AutoField):
                    self.stdout.write(f'正在处理表: {table_name} ... ' + self.style.WARNING('跳过 (主键非自增整数)'))
                    continue

                # 2. 如果是自增字段，其内部类型一定是整数，可以安全处理
                pk_name = pk_field.name
                sequence_name = f"{table_name}_{pk_name}_seq"
                
                self.stdout.write(f'正在处理表: {table_name} (序列: {sequence_name}) ... ', ending='')
                
                try:
                    # SQL to get the max PK value.
                    # COALESCE is still useful for empty tables.
                    # The third argument 'false' in setval means the next value will be max_id + 1
                    # No change needed here as we've already filtered for integer PKs.
                    sql = f"""
                    SELECT setval('"{sequence_name}"', (SELECT COALESCE(MAX("{pk_name}"), 1) FROM "{table_name}"), false);
                    """
                    cursor.execute(sql)
                    self.stdout.write(self.style.SUCCESS('OK'))
                except Exception as e:
                    # 捕获其他可能的错误，例如序列真的不存在
                    if "does not exist" in str(e):
                        self.stdout.write(self.style.WARNING(f'跳过 (序列不存在)'))
                    else:
                        self.stdout.write(self.style.ERROR(f'失败: {e}'))
                        logger.error(f"重置序列 {sequence_name} 失败: {e}", exc_info=True)

        self.stdout.write(self.style.SUCCESS('\n===== 数据库序列智能重置完毕 ====='))

####文件结束####

####data_manager\service\corporate_action_service.py####
import logging
import time
from datetime import datetime

import akshare
import pandas as pd
from django.db import transaction

# 导入您的 Django models
# 请根据您的项目结构调整以下导入路径
from common.models.corporate_action import CorporateAction
from common.models.stock_info import StockInfo

# 配置日志记录器
logger = logging.getLogger(__name__)
class CorporateActionService:
    def _fetch_and_save_split_events(self,stock_codes_filter: list, start_date: str, end_date: str):
        """
        预留的拆股/并股事件处理函数。
        """
        # logger.info(f"正在检查拆股/并股事件 (当前版本暂未实现)...")
        pass

    def sync_corporate_actions(self,start_date: str, end_date: str, stock_codes: list = None):
        """
        从 Akshare 高效同步指定日期范围和股票范围的股权事件数据，并存入数据库。
        """
        logger.info(f"开始同步股权事件，日期范围: {start_date} to {end_date}。")
        if stock_codes:
            logger.info(f"目标股票: {len(stock_codes)} 只。")
        else:
            logger.info("目标股票: 全部A股。")

        # 1. 任务开始前，一次性清理数据
        try:
            with transaction.atomic():
                qs = CorporateAction.objects.filter(
                    ex_dividend_date__gte=start_date,
                    ex_dividend_date__lte=end_date
                )
                if stock_codes:
                    qs = qs.filter(stock_code__in=stock_codes)
                
                deleted_count, _ = qs.delete()
                logger.info(f"数据清理完成。在 {start_date} 到 {end_date} 范围内共删除 {deleted_count} 条旧记录。")
        except Exception as e:
            logger.error(f"清理历史数据时发生严重错误，任务终止: {e}", exc_info=True)
            return

        all_stocks_map = {s.split('.')[-1]: s for s in StockInfo.objects.values_list('stock_code', flat=True)}
        ak_codes_filter = [c.split('.')[-1] for c in stock_codes] if stock_codes else None

        # 2. 处理分红、送股、转股 (stock_fhps_em)
        try:
            logger.info("开始处理分红、送股、转股事件...")
            fhps_dfs = []
            start_year = datetime.strptime(start_date, '%Y-%m-%d').year
            end_year = datetime.strptime(end_date, '%Y-%m-%d').year
            
            # ★★★★★ 优化点：使用更精确的年份范围，覆盖跨年预案 ★★★★★
            report_suffixes = ["0331", "0630", "0930", "1231"]
            for year in range(start_year - 1, end_year + 1):
                for suffix in report_suffixes:
                    report_date = f"{year}{suffix}"
                    logger.info(f"正在拉取报告期 {report_date} 的分红送配预案...")
                    try:
                        time.sleep(1)
                        fhps_df = akshare.stock_fhps_em(date=report_date)
                        if not fhps_df.empty:
                            fhps_dfs.append(fhps_df)
                    except Exception as e:
                        logger.warning(f"拉取报告期 {report_date} 数据失败或无数据: {e}")
            
            if fhps_dfs:
                # 使用 '代码' 和 '除权除息日' 作为联合主键去重，防止同一事件因在不同报告期披露而重复
                all_fhps_df = pd.concat(fhps_dfs, ignore_index=True).drop_duplicates(subset=['代码', '除权除息日'])
                
                all_fhps_df['除权除息日'] = pd.to_datetime(all_fhps_df['除权除息日'], errors='coerce')
                all_fhps_df.dropna(subset=['除权除息日'], inplace=True)
                
                mask = (all_fhps_df['除权除息日'] >= pd.to_datetime(start_date)) & (all_fhps_df['除权除息日'] <= pd.to_datetime(end_date))
                filtered_fhps_df = all_fhps_df[mask].copy()

                if ak_codes_filter:
                    filtered_fhps_df = filtered_fhps_df[filtered_fhps_df['代码'].isin(ak_codes_filter)]

                logger.info(f"共获取到 {len(filtered_fhps_df)} 条符合条件的分红送转记录，准备入库...")

                with transaction.atomic():
                    for _, row in filtered_fhps_df.iterrows():
                        ak_code = row['代码']
                        stock_code_prefixed = all_stocks_map.get(ak_code)
                        if not stock_code_prefixed:
                            continue

                        # 分红
                        if pd.notna(row['现金分红-现金分红比例']) and row['现金分红-现金分红比例'] > 0:
                            CorporateAction.objects.create(
                                stock_code=stock_code_prefixed,
                                ex_dividend_date=row['除权除息日'].date(),
                                record_date=pd.to_datetime(row['股权登记日'], errors='coerce').date() if pd.notna(row['股权登记日']) else None,
                                notice_date=pd.to_datetime(row['最新公告日期'], errors='coerce').date() if pd.notna(row['最新公告日期']) else None,
                                event_type=CorporateAction.EventType.DIVIDEND,
                                dividend_per_share=row['现金分红-现金分红比例'] / 10
                            )

                        # 送股
                        if pd.notna(row['送转股份-送转比例']) and row['送转股份-送转比例'] > 0:
                            CorporateAction.objects.create(
                                stock_code=stock_code_prefixed,
                                ex_dividend_date=row['除权除息日'].date(),
                                record_date=pd.to_datetime(row['股权登记日'], errors='coerce').date() if pd.notna(row['股权登记日']) else None,
                                notice_date=pd.to_datetime(row['最新公告日期'], errors='coerce').date() if pd.notna(row['最新公告日期']) else None,
                                event_type=CorporateAction.EventType.BONUS,
                                shares_before=10,
                                shares_after=10 + row['送转股份-送转比例']
                            )

                        # 转股
                        if pd.notna(row['送转股份-转股比例']) and row['送转股份-转股比例'] > 0:
                            CorporateAction.objects.create(
                                stock_code=stock_code_prefixed,
                                ex_dividend_date=row['除权除息日'].date(),
                                record_date=pd.to_datetime(row['股权登记日'], errors='coerce').date() if pd.notna(row['股权登记日']) else None,
                                notice_date=pd.to_datetime(row['最新公告日期'], errors='coerce').date() if pd.notna(row['最新公告日期']) else None,
                                event_type=CorporateAction.EventType.TRANSFER,
                                shares_before=10,
                                shares_after=10 + row['送转股份-转股比例']
                            )
            logger.info("分红、送股、转股事件处理完成。")
        except Exception as e:
            logger.error(f"处理分红送转数据时发生严重错误: {e}", exc_info=True)

        # 3. 处理配股 (stock_pg_em)
        try:
            logger.info("开始处理配股事件...")
            time.sleep(1)
            all_pg_df = akshare.stock_pg_em()
            
            # Akshare 返回的 '股权登记日' 可能包含无效日期，需要处理
            all_pg_df['股权登记日'] = pd.to_datetime(all_pg_df['股权登记日'], errors='coerce')
            all_pg_df.dropna(subset=['股权登记日'], inplace=True)
 
            mask = (all_pg_df['股权登记日'] >= pd.to_datetime(start_date)) & (all_pg_df['股权登记日'] <= pd.to_datetime(end_date))
            filtered_pg_df = all_pg_df[mask].copy()
 
            if ak_codes_filter:
                filtered_pg_df = filtered_pg_df[filtered_pg_df['股票代码'].isin(ak_codes_filter)]
            
            logger.info(f"共获取到 {len(filtered_pg_df)} 条符合条件的配股记录，准备入库...")
 
            with transaction.atomic():
                for _, row in filtered_pg_df.iterrows():
                    ak_code = row['股票代码']
                    stock_code_prefixed = all_stocks_map.get(ak_code)
                    if not stock_code_prefixed:
                        continue
 
                    # --- 修改开始 ---
                    # 从 '10配3.0' 这样的字符串中解析出配股比例数值
                    rights_ratio_val = 0
                    rights_ratio_str = row['配股比例']
                    
                    # 确保 '配股比例' 是一个有效的、可解析的字符串
                    if pd.notna(rights_ratio_str) and isinstance(rights_ratio_str, str) and '配' in rights_ratio_str:
                        try:
                            # 按 '配' 分割，取后面的部分，并转换为浮点数
                            ratio_str_part = rights_ratio_str.split('配')[1]
                            rights_ratio_val = float(ratio_str_part)
                        except (IndexError, ValueError) as e:
                            logger.warning(f"无法解析股票 {ak_code} 的配股比例 '{rights_ratio_str}'，已跳过。错误: {e}")
                            continue # 跳过此条记录
 
                    if rights_ratio_val > 0:
                        CorporateAction.objects.create(
                            stock_code=stock_code_prefixed,
                            # 注意：配股通常使用 '股权登记日' 作为关键日期，'除权日' 在此接口中可能不提供
                            ex_dividend_date=row['股权登记日'].date(), 
                            record_date=row['股权登记日'].date(),
                            notice_date=None, # akshare.stock_pg_em() 未提供公告日期
                            event_type=CorporateAction.EventType.RIGHTS,
                            shares_before=10, # 配股基准通常是10股
                            shares_after=10 + rights_ratio_val, # 使用解析后的数值
                            rights_issue_price=row['配股价']
                        )
                    # --- 修改结束 ---
 
            logger.info("配股事件处理完成。")
        except KeyError as e:
            # 捕获 '配股比例' 等字段不存在的错误
            logger.error(f"处理配股数据时发生字段缺失错误: {e}。请检查 Akshare 返回的数据列名是否已变更。", exc_info=True)
        except Exception as e:
            logger.error(f"处理配股数据时发生严重错误: {e}", exc_info=True)

        # 4. 调用预留的拆股/并股处理函数
        self._fetch_and_save_split_events(stock_codes, start_date, end_date)

        logger.info("所有股权事件同步任务已全部完成。")

####文件结束####

####data_manager\service\db_service.py####
# data_manager/service/db_service.py

import logging
import time
import pandas as pd
from sqlalchemy import create_engine, text
from django.apps import apps
from django.db import connections
from django.conf import settings
from collections import deque

logger = logging.getLogger(__name__)

class DbMigrationService:
    """
    一个健壮的服务，用于将数据从源数据库（SQLite）迁移到目标数据库（PostgreSQL）。
    它能自动处理表依赖关系，并使用分块读写来处理大数据表。
    """
    def __init__(self):
        # 从 Django settings 获取目标数据库配置
        pg_config = settings.DATABASES['default']
        self.pg_uri = f"postgresql+psycopg2://{pg_config['USER']}:{pg_config['PASSWORD']}@{pg_config['HOST']}:{pg_config['PORT']}/{pg_config['NAME']}"
        
        # 源数据库路径
        sqlite_path = settings.BASE_DIR / 'mainDB.sqlite3'
        self.sqlite_uri = f"sqlite:///{sqlite_path}"
        
        self.chunk_size = 50000  # 每次处理5万行，防止内存溢出

    def _get_migration_order(self) -> list:
        """
        通过拓扑排序分析 Django 模型之间的依赖关系，生成正确的迁移顺序。
        父表（被外键引用的表）会排在子表（有外键的表）前面。
        """
        all_models = apps.get_models()
        model_map = {model: model._meta.db_table for model in all_models}
        
        # 构建依赖图和入度计数
        dependencies = {model: set() for model in all_models}
        in_degree = {model: 0 for model in all_models}

        for model in all_models:
            for field in model._meta.get_fields():
                if field.is_relation and field.many_to_one and field.related_model in model_map:
                    # 如果 model 依赖于 related_model
                    related_model = field.related_model
                    if model in dependencies[related_model]:
                        continue
                    dependencies[related_model].add(model)
                    in_degree[model] += 1
        
        # 拓扑排序
        queue = deque([model for model in all_models if in_degree[model] == 0])
        sorted_models = []
        
        while queue:
            model = queue.popleft()
            sorted_models.append(model)
            
            for dependent_model in dependencies[model]:
                in_degree[dependent_model] -= 1
                if in_degree[dependent_model] == 0:
                    queue.append(dependent_model)

        if len(sorted_models) != len(all_models):
            raise Exception("数据库模型存在循环依赖，无法进行拓扑排序！")
            
        logger.info(f"计算出模型迁移顺序: {[model._meta.db_table for model in sorted_models]}")
        return sorted_models

    def migrate(self):
        """
        执行完整的数据库迁移流程。
        """
        logger.info("===== 开始数据库迁移：SQLite -> PostgreSQL =====")
        start_total_time = time.time()

        try:
            migration_order = self._get_migration_order()
            
            source_engine = create_engine(self.sqlite_uri)
            target_engine = create_engine(self.pg_uri)

            with target_engine.connect() as pg_conn:
                for model in migration_order:
                    if not(model._meta.db_table =='tb_daily_factor_values' or model._meta.db_table =='tb_daily_trading_plan' or model._meta.db_table =='tb_trade_log'):
                        logger.info(f"跳过表 {model}")
                        continue
                    else:
                        logger.info(f"执行表 {model}")
                    table_name = model._meta.db_table
                    logger.info(f"--- 正在迁移表: {table_name} ---")
                    start_table_time = time.time()

                    try:
                        # 1. 清空目标表并重置自增ID，保证幂等性
                        logger.info(f"清空目标表 {table_name}...")
                        # 使用 text() 来确保SQL语句被正确处理
                        truncate_sql = text(f'TRUNCATE TABLE public."{table_name}" RESTART IDENTITY CASCADE;')
                        pg_conn.execute(truncate_sql)
                        pg_conn.commit() # TRUNCATE 需要显式提交

                        # 2. 分块读取源数据并写入目标库
                        query = f'SELECT * FROM "{table_name}";'
                        total_rows = 0
                        for chunk_df in pd.read_sql_query(query, source_engine, chunksize=self.chunk_size):
                            
                            # 修正数据类型问题：Pandas有时会将bool转为int，需要转回来
                            for col in chunk_df.columns:
                                model_field = model._meta.get_field(col)
                                if model_field.get_internal_type() == 'BooleanField':
                                    chunk_df[col] = chunk_df[col].astype(bool)

                            chunk_df.to_sql(
                                name=table_name,
                                con=target_engine,
                                if_exists='append',
                                index=False,
                                method='multi',
                                schema='public' # 显式指定 schema
                            )
                            total_rows += len(chunk_df)
                            logger.info(f"已迁移 {total_rows} 行...")
                        
                        table_duration = time.time() - start_table_time
                        logger.info(f"表 {table_name} 迁移完成，共 {total_rows} 行，耗时 {table_duration:.2f} 秒。")

                    except Exception as e:
                        logger.error(f"迁移表 {table_name} 时发生错误: {e}", exc_info=True)
                        pg_conn.rollback() # 如果出错则回滚
                        raise  # 重新抛出异常，中断整个迁移过程

        except Exception as e:
            logger.critical(f"数据库迁移过程中发生严重错误，任务终止: {e}", exc_info=True)
            return

        total_duration = time.time() - start_total_time
        logger.info(f"===== 数据库迁移成功完成！总耗时: {total_duration:.2f} 秒 =====")


####文件结束####

####data_manager\service\email_handler.py####
# data_manager/service/email_handler.py

import smtplib
import logging
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.header import Header

logger = logging.getLogger(__name__)

class EmailHandler:
    """
    一个通用的邮件发送处理器。
    它封装了SMTP协议的细节，只向上层提供一个简单的send_email接口。
    所有配置项都在类的起始区域定义，方便统一管理。
    """

    # ==========================================================================
    # SMTP 配置区域 - 请根据您的邮箱服务商填充以下信息
    # 强烈建议在生产环境中使用环境变量或安全的配置管理方式，而非硬编码
    # 对于多数邮箱，您可能需要使用“应用专用密码”而非您的登录密码
    # ==========================================================================
    SMTP_SERVER = 'smtp.qq.com'  # 例如: 'smtp.qq.com' 或 'smtp.gmail.com'
    SMTP_PORT = 465                   # SSL加密端口通常为 465
    SMTP_USER = '876858298@qq.com' # 您的邮箱登录账号
    SMTP_PASSWORD = 'eoyktuuifrmxbdba'  # 您的邮箱授权码或密码
    SENDER_EMAIL = '876858298@qq.com' # 发件人邮箱地址
    SENDER_NAME = '量化交易预案推送'          # 发件人显示名称
    # ==========================================================================

    def send_email(self, recipients: list[str], subject: str, html_content: str) -> bool:
        """
        发送一封HTML格式的邮件给一个或多个收件人。

        :param recipients: 目标邮箱地址的列表, e.g., ['user1@example.com', 'user2@example.com']
        :param subject: 邮件主题
        :param html_content: 邮件正文 (HTML格式)
        :return: True 如果发送成功, False 如果失败
        """
        if not all([self.SMTP_SERVER, self.SMTP_PORT, self.SMTP_USER, self.SMTP_PASSWORD, self.SENDER_EMAIL]):
            logger.critical("SMTP配置不完整，无法发送邮件。请检查 EmailHandler 中的配置项。")
            return False

        if not recipients:
            logger.warning("收件人列表为空，邮件未发送。")
            return False

        # 创建一个带附件的实例
        message = MIMEMultipart('alternative')
        message['From'] = f'"{Header(self.SENDER_NAME, "utf-8").encode()}" <{self.SENDER_EMAIL}>'
        message['To'] = ", ".join(recipients)
        message['Subject'] = Header(subject, 'utf-8')

        # 邮件正文内容
        html_part = MIMEText(html_content, 'html', 'utf-8')
        message.attach(html_part)
        server = None  # 初始化server变量
        try:
            logger.info(f"准备通过 {self.SMTP_SERVER}:{self.SMTP_PORT} 发送邮件至 {recipients}...")
            
            # 1. 手动建立连接
            server = smtplib.SMTP_SSL(self.SMTP_SERVER, self.SMTP_PORT)
            server.login(self.SMTP_USER, self.SMTP_PASSWORD)
            server.sendmail(self.SENDER_EMAIL, recipients, message.as_string())
            
            logger.info(f"邮件发送成功！主题: '{subject}'")
            return True
            
        except smtplib.SMTPException as e:
            logger.error(f"发送邮件时发生SMTP错误: {e}", exc_info=True)
            return False
        except Exception as e:
            logger.error(f"发送邮件时发生未知错误: {e}", exc_info=True)
            return False
        finally:
            # 2. 在finally块中确保关闭连接
            if server:
                try:
                    # 3. 对quit()命令进行独立的异常处理
                    server.quit()
                except smtplib.SMTPResponseException as e:
                    # 优雅地处理服务器提前关闭连接的情况
                    logger.warning(f"关闭SMTP连接时发生响应异常 (通常无害): {e}")
                except Exception as e:
                    logger.error(f"关闭SMTP连接时发生未知错误: {e}", exc_info=True)


####文件结束####

####data_manager\service\email_service.py####
# data_manager/service/email_service.py

import logging
from datetime import date, timedelta
from decimal import Decimal

from django.utils import timezone
from django.db import transaction

# 内部模块导入
from .email_handler import EmailHandler

# Django模型导入
from common.models import (
    DailyFactorValues, DailyTradingPlan, DailyQuotes, StockInfo,
    Position, TradeLog
)
from selection_manager.service.selection_service import MARKET_INDICATOR_CODE
from trade_manager.service.decision_order_service import DecisionOrderService
from trade_manager.service.simulate_trade_handler import SimulateTradeHandler
from trade_manager.service.simulate_trade import SimulateTradeService


logger = logging.getLogger(__name__)

class EmailNotificationService:
    """
    封装了在T日盘前（如9:10）向指定邮箱推送T-1日预案的业务逻辑。
    """

    def __init__(self, t_day: date):
        """
        初始化邮件通知服务。
        :param t_day: T日，即预案执行日。
        """
        self.t_day = t_day
        try:
            # 获取T日之前的最后一个交易日作为T-1日
            self.t_minus_1_day = DailyQuotes.objects.filter(
                trade_date__lt=self.t_day
            ).latest('trade_date').trade_date
        except DailyQuotes.DoesNotExist:
            raise ValueError(f"无法找到 {self.t_day} 的前一个交易日(T-1)，服务无法初始化。")

        self.email_handler = EmailHandler()
        # 从EmailHandler的配置中直接读取收件人列表
        self.recipients = self.email_handler.recipients if hasattr(self.email_handler, 'recipients') else ['876858298@qq.com','850696281@qq.com','285173686@qq.com','2516937525@qq.com']


    def runEmailSend(self):
        """
        一键执行邮件发送的主方法。
        """
        logger.info(f"开始为T日({self.t_day})生成预案推送邮件...")
        # 【核心修改】先找到真正需要处理的预案日期
        plan_date_to_process = self._find_latest_pending_plan_date()
        if not plan_date_to_process:
            logger.warning(f"从T日({self.t_day})回溯，未找到任何待处理的交易预案，邮件发送任务终止。")
            return
        # 1. 获取所有需要的数据
        market_data = self._get_market_regime_data()
        # 【核心修改】将找到的日期传递给下一步
        plan_details = self._get_trading_plan_details(plan_date_to_process)
        if not plan_details:
            logger.warning(f"预案日({plan_date_to_process})的预案详情为空，邮件发送任务终止。")
            return
        # 2. 生成HTML内容
        html_content = self._format_html_content(market_data, plan_details)
        # 3. 发送邮件
        subject = f"【交易预案】{self.t_day.strftime('%Y-%m-%d')} 盘前确认 (数据源: {plan_date_to_process.strftime('%Y-%m-%d')})"
        self.email_handler.send_email(self.recipients, subject, html_content)

    def _get_market_regime_data(self) -> dict:
        """获取昨日M值及近10日M值历史"""
        try:
            # 获取T-1日及之前的10个交易日
            trade_dates = list(DailyQuotes.objects.filter(trade_date__lte=self.t_minus_1_day)
                               .values_list('trade_date', flat=True)
                               .distinct().order_by('-trade_date')[:10])
            trade_dates.reverse()

            m_values_qs = DailyFactorValues.objects.filter(
                stock_code_id=MARKET_INDICATOR_CODE,
                factor_code_id='dynamic_M_VALUE',
                trade_date__in=trade_dates
            ).order_by('-trade_date')

            m_values_map = {fv.trade_date: fv.raw_value for fv in m_values_qs}

            yesterday_m = m_values_map.get(self.t_minus_1_day, Decimal('NaN'))
            history_m = [{'date': d, 'value': m_values_map.get(d, Decimal('NaN'))} for d in trade_dates]

            return {'yesterday_m': yesterday_m, 'history_m': history_m}

        except Exception as e:
            logger.error(f"获取M值数据时出错: {e}", exc_info=True)
            return {'yesterday_m': Decimal('NaN'), 'history_m': []}

    def _get_trading_plan_details(self, plan_date: date) -> list[dict]:
        """获取T日交易预案及相关的所有详细信息"""
        plans = DailyTradingPlan.objects.filter(plan_date=plan_date, status=DailyTradingPlan.StatusChoices.PENDING).order_by('rank')
        if not plans.exists():
            return []

        detailed_plans = []
        for plan in plans:
            stock_code = plan.stock_code_id
            logger.debug(f"正在处理预案股票: {stock_code}")
            try:
                # 获取止盈止损率
                rates = self._calculate_profit_loss_rates(stock_code)
                # 获取历史行情
                history = self._get_stock_historical_data(stock_code)

                detailed_plans.append({
                    'plan': plan,
                    'stock_info': plan.stock_code, # StockInfo object
                    'rates': rates,
                    'history': history
                })
            except Exception as e:
                logger.error(f"处理股票 {stock_code} 的预案详情时失败: {e}", exc_info=True)
                continue # 跳过这个出错的股票

        return detailed_plans

    def _calculate_profit_loss_rates(self, stock_code: str) -> dict:
        """
        通过创建临时数据库记录来复用现有止盈止损计算逻辑。
        整个过程在单个数据库事务中完成，确保安全。
        """
        tp_rate, sl_rate = Decimal('NaN'), Decimal('NaN')
        try:
            # 【新增步骤1】: 获取T-1日收盘价作为基准
            try:
                t_minus_1_quote = DailyQuotes.objects.get(stock_code_id=stock_code, trade_date=self.t_minus_1_day)
                base_price = t_minus_1_quote.close
                if base_price <= 0:
                    raise ValueError("T-1日收盘价无效")
            except DailyQuotes.DoesNotExist:
                logger.error(f"无法找到 {stock_code} 在 {self.t_minus_1_day} 的行情数据，无法计算止盈止损率。")
                return {'tp_rate': tp_rate, 'sl_rate': sl_rate}
            except ValueError as e:
                logger.error(f"股票 {stock_code} 在 {self.t_minus_1_day} 的收盘价不合法: {e}")
                return {'tp_rate': tp_rate, 'sl_rate': sl_rate}
            with transaction.atomic():
                # 【修改步骤2】: 使用获取到的base_price创建临时记录
                temp_position = Position.objects.create(
                    stock_code_id=stock_code,
                    entry_price=base_price, # 使用T-1收盘价
                    quantity=100,
                    entry_datetime=timezone.now(),
                    status=Position.StatusChoices.OPEN,
                    current_stop_loss=Decimal('0.00'),
                    current_take_profit=Decimal('0.00')
                )
                temp_trade_log = TradeLog.objects.create(
                    position=temp_position,
                    stock_code_id=stock_code,
                    trade_datetime=timezone.now(),
                    trade_type=TradeLog.TradeTypeChoices.BUY,
                    status=TradeLog.StatusChoices.FILLED,
                    price=base_price, # 使用T-1收盘价
                    quantity=100,
                    commission=0,
                    stamp_duty=0
                )
                # 调用服务进行计算 (这部分不变)
                dummy_sim_service = SimulateTradeService()
                dummy_handler = SimulateTradeHandler(dummy_sim_service)
                decision_service = DecisionOrderService(handler=dummy_handler, execution_date=self.t_day)
                decision_service.calculate_stop_profit_loss(trade_id=temp_trade_log.trade_id)
                temp_position.refresh_from_db()
                # 【修改步骤3】: 使用base_price作为分母计算比率
                take_profit_price = temp_position.current_take_profit
                stop_loss_price = temp_position.current_stop_loss
                if take_profit_price > 0:
                    tp_rate = (take_profit_price / base_price) - 1
                if stop_loss_price > 0:
                    sl_rate = 1 - (stop_loss_price / base_price)
                # 回滚事务，清除临时数据 (这部分不变)
                transaction.set_rollback(True)
        except Exception as e:
            logger.error(f"为 {stock_code} 计算止盈止损率时发生严重错误: {e}", exc_info=True)
            transaction.set_rollback(True)
        logger.debug(f"{stock_code} (基准价: {base_price:.2f}) -> TP Rate: {tp_rate:.4%}, SL Rate: {sl_rate:.4%}")
        return {'tp_rate': tp_rate, 'sl_rate': sl_rate}


    def _get_stock_historical_data(self, stock_code: str) -> list[dict]:
        """获取指定股票近10个交易日的历史行情"""
        trade_dates = list(DailyQuotes.objects.filter(trade_date__lte=self.t_minus_1_day)
                           .values_list('trade_date', flat=True)
                           .distinct().order_by('-trade_date')[:10])
        trade_dates.reverse()

        quotes = DailyQuotes.objects.filter(
            stock_code_id=stock_code,
            trade_date__in=trade_dates
        ).order_by('trade_date')

        history = []
        prev_close = None
        for quote in quotes:
            change_pct = Decimal('0.0')
            if prev_close and prev_close > 0:
                change_pct = (quote.close / prev_close) - 1
            
            history.append({
                'date': quote.trade_date,
                'open': quote.open,
                'high': quote.high,
                'low': quote.low,
                'close': quote.close,
                'hfq_close': quote.hfq_close,
                'change_pct': change_pct
            })
            prev_close = quote.close
        return history

    def _format_html_content(self, market_data: dict, plan_details: list[dict]) -> str:
        """将所有数据格式化为美观的HTML字符串"""
        
        # --- CSS样式 ---
        style = """
        <style>
            body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; line-height: 1.6; color: #333; background-color: #f8f9fa; margin: 0; padding: 20px; }
            .container { max-width: 800px; margin: auto; background: #fff; padding: 25px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
            h2 { color: #0056b3; border-bottom: 2px solid #0056b3; padding-bottom: 10px; margin-top: 30px; }
            h3 { color: #17a2b8; margin-top: 25px; }
            table { width: 100%; border-collapse: collapse; margin-top: 15px; font-size: 14px; }
            th, td { border: 1px solid #dee2e6; padding: 10px; text-align: left; }
            th { background-color: #e9ecef; font-weight: 600; }
            tr:nth-child(even) { background-color: #f8f9fa; }
            .summary { font-size: 16px; font-weight: bold; margin-bottom: 20px; }
            .red { color: #dc3545; }
            .green { color: #28a745; }
            .footer { margin-top: 30px; font-size: 12px; color: #6c757d; text-align: center; }
        </style>
        """

        # --- HTML头部 ---
        html = f"""
        <!DOCTYPE html>
        <html lang="zh-CN">
        <head>
            <meta charset="UTF-8">
            <title>交易预案确认</title>
            {style}
        </head>
        <body>
            <div class="container">
                <h2>T日 ({self.t_day.strftime('%Y-%m-%d')}) 交易预案盘前确认</h2>
        """

        # --- 大盘情况 ---
        yesterday_m_str = f"{market_data['yesterday_m']:.4f}" if not market_data['yesterday_m'].is_nan() else "N/A"
        html += f"""
        <h3>[大盘情况]</h3>
        <p class="summary">昨日M值: <span class="{'red' if market_data.get('yesterday_m', 0) > 0 else 'green'}">{yesterday_m_str}</span></p>
        <table>
            <thead><tr><th>日期</th><th>M值</th></tr></thead>
            <tbody>
        """
        for item in reversed(market_data['history_m']):
            m_val_str = f"{item['value']:.4f}" if not item['value'].is_nan() else "N/A"
            html += f"<tr><td>{item['date'].strftime('%Y-%m-%d')}</td><td>{m_val_str}</td></tr>"
        html += "</tbody></table>"

        # --- 选股预案 ---
        html += "<h3>[选股预案]</h3>"
        html += """
        <table>
            <thead>
                <tr>
                    <th>排名</th>
                    <th>股票代码</th>
                    <th>股票名称</th>
                    <th>可接受开盘区间</th>
                    <th>选股得分</th>
                    <th>预期止盈率</th>
                    <th>预期止损率</th>
                </tr>
            </thead>
            <tbody>
        """
        for detail in plan_details:
            plan = detail['plan']
            stock_info = detail['stock_info']
            rates = detail['rates']
            tp_rate_str = f"{rates['tp_rate']:.2%}" if not rates['tp_rate'].is_nan() else "N/A"
            sl_rate_str = f"{rates['sl_rate']:.2%}" if not rates['sl_rate'].is_nan() else "N/A"
            html += f"""
            <tr>
                <td>{plan.rank}</td>
                <td>{stock_info.stock_code}</td>
                <td>{stock_info.stock_name}</td>
                <td>{plan.miop:.2f} - {plan.maop:.2f}</td>
                <td>{plan.final_score}</td>
                <td class="red">{tp_rate_str}</td>
                <td class="green">{sl_rate_str}</td>
            </tr>
            """
        html += "</tbody></table>"

        # --- 各股票历史行情 ---
        for detail in plan_details:
            stock_info = detail['stock_info']
            history = detail['history']
            html += f"<h4>{stock_info.stock_name} ({stock_info.stock_code}) - 近10日行情</h4>"
            html += """
            <table>
                <thead>
                    <tr>
                        <th>日期</th>
                        <th>开盘价</th>
                        <th>最高价</th>
                        <th>最低价</th>
                        <th>收盘价</th>
                        <th>后复权收盘</th>
                        <th>涨幅</th>
                    </tr>
                </thead>
                <tbody>
            """
            for item in reversed(history):
                color_class = 'red' if item['change_pct'] > 0 else ('green' if item['change_pct'] < 0 else '')
                html += f"""
                <tr>
                    <td>{item['date'].strftime('%Y-%m-%d')}</td>
                    <td>{item['open']:.2f}</td>
                    <td>{item['high']:.2f}</td>
                    <td>{item['low']:.2f}</td>
                    <td>{item['close']:.2f}</td>
                    <td>{item['hfq_close']:.4f}</td>
                    <td class="{color_class}">{item['change_pct']:.2%}</td>
                </tr>
                """
            html += "</tbody></table>"

        # --- HTML尾部 ---
        html += """
                <p class="footer">本邮件由策略交易系统自动生成，仅供参考，请在交易前最终确认。</p>
            </div>
        </body>
        </html>
        """
        return html
    def _find_latest_pending_plan_date(self) -> date | None:
        """从T日开始向前回溯，查找最新的一个包含待执行预案的日期"""
        # 设置一个合理的回溯上限，例如14天
        for i in range(14):
            check_date = self.t_day - timedelta(days=i)
            if DailyTradingPlan.objects.filter(
                plan_date=check_date,
                status=DailyTradingPlan.StatusChoices.PENDING
            ).exists():
                logger.info(f"找到待执行的交易预案，预案生成日为: {check_date}")
                return check_date
        logger.warning(f"在过去14天内未找到任何待执行的交易预案。")
        return None

####文件结束####

####data_manager\service\stock_service.py####
import logging
import datetime
from decimal import Decimal, ROUND_HALF_UP,InvalidOperation
import akshare as ak
import pandas as pd
from django.utils import timezone
from django.db import connection,transaction, DatabaseError

# 导入您的Django模型
from common.models.stock_info import StockInfo
from common.models.daily_quotes import DailyQuotes
from common.models.factor_definitions import FactorDefinitions
from common.models.daily_factor_values import DailyFactorValues
from common.models.strategy_parameters import StrategyParameters
from common.models.daily_trading_plan import DailyTradingPlan
from common.models.positions import Position
from common.models.trade_log import TradeLog
from common.models.system_log import SystemLog
from common.models.index_quotes_csi300 import IndexQuotesCsi300
from concurrent.futures import ThreadPoolExecutor, as_completed
import time

# 获取logger实例
logger = logging.getLogger(__name__)

# 定义模块常量，便于维护
MODULE_NAME = 'data_manager'

class StockService:
    """
    封装了与股票数据相关的服务，包括从akshare更新数据和从本地数据库查询数据。
  
    使用示例 (在Django views.py 或 management command中):
  
    from .services.stock_service import StockService
  
    def my_view(request):
        service = StockService()
      
        # 示例1: 更新所有A股今天的行情
        service.update_local_a_shares()
      
        # 示例2: 更新指定几只股票某时间段的行情
        codes = ['sh.600519', 'sz.000001']
        service.update_local_a_shares(stock_codes=codes, start_date='2023-01-01', end_date='2023-01-31')
      
        # 示例3: 查询指定股票的基础信息
        stock_infos = service.query_stock_info(stock_codes=codes)
      
        # 示例4: 查询所有股票今天的日线行情
        daily_quotes = service.query_daily_quotes()
    """

    def _log_and_save(self, message: str, level: str = SystemLog.LogLevelChoices.INFO):
        """
        一个辅助方法，用于同时向标准logger和数据库系统日志表写入日志。
        """
        log_map = {
            SystemLog.LogLevelChoices.INFO: logger.info,
            SystemLog.LogLevelChoices.WARNING: logger.warning,
            SystemLog.LogLevelChoices.ERROR: logger.error,
            SystemLog.LogLevelChoices.CRITICAL: logger.critical,
        }
      
        # 打印到标准日志
        log_function = log_map.get(level, logger.info)
        log_function(message)
      
        # 保存到数据库
        # try:
        #     SystemLog.objects.create(
        #         log_level=level,
        #         module_name=MODULE_NAME,
        #         message=message
        #     )
        # except Exception as e:
        #     logger.error(f"无法将日志写入数据库: {e}")

    def _save_quotes_df_to_db(self, quotes_df: pd.DataFrame):
        """
        辅助方法：将一个DataFrame的行情数据通过 update_or_create 批量存入数据库。
        此方法具有幂等性，适用于所有数据，无需区分历史和当日。
        """
        if quotes_df.empty:
            return
 
        # 数据清洗和预处理
        quotes_df.fillna(0, inplace=True)
        quotes_df = quotes_df[(quotes_df['开盘'] > 0) & (quotes_df['收盘'] > 0) & (quotes_df['最高'] > 0) & (quotes_df['最低'] > 0) & (quotes_df['成交量'] >= 0)]
        if quotes_df.empty:
            self._log_and_save("数据清洗后，当前批次无有效数据可存储。", level=SystemLog.LogLevelChoices.INFO)
            return
            
        quotes_df['日期'] = pd.to_datetime(quotes_df['日期']).dt.date
        
        hfq_precision = Decimal('0.0000000001')
        records_to_process = len(quotes_df)
    
        try:
            # 将整个批次的 update_or_create 操作放在一个事务中，以提高性能
            with transaction.atomic():
                for _, row in quotes_df.iterrows():
                    try:
                        close_dec = Decimal(str(row['收盘']))
                        factor_dec = Decimal(str(row['复权因子']))
                        hfq_close_dec = (close_dec * factor_dec).quantize(hfq_precision, rounding=ROUND_HALF_UP)
                        
                        # 对每一行数据都执行 update_or_create
                        DailyQuotes.objects.update_or_create(
                            stock_code_id=row['stock_code'], 
                            trade_date=row['日期'],
                            defaults={
                                'open': Decimal(str(row['开盘'])), 
                                'high': Decimal(str(row['最高'])),
                                'low': Decimal(str(row['最低'])), 
                                'close': close_dec,
                                'volume': int(row['成交量']), 
                                'turnover': Decimal(str(row['成交额'])),
                                'adjust_factor': factor_dec, 
                                'hfq_close': hfq_close_dec
                            }
                        )
                    except (InvalidOperation, TypeError) as conversion_error:
                        self._log_and_save(f"跳过一条数据转换失败的记录: {row['stock_code']} on {row['日期']}. Error: {conversion_error}", level=SystemLog.LogLevelChoices.WARNING)
                        continue
            
            self._log_and_save(f"通过 update_or_create 成功处理了 {records_to_process} 条日线数据。")
    
        except (DatabaseError, Exception) as e:
            self._log_and_save(f"数据批量入库阶段(update_or_create)发生严重错误: {e}", level=SystemLog.LogLevelChoices.ERROR)

    def update_local_a_shares(
        self, 
        stock_codes: list[str] = None, 
        start_date: str = None, 
        end_date: str = None
    ):

        """
        1. 更新本地A股信息 (最终版：高效、健壮)
        """
        self._log_and_save(f"开始执行A股数据更新任务...")
        target_codes=[]
        # --- Part 1: 更新股票基础信息 (tb_stock_info) ---
        try:
            self._log_and_save("正在从交易所官方数据源获取全量A股列表...")
            
            # 1. 通过高效、可靠的接口一次性获取所有A股信息
            # 上海主板A股
            sh_main_df = ak.stock_info_sh_name_code(symbol="主板A股").copy()
            # 上海科创板
            sh_star_df = ak.stock_info_sh_name_code(symbol="科创板").copy()
            # 深圳A股
            sz_a_df = ak.stock_info_sz_name_code(symbol="A股列表").copy()
 
            # 2. 数据预处理和合并
            # 统一列名
            sh_main_df.rename(columns={'证券简称': 'stock_name', '上市日期': 'listing_date', '证券代码': 'code'}, inplace=True)
            sh_star_df.rename(columns={'证券简称': 'stock_name', '上市日期': 'listing_date', '证券代码': 'code'}, inplace=True)
            sz_a_df.rename(columns={'A股简称': 'stock_name', 'A股上市日期': 'listing_date', 'A股代码': 'code'}, inplace=True)
 
            # 添加市场前缀
            sh_main_df['code'] = 'sh.' + sh_main_df['code']
            sh_star_df['code'] = 'sh.' + sh_star_df['code']
            sz_a_df['code'] = 'sz.' + sz_a_df['code']
 
            # 合并为一个DataFrame
            all_stocks_df = pd.concat([
                sh_main_df[['code', 'stock_name', 'listing_date']],
                sh_star_df[['code', 'stock_name', 'listing_date']],
                sz_a_df[['code', 'stock_name', 'listing_date']]
            ], ignore_index=True)
 
            # 转换日期格式
            all_stocks_df['listing_date'] = pd.to_datetime(all_stocks_df['listing_date']).dt.date
            
            self._log_and_save(f"成功获取 {len(all_stocks_df)} 条A股基础信息。")
 
            # 3. 高效的批量入库操作
            with transaction.atomic():
                existing_stocks = StockInfo.objects.in_bulk(field_name='stock_code')
                
                to_create = []
                to_update = []
 
                for _, row in all_stocks_df.iterrows():
                    code = row['code']
                    stock_obj = existing_stocks.get(code)
                    
                    if not stock_obj:
                        # 如果股票不存在，则准备新建
                        to_create.append(
                            StockInfo(
                                stock_code=code,
                                stock_name=row['stock_name'],
                                listing_date=row['listing_date'],
                                status=StockInfo.StatusChoices.LISTING
                            )
                        )
                    elif stock_obj.stock_name != row['stock_name']:
                        # 如果股票存在但名称有变，则准备更新
                        stock_obj.stock_name = row['stock_name']
                        to_update.append(stock_obj)
 
                # 批量创建
                if to_create:
                    StockInfo.objects.bulk_create(to_create, batch_size=500)
                    self._log_and_save(f"批量新增 {len(to_create)} 条股票基础信息。")
                
                # 批量更新
                if to_update:
                    StockInfo.objects.bulk_update(to_update, ['stock_name'], batch_size=500)
                    self._log_and_save(f"批量更新 {len(to_update)} 条股票基础信息。")
 
            # 如果未指定 stock_codes，则使用获取到的所有代码进行下一步
            if not stock_codes or len(stock_codes)==0:
                stock_codes = all_stocks_df['code'].tolist()
            else:
                # 如果指定了，则只处理指定的代码
                stock_codes = [code for code in stock_codes if code in all_stocks_df['code'].values]
            target_codes = stock_codes if stock_codes else all_stocks_df['code'].tolist()
        except Exception as e:
            self._log_and_save(f"更新股票基础信息时发生严重错误: {e}", level=SystemLog.LogLevelChoices.ERROR)
            return

        # --- Part 2: 更新日线行情 (串行获取、内存汇总、批量入库) ---
        self._log_and_save(f"开始为 {len(target_codes)} 只股票串行获取日线行情...")
        today_str = datetime.date.today().strftime('%Y%m%d')
        start_date_str = datetime.datetime.strptime(start_date, '%Y-%m-%d').strftime('%Y%m%d') if start_date else today_str
        end_date_str = datetime.datetime.strptime(end_date, '%Y-%m-%d').strftime('%Y%m%d') if end_date else today_str
        # 定义批处理参数
        batch_size = 50  # 每批处理50只股票，可以根据你的机器内存调整
        batch_quotes_list = []
        # 改为串行循环
        for i, code in enumerate(target_codes):
            ak_code = code.split('.')[1]
            logger.info(f"进度: [{i+1}/{len(target_codes)}] 正在获取 {code}...")
            try:
                df_normal = ak.stock_zh_a_hist(symbol=ak_code, period="daily", start_date=start_date_str, end_date=end_date_str, adjust="")
                time.sleep(1.6) # 增加礼貌性延时，降低被封风险
                df_hfq = ak.stock_zh_a_hist(symbol=ak_code, period="daily", start_date=start_date_str, end_date=end_date_str, adjust="hfq")
                
                if df_normal.empty or df_hfq.empty:
                    continue
 
                df = pd.merge(df_normal, df_hfq[['日期', '收盘']], on='日期', suffixes=('', '_hfq'))
                df['复权因子'] = df.apply(lambda row: row['收盘_hfq'] / row['收盘'] if row['收盘'] and row['收盘'] != 0 else 0, axis=1)
                df['stock_code'] = code
                batch_quotes_list.append(df)
                
                time.sleep(1.4) # 增加礼貌性延时，降低被封风险
 
            except Exception as e:
                self._log_and_save(f"获取 {code} 日线行情失败: {e}", level=SystemLog.LogLevelChoices.WARNING)
                continue
 
        # 检查是否达到批处理大小，或者已经是最后一只股票
            if (i + 1) % batch_size == 0 or (i + 1) == len(target_codes):
                if not batch_quotes_list:
                    continue # 如果这个批次是空的，就跳过

                self._log_and_save(f"处理批次 {i//batch_size + 1}，包含 {len(batch_quotes_list)} 只股票...")
                
                # 1. 合并当前批次的数据
                batch_master_df = pd.concat(batch_quotes_list, ignore_index=True)
                
                # 2. 将这个批次的数据存入数据库
                self._save_quotes_df_to_db(batch_master_df)
                
                # 3. 清空批次列表，释放内存，为下一批做准备
                batch_quotes_list = []
                self._log_and_save(f"批次 {i//batch_size + 1} 处理完毕，内存已释放。")
 
        self._log_and_save("A股数据更新任务全部执行完毕。")

    def query_stock_info(self, stock_codes: list[str] = None) -> dict[str, StockInfo]:
        """
        2. 查询本地A股基础信息
        直接查询 tb_stock_info。
        """
        queryset = StockInfo.objects.all()
        if stock_codes:
            queryset = queryset.filter(stock_code__in=stock_codes)
      
        return {stock.stock_code: stock for stock in queryset}

    def query_daily_quotes(
        self, 
        stock_codes: list[str] = None, 
        start_date: str = None, 
        end_date: str = None
    ) -> dict[str, list[DailyQuotes]]:
        """
        3. 查询本地A股交易信息
        直接查询 tb_daily_quotes。
        """
        # 设置默认日期为今天
        today = datetime.date.today()
        start_date = start_date or today.strftime('%Y-%m-%d')
        end_date = end_date or today.strftime('%Y-%m-%d')

        # 使用 select_related 优化查询，一次性获取关联的 StockInfo 对象
        # 使用 order_by 确保数据按股票和日期排序，便于后续分组
        queryset = DailyQuotes.objects.select_related('stock_code').filter(
            trade_date__gte=start_date,
            trade_date__lte=end_date
        ).order_by('stock_code', 'trade_date')

        if stock_codes:
            queryset = queryset.filter(stock_code__in=stock_codes)
      
        # 构建输出字典
        result = {}
        for quote in queryset:
            # 使用 stock_code_id 避免再次访问数据库
            # setdefault 是构建这种分组字典的优雅方式
            result.setdefault(quote.stock_code_id, []).append(quote)
          
        return result

    #清空所有数据
    def clear_all_data(self):
        with connection.cursor() as cursor:
            cursor.execute(f"DELETE FROM tb_daily_factor_values;")
            cursor.execute(f"DELETE FROM tb_daily_quotes;")
            cursor.execute(f"DELETE FROM tb_daily_trading_plan;")
            cursor.execute(f"DELETE FROM tb_factor_definitions;")
            cursor.execute(f"DELETE FROM tb_positions;")
            cursor.execute(f"DELETE FROM tb_stock_info;")
            cursor.execute(f"DELETE FROM tb_strategy_parameters;")
            cursor.execute(f"DELETE FROM tb_system_log;")
            cursor.execute(f"DELETE FROM tb_trade_log;")
    def update_csi300_index_data(self, start_date: str, end_date: str):
        """
        获取并更新沪深300指数的日线行情数据。
        """
        self._log_and_save(f"开始更新沪深300指数数据，范围: {start_date} to {end_date}。")
        try:
            df = ak.index_zh_a_hist(
                symbol="000300",
                period="daily",
                start_date=start_date.replace('-', ''),
                end_date=end_date.replace('-', '')
            )
            if df.empty:
                self._log_and_save(f"在 {start_date} to {end_date} 期间未获取到沪深300指数数据。", level=SystemLog.LogLevelChoices.WARNING)
                return
            df.rename(columns={
                '日期': 'trade_date', '开盘': 'open', '收盘': 'close', '最高': 'high', '最低': 'low',
                '成交量': 'volume', '成交额': 'amount', '振幅': 'amplitude',
                '涨跌幅': 'pct_change', '涨跌额': 'change_amount', '换手率': 'turnover_rate'
            }, inplace=True)
            
            df['volume'] = df['volume'] * 100
            df['turnover_rate'] = pd.to_numeric(df['turnover_rate'], errors='coerce')
            with transaction.atomic():
                for _, row in df.iterrows():
                    IndexQuotesCsi300.objects.update_or_create(
                        trade_date=row['trade_date'],
                        defaults={
                            'open': Decimal(str(row['open'])), 'close': Decimal(str(row['close'])),
                            'high': Decimal(str(row['high'])), 'low': Decimal(str(row['low'])),
                            'volume': int(row['volume']), 'amount': Decimal(str(row['amount'])),
                            'amplitude': Decimal(str(row['amplitude'])), 'pct_change': Decimal(str(row['pct_change'])),
                            'change_amount': Decimal(str(row['change_amount'])),
                            'turnover_rate': Decimal(str(row['turnover_rate'])) if pd.notna(row['turnover_rate']) else None
                        }
                    )
            self._log_and_save(f"成功更新 {len(df)} 条沪深300指数数据。")
        except Exception as e:
            self._log_and_save(f"更新沪深300指数数据时发生错误: {e}", level=SystemLog.LogLevelChoices.ERROR)
####文件结束####

####selection_manager\__init__.py####

####文件结束####

####selection_manager\admin.py####
from django.contrib import admin

# Register your models here.

####文件结束####

####selection_manager\apps.py####
from django.apps import AppConfig


class SelectionManagerConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'selection_manager'

####文件结束####

####selection_manager\models.py####
from django.db import models

# Create your models here.

####文件结束####

####selection_manager\tests.py####
from django.test import TestCase

# Create your tests here.

####文件结束####

####selection_manager\urls.py####
"""
URL configuration for autoTrade project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path,include
from . import views
urlpatterns = [
    path('initParam', views.init_strategy),
    path('runSelection',views.run_selection)
]

####文件结束####

####selection_manager\views.py####
from datetime import date,datetime
from django.shortcuts import render
from django.http.response import JsonResponse
from selection_manager.service.selection_service import SelectionService
import json
from django.views.decorators.http import require_http_methods
# Create your views here.
@require_http_methods(["GET"])
def init_strategy(request):
    SelectionService.initialize_strategy()
    result={}
    return JsonResponse(result)
@require_http_methods(["POST"])
def run_selection(request):
    if request.method=='POST':
        body= json.loads(request.body)
        selection_date=datetime.strptime(body['date'], "%Y-%m-%d").date()
        service=SelectionService(selection_date,mode=body['mode'])
        service.run_selection()
        return JsonResponse({
            'type':selection_date,
            'data':json.loads(request.body)
        })
    

####文件结束####

####selection_manager\service\m_value_service.py####
# selection_manager/service/m_value_service.py

import logging
import json
from pathlib import Path

import numpy as np
import pandas as pd
import pandas_ta as ta
import joblib
from django.conf import settings

logger = logging.getLogger(__name__)

# ==============================================================================
#  独立的因子计算器 (Decoupled Factor Calculator)
#  [重要] 此类代码与 prepare_csi300_features.py 中的完全一致，以实现解耦。
#  如果因子逻辑更新，需要同步修改这两个地方。
# ==============================================================================
class FactorCalculator:
    """
    一个独立的、解耦的因子计算器。
    它只接收一个标准的OHLCVA DataFrame，并计算所有预定义的因子。
    """
    def __init__(self, df: pd.DataFrame):
        if not all(col in df.columns for col in ['open', 'high', 'low', 'close', 'volume', 'amount']):
            raise ValueError("输入DataFrame必须包含 'open', 'high', 'low', 'close', 'volume', 'amount' 列")
        self.df = df.copy()
        ta.Imports["verbose"] = False

    def run(self, feature_names: list) -> pd.DataFrame:
        """
        根据给定的特征名称列表，运行所有需要的因子计算。
        """
        all_factors_df = pd.DataFrame(index=self.df.index)
        
        # [同步] 确保此处的计算方法列表与 prepare_csi300_features.py 完全一致
        calculator_methods = {
            'dynamic_ADX_CONFIRM': self._calc_adx_confirm,
            'dynamic_v2_MA_SLOPE': self._calc_v2_ma_slope,
            'dynamic_v2_MA_SCORE': self._calc_v2_ma_score,
            'dynamic_v2_CPC_Factor': self._calc_v2_cpc_factor,
            'dynamic_v2_VPCF': self._calc_v2_vpcf,
            'dynamic_BREAKOUT_PWR': self._calc_breakout_pwr,
            'dynamic_VOLUME_SURGE': self._calc_volume_surge,
            'dynamic_MOM_ACCEL': self._calc_mom_accel,
            'dynamic_RSI_OS': self._calc_rsi_os,
            'dynamic_NEG_DEV': self._calc_neg_dev,
            'dynamic_BOLL_LB': self._calc_boll_lb,
            'dynamic_LOW_VOL': self._calc_low_vol,
            'dynamic_MAX_DD': self._calc_max_dd,
            'dynamic_DOWNSIDE_RISK': self._calc_downside_risk,
            'dynamic_MACD_SIGNAL': self._calc_macd_signal,
            'dynamic_BREAKOUT_DURATION': self._calc_breakout_duration,
            # --- 新增老M值体系因子 ---
            'dynamic_Old_D': self._calc_old_d,
            'dynamic_Old_I': self._calc_old_i,
            'dynamic_Old_M': self._calc_old_m,
        }

        for factor_name in feature_names:
            if factor_name in calculator_methods:
                factor_series = calculator_methods[factor_name]()
                all_factors_df[factor_name] = factor_series
            else:
                raise ValueError(f"预测时发现未知特征 '{factor_name}'，模型和数据准备脚本可能不一致。")
        
        return all_factors_df

    # --- 因子计算方法 (与prepare文件完全相同) ---
    def _calc_adx_confirm(self, length=14, adx_threshold=25):
        adx_df = self.df.ta.adx(length=length, high=self.df['high'], low=self.df['low'], close=self.df['close'])
        adx_col, dmp_col, dmn_col = f'ADX_{length}', f'DMP_{length}', f'DMN_{length}'
        condition = (adx_df[adx_col] > adx_threshold) & (adx_df[dmp_col] > adx_df[dmn_col])
        return adx_df[adx_col].where(condition, 0.0).rename('dynamic_ADX_CONFIRM')

    def _calc_v2_ma_slope(self, ma_period=20, ema_period=20):
        ma = self.df['close'].rolling(window=ma_period).mean()
        ma_roc = ma.pct_change(1)
        return ma_roc.ewm(span=ema_period, adjust=False).mean().rename('dynamic_v2_MA_SLOPE')

    def _calc_v2_ma_score(self, p1=5, p2=10, p3=20):
        close = self.df['close']
        ma5 = close.rolling(window=p1).mean()
        ma10 = close.rolling(window=p2).mean()
        ma20 = close.rolling(window=p3).mean()
        spread1 = (close - ma5) / ma5.replace(0, 1e-9)
        spread2 = (ma5 - ma10) / ma10.replace(0, 1e-9)
        spread3 = (ma10 - ma20) / ma20.replace(0, 1e-9)
        return ((spread1 + spread2 + spread3) / 3.0).rename('dynamic_v2_MA_SCORE')

    def _calc_v2_cpc_factor(self, ema_period=10):
        high, low, close = self.df['high'], self.df['low'], self.df['close']
        price_range = high - low
        dcp = (2 * close - high - low) / price_range.replace(0, 1e-9)
        return dcp.ewm(span=ema_period, adjust=False).mean().rename('dynamic_v2_CPC_Factor')

    def _calc_v2_vpcf(self, s=5, l=20, n_smooth=5):
        ma_close_s = self.df['close'].rolling(window=s).mean()
        price_momentum = ma_close_s.pct_change(1)
        ma_amount_s = self.df['amount'].rolling(window=s).mean()
        ma_amount_l = self.df['amount'].rolling(window=l).mean()
        volume_level = (ma_amount_s / ma_amount_l.replace(0, 1e-9)) - 1
        daily_score = price_momentum * volume_level
        return daily_score.ewm(span=n_smooth, adjust=False).mean().rename('dynamic_v2_VPCF')

    def _calc_breakout_pwr(self, lookback=60, atr_period=14):
        high_lookback = self.df['high'].rolling(window=lookback).max().shift(1)
        atr = self.df.ta.atr(length=atr_period, high=self.df['high'], low=self.df['low'], close=self.df['close'])
        return ((self.df['close'] - high_lookback) / atr.replace(0, 1e-9)).rename('dynamic_BREAKOUT_PWR')

    def _calc_volume_surge(self, lookback=20):
        avg_amount = self.df['amount'].rolling(window=lookback).mean().shift(1)
        return (self.df['amount'] / avg_amount.replace(0, 1e-9)).rename('dynamic_VOLUME_SURGE')

    def _calc_mom_accel(self, roc_period=5, shift_period=11):
        roc = self.df['close'].pct_change(roc_period)
        roc_shifted = roc.shift(shift_period)
        return ((roc / roc_shifted.replace(0, np.nan)) - 1).rename('dynamic_MOM_ACCEL')

    def _calc_rsi_os(self, length=14):
        return self.df.ta.rsi(close=self.df['close'], length=length).rename('dynamic_RSI_OS')

    def _calc_neg_dev(self, period=60):
        ma = self.df['close'].rolling(window=period).mean()
        return ((self.df['close'] - ma) / ma.replace(0, 1e-9)).rename('dynamic_NEG_DEV')

    def _calc_boll_lb(self, length=20, std=2.0):
        boll = self.df.ta.bbands(close=self.df['close'], length=length, std=std)
        lower_band = boll[f'BBL_{length}_{std}']
        upper_band = boll[f'BBU_{length}_{std}']
        band_width = upper_band - lower_band
        return ((self.df['close'] - lower_band) / band_width.replace(0, 1e-9)).rename('dynamic_BOLL_LB')

    def _calc_low_vol(self, period=20):
        returns = self.df['close'].pct_change()
        return returns.rolling(window=period).std().rename('dynamic_LOW_VOL')

    def _calc_max_dd(self, period=60):
        rolling_max = self.df['close'].rolling(window=period, min_periods=1).max()
        daily_dd = self.df['close'] / rolling_max - 1.0
        return daily_dd.rolling(window=period, min_periods=1).min().rename('dynamic_MAX_DD')

    def _calc_downside_risk(self, period=60):
        returns = self.df['close'].pct_change()
        downside_returns = returns.copy()
        downside_returns[downside_returns > 0] = 0
        return downside_returns.rolling(window=period).std().rename('dynamic_DOWNSIDE_RISK')

    # [同步] 补全与 prepare_csi300_features.py 一致的因子
    def _calc_macd_signal(self, fast=12, slow=26, signal=9):
        macd_df = self.df.ta.macd(fast=fast, slow=slow, signal=signal)
        macd_line = macd_df[f'MACD_{fast}_{slow}_{signal}']
        signal_line = macd_df[f'MACDs_{fast}_{slow}_{signal}']
        factor = (macd_line - signal_line).where(macd_line > 0, 0)
        return factor.rename('dynamic_MACD_SIGNAL')
    
    def _calc_breakout_duration(self, lookback=20):
        high_lookback = self.df['close'].rolling(window=lookback).max().shift(1)
        is_breakout = self.df['close'] > high_lookback
        breakout_streaks = is_breakout.groupby((is_breakout != is_breakout.shift()).cumsum()).cumsum()
        return breakout_streaks.rename('dynamic_BREAKOUT_DURATION')
    

    def _calc_old_d(self, lookback_k=20, a_param=200.0):
        """
        计算老M值体系中的方向函数 D(t)。
        D(t) = tanh(a * h(t,K))
        h(t,K) 是过去K天不同周期线性回归斜率的均值。
        """
        from scipy.stats import linregress # 仅在此方法中需要
        close_prices = self.df['close']
        g_values_list = []
        
        # 为了向量化计算，我们创建一个包含所有需要回归的窗口的DataFrame
        # 对于每个交易日t，我们需要计算从t-k到t的回归，k从1到lookback_k
        for k in range(1, lookback_k + 1):
            # 截取 k+1 个数据点
            windows = close_prices.rolling(window=k + 1)
            
            # 使用apply函数对每个窗口进行线性回归
            # apply函数会比较慢，但对于这种复杂的窗口计算是必要的
            # 注意：linregress需要numpy数组
            slopes = windows.apply(lambda x: linregress(np.arange(len(x)), x).slope, raw=True)
            
            # 获取 t-k 日的收盘价
            close_t_minus_k = close_prices.shift(k)
            
            # 计算 g(t,k)
            g_tk = slopes / close_t_minus_k.replace(0, 1e-9)
            g_values_list.append(g_tk)
        # 将所有g(t,k)的值合并成一个DataFrame
        g_df = pd.concat(g_values_list, axis=1)
        
        # 计算 h(t,K)，即对每一行（每个交易日）的g值求均值
        h_t_k = g_df.mean(axis=1)
        
        # 计算 D(t)
        d_t = np.tanh(a_param * h_t_k)
        
        return d_t.rename('dynamic_Old_D')
    def _calc_old_i(self, adx_period=14, adx_threshold=20.0, b_param=0.075):
        """
        计算老M值体系中的强度函数 I(t)。
        I(t) = max(0, tanh(b * (ADX(t) - threshold)))
        """
        # pandas_ta库可以非常高效地计算ADX
        adx_df = self.df.ta.adx(length=adx_period, high=self.df['high'], low=self.df['low'], close=self.df['close'])
        adx_series = adx_df[f'ADX_{adx_period}']
        
        # 计算 I(t)
        raw_i = np.tanh(b_param * (adx_series - adx_threshold))
        i_t = raw_i.clip(lower=0) # 使用clip实现max(0, raw_i)
        
        return i_t.rename('dynamic_Old_I')
    def _calc_old_m(self):
        """
        计算老M值 OldM(t) = D(t) * I(t)。
        这个因子依赖于 _calc_old_d 和 _calc_old_i 的计算结果。
        为了效率，我们直接在这里调用它们，而不是重复计算。
        """
        # 为了避免重复计算，我们检查这些列是否已存在于一个临时的DataFrame中
        # 但在当前架构下，最简单的做法是重新计算一次，或者修改run方法
        # 这里我们选择直接计算，因为因子计算是独立的
        d_t = self._calc_old_d()
        i_t = self._calc_old_i()
        
        m_t = d_t * i_t
        
        return m_t.rename('dynamic_Old_M')

# ==============================================================================
#  重构后的 M 值预测服务 (Refactored M-Value Prediction Service)
# ==============================================================================
class MValueMLService:
    MODELS_DIR = settings.BASE_DIR / 'selection_manager' / 'ml_models'
    MODEL_FILE = MODELS_DIR / 'm_value_lgbm_model.joblib'
    CONFIG_FILE = MODELS_DIR / 'm_value_model_config.json'
    
    # 因子计算所需的最长回溯期，应大于所有因子中最大的lookback period
    # 例如，neg_dev(60), max_dd(60)等，给足100天buffer
    REQUIRED_LOOKBACK = 100

    def __init__(self):
        self._model = None
        self._config = None
        self._dependencies_loaded = False

    def _load_dependencies(self):
        """懒加载模型和配置文件"""
        if not self.MODEL_FILE.exists() or not self.CONFIG_FILE.exists():
            logger.error("M值模型或配置文件不存在。请先运行 'prepare_csi300_features' 和 'train_csi300_model_test' 命令。")
            return
        try:
            self._model = joblib.load(self.MODEL_FILE)
            with open(self.CONFIG_FILE, 'r') as f:
                self._config = json.load(f)
            logger.info("成功加载M值预测模型 (LightGBM Regressor) 及配置。")
        except Exception as e:
            logger.error(f"加载M值模型依赖时发生错误: {e}", exc_info=True)
            self._model, self._config = None, None
        self._dependencies_loaded = True

    def _prepare_input_data(self, csi300_df: pd.DataFrame) -> pd.DataFrame:
        """
        为单次预测准备特征向量。
        """
        if len(csi300_df) < self.REQUIRED_LOOKBACK:
            raise ValueError(f"输入数据长度不足，需要至少 {self.REQUIRED_LOOKBACK} 天，实际 {len(csi300_df)} 天。")

        df = csi300_df.copy()
        
        # 数据清洗
        numeric_cols = ['open', 'high', 'low', 'close', 'volume', 'amount']
        for col in numeric_cols:
            df[col] = pd.to_numeric(df[col], errors='coerce')
        #df.ffill(inplace=True).bfill(inplace=True)
        df.ffill(inplace=True)
        df.bfill(inplace=True)

        # 计算所有需要的特征
        feature_names = self._config['feature_names']
        calculator = FactorCalculator(df)
        features_df = calculator.run(feature_names)
        
        # 检查计算后的特征是否有NaN，并返回最后一行的特征向量
        latest_features = features_df.iloc[-1]
        if latest_features.isnull().any():
            # 尝试向前填充，以防万一
            latest_features = features_df.ffill().iloc[-1]
            if latest_features.isnull().any():
                 raise ValueError(f"计算出的最新特征向量包含NaN值，无法进行预测。NaNs in: {latest_features[latest_features.isnull()].index.tolist()}")

        return latest_features[feature_names] # 确保特征顺序与训练时一致

    def predict_csi300_next_day_trend(self, csi300_df: pd.DataFrame) -> float:
        """
        使用重构后的ML回归模型直接预测M值。
        M值由模型直接输出，其范围在[-1, 1]之间。
        """
        if not self._dependencies_loaded:
            self._load_dependencies()
        
        if self._model is None or self._config is None:
            logger.warning("M值模型未加载，返回中性值 0.0")
            return 0.0

        try:
            # 1. 准备输入特征向量
            feature_vector = self._prepare_input_data(csi300_df)
            
            # 2. 模型预测
            # 回归模型直接输出预测值
            model_input = feature_vector.to_frame().T 
            m_value = self._model.predict(model_input)[0]
            
            # 3. 裁剪M值确保在[-1, 1]范围内，以防模型预测略微超限
            m_value = np.clip(m_value, -1.0, 1.0)
            
            logger.info(
                f"M值预测: 模型直接输出 M-Value = {m_value:.4f}"
            )
            return float(m_value)
        
        except Exception as e:
            logger.error(f"预测M值过程中发生严重错误: {e}", exc_info=True)
            return 0.0

# 创建全局单例，供下游服务导入
m_value_service_instance = MValueMLService()

####文件结束####

####selection_manager\service\selection_service.py####
# ==============================================================================
# 文件 4/4: selection_manager/service/selection_service.py (重构版)
# 描述: 简化后的选股服务，职责分离，调用新服务获取评分。
# ==============================================================================
import logging
from datetime import date, timedelta
from decimal import Decimal

import pandas as pd
from django.db import transaction
from common.models import IndexQuotesCsi300
from common.models import (
    StockInfo, DailyQuotes, SystemLog, FactorDefinitions, DailyFactorValues,
    StrategyParameters, DailyTradingPlan
)
from .m_value_service import m_value_service_instance # 复用M值预测服务
from .stock_value_service import StockValueService # 引入新的个股评分服务

logger = logging.getLogger(__name__)
MODULE_NAME = '机器学习选股与预案模块'
MARKET_INDICATOR_CODE = '_MARKET_REGIME_INDICATOR_'

class SelectionService:
    """
    [重构版] T-1日收盘后运行的，基于机器学习模型的选股与预案生成服务。
    
    该服务现在将核心的股票评分逻辑委托给 StockValueService，自身职责简化为：
    1. 计算市场状态 M(t)。
    2. 调用 StockValueService 获取所有股票的模型评分。
    3. 基于模型评分生成交易预案。
    4. 保存结果。
    """

    def __init__(self, trade_date: date, mode: str = 'realtime', one_strategy: str = None, preloaded_panels: dict = None):
        if mode not in ['realtime', 'backtest']:
            raise ValueError("模式(mode)必须是 'realtime' 或 'backtest'")

        try:
            latest_trade_date_obj = DailyQuotes.objects.filter(trade_date__lte=trade_date).latest('trade_date')
            self.trade_date = latest_trade_date_obj.trade_date
        except DailyQuotes.DoesNotExist:
            self.trade_date = trade_date
        
        self.mode = mode
        self.params = {}
        self.market_regime_M = 0.0
        self.stock_value_service = StockValueService() # 实例化新的服务
        self.preloaded_panels = preloaded_panels
        logger.debug(f"--- {MODULE_NAME} 初始化 ---")
        logger.debug(f"交易日期 (T-1): {self.trade_date}, 运行模式: {self.mode}")

    def run_selection(self):
        """一键启动全流程的入口方法。"""
        self._log_to_db('INFO', f"机器学习选股流程启动。模式: {self.mode}, 日期: {self.trade_date}")
        try:
            self._load_parameters()
            initial_stock_pool = self._initial_screening()
            if not initial_stock_pool:
                self._log_to_db('WARNING', "初步筛选后无符合条件的股票，流程终止。")
                return

            # 1. 计算市场M值
            self.market_regime_M = self._calculate_market_regime_M(initial_stock_pool)

            # 2. 调用新服务获取所有股票的模型评分
            logger.info("调用StockValueService获取所有股票的模型评分...")
            final_scores = self.stock_value_service.get_all_stock_scores(
                stock_pool=initial_stock_pool,
                trade_date=self.trade_date,
                m_value=self.market_regime_M,
                preloaded_panels=self.preloaded_panels
            )
            final_scores = final_scores.sort_values(ascending=False)

            if final_scores.empty:
                self._log_to_db('WARNING', "模型未对任何股票给出有效评分，流程终止。")
                return
            if self.preloaded_panels:
                plan_panels = self.preloaded_panels
            else:
                # 如果是实时运行，没有预加载数据，需要为TopN股票加载数据
                top_n_codes = final_scores.head(int(self.params.get('dynamic_top_n', 10))).index.tolist()
                plan_panels = self._load_panels_for_plan(top_n_codes)
            trading_plan = self._generate_trading_plan(final_scores, plan_panels)
            # 3. 生成交易预案
            #trading_plan = self._generate_trading_plan(final_scores)
            if trading_plan.empty:
                self._log_to_db('WARNING', "最终未生成任何交易预案。")
                return

            # 4. 保存结果
            self._save_results(final_scores, trading_plan)

            success_msg = f"机器学习选股流程成功完成。M(t)={self.market_regime_M:.4f}, 生成 {len(trading_plan)} 条交易预案。"
            logger.info(success_msg)
            self._log_to_db('INFO', success_msg)

        except Exception as e:
            error_msg = f"机器学习选股流程发生严重错误: {e}"
            logger.critical(error_msg, exc_info=True)
            self._log_to_db('CRITICAL', error_msg)
            raise

    def _load_parameters(self):
        """加载策略参数"""
        logger.debug("加载策略参数...")
        params_qs = StrategyParameters.objects.all()
        self.params = {p.param_name: float(p.param_value) for p in params_qs}
        
    def _initial_screening(self) -> list[str]:
        """初步筛选股票池，逻辑保持不变"""
        logger.debug("开始执行初步筛选...")
        all_stocks = StockInfo.objects.filter(status=StockInfo.StatusChoices.LISTING)
        non_st_stocks = all_stocks.exclude(stock_code__contains='.688').exclude(stock_name__startswith='ST').exclude(stock_name__startswith='*ST')
        
        min_listing_days = self.params.get('dynamic_lookback_new_stock', 60)
        min_listing_date = self.trade_date - timedelta(days=int(min_listing_days))
        non_new_stocks = non_st_stocks.filter(listing_date__lt=min_listing_date)
        
        stock_pool_codes = list(non_new_stocks.values_list('stock_code', flat=True))
        
        lookback_days = 20
        start_date = self.trade_date - timedelta(days=lookback_days * 2)
        quotes = DailyQuotes.objects.filter(
            stock_code_id__in=stock_pool_codes,
            trade_date__gte=start_date,
            trade_date__lte=self.trade_date
        ).values('stock_code_id', 'turnover')

        if not quotes:
            return []

        quotes_df = pd.DataFrame.from_records(quotes)
        avg_turnover = quotes_df.groupby('stock_code_id')['turnover'].mean()
        
        min_liquidity = self.params.get('dynamic_min_liquidity', 100000000)
        liquid_stocks = avg_turnover[avg_turnover >= min_liquidity]
        
        final_stock_pool = list(liquid_stocks.index)
        logger.debug(f"初步筛选后，最终剩余 {len(final_stock_pool)} 只股票进入精选池。")
        return final_stock_pool

    def _calculate_market_regime_M(self, stock_pool: list[str]) -> float:
        """
        计算市场状态函数 M(t)
        """
        
        # =======================================================================
        # [ML预测接口] - 未来切换到机器学习模型预测M值的入口
        # =======================================================================
        try:
            # 1. 获取最近60个交易日的数据
            quotes_60_days_qs = IndexQuotesCsi300.objects.filter(
                trade_date__lte=self.trade_date
            ).order_by('-trade_date')[:100]
            
            if len(quotes_60_days_qs) < 100:
                logger.warning("沪深300数据不足100天，无法使用ML模型进行预测，将回退到传统方法。")
            else:
                # [修复] 从QuerySet直接构建DataFrame
                df_60_days_raw = pd.DataFrame.from_records(quotes_60_days_qs.values())
                
                # 反转顺序使日期从旧到新
                df_60_days = df_60_days_raw.iloc[::-1].reset_index(drop=True)
                
                # 2. 调用预测服务 (m_value_service内部会处理类型转换)
                ml_m_value = m_value_service_instance.predict_csi300_next_day_trend(df_60_days)
                
                # 3. 【重要】将ML预测结果存入缓存
                DailyFactorValues.objects.update_or_create(
                    stock_code_id=MARKET_INDICATOR_CODE,
                    trade_date=self.trade_date,
                    factor_code_id='dynamic_M_VALUE',
                    defaults={'raw_value': Decimal(str(ml_m_value)), 'norm_score': Decimal(str(ml_m_value))}
                )
                logger.info(f"已使用ML模型预测M(t) = {ml_m_value:.4f}")
                return ml_m_value
        except Exception as e:
            logger.error(f"调用ML模型预测M值时发生错误: {e}", exc_info=True)

    def _generate_trading_plan(self, final_scores: pd.Series, panels: dict) -> pd.DataFrame:
        """基于模型评分和面板数据生成交易预案"""
        logger.debug("基于模型评分生成交易预案...")
        top_n = int(self.params.get('dynamic_top_n', 10))
        top_stocks_scores = final_scores.head(top_n)
        
        if top_stocks_scores.empty:
            return pd.DataFrame()
        top_stock_codes = top_stocks_scores.index.tolist()
        
        # --- [关键修正] 开始 ---
        # 不再从数据库加载，直接使用传入的panels
        if not panels or 'close' not in panels:
            logger.error("生成交易预案时未提供有效的面板数据。")
            return pd.DataFrame()
        # 注意：MIOP/MAOP的计算应该基于不复权价格，但ATR也需要不复权价格
        # 我们需要确保传入的panels包含不复权价格。
        # 假设回测框架传入的panels已经是处理好的，包含了所需列。
        # 如果没有，我们需要在这里进行处理，但为了保持与你原设计一致，我们假设panels是OK的。
        # 这里的逻辑需要和你的回测框架传入的数据格式对齐。
        # 假设你的回测框架传入的panels的 'close', 'high', 'low' 是不复权价。
        close_panel = panels['close']
        high_panel = panels['high']
        low_panel = panels['low']
        last_close_series = close_panel.iloc[-1].reindex(top_stock_codes)
        # 简单的日内波幅作为ATR
        last_atr_series = (high_panel.iloc[-1] - low_panel.iloc[-1]).reindex(top_stock_codes)
        # --- [关键修正] 结束 ---
        k_gap = self.params.get('k_gap', 0.5)
        k_drop = self.params.get('k_drop', 0.3)
        plans = []
        for stock_code, score in top_stocks_scores.items():
            close_price = last_close_series.get(stock_code)
            atr = last_atr_series.get(stock_code)
            if pd.isna(close_price) or pd.isna(atr):
                continue
            
            miop = Decimal(str(close_price)) - Decimal(str(k_drop)) * Decimal(str(atr))
            maop = Decimal(str(close_price)) + Decimal(str(k_gap)) * Decimal(str(atr))
            plans.append({
                'stock_code': stock_code,
                'rank': len(plans) + 1,
                'final_score': score,
                'miop': miop,
                'maop': maop,
            })
        
        return pd.DataFrame(plans)
    

    def _load_panels_for_plan(self, stock_codes: list) -> dict:
        """在实时模式下，为生成交易预案加载所需的不复权价格面板"""
        if not stock_codes:
            return {}
        
        start_date = self.trade_date - timedelta(days=30) # ATR计算通常不需要很长回溯
        quotes_qs = DailyQuotes.objects.filter(
            stock_code_id__in=stock_codes,
            trade_date__gte=start_date,
            trade_date__lte=self.trade_date
        ).values('trade_date', 'stock_code_id', 'close', 'high', 'low')
        if not quotes_qs:
            return {}
            
        df = pd.DataFrame.from_records(quotes_qs)
        panels = {}
        for col in ['close', 'high', 'low']:
            df[col] = pd.to_numeric(df[col], errors='coerce')
            panel = df.pivot(index='trade_date', columns='stock_code_id', values=col)
            panels[col] = panel
        return panels

    @transaction.atomic
    def _save_results(self, final_scores: pd.Series, trading_plan_df: pd.DataFrame):
        """保存模型评分和交易预案"""
        logger.debug("开始将结果保存到数据库...")

        # 1. 保存模型评分到 DailyFactorValues
        factor_values_to_create = []
        for stock_code, score in final_scores.items():
            factor_values_to_create.append(
                DailyFactorValues(
                    stock_code_id=stock_code,
                    trade_date=self.trade_date,
                    factor_code_id='ML_STOCK_SCORE', # 新因子
                    raw_value=Decimal(str(score)),
                    norm_score=Decimal(str(score)) # 评分本身就是标准化的，直接存
                )
            )
        
        # 先删除当日旧的ML_STOCK_SCORE，再批量创建
        DailyFactorValues.objects.filter(
            trade_date=self.trade_date,
            factor_code_id='ML_STOCK_SCORE'
        ).delete()
        DailyFactorValues.objects.bulk_create(factor_values_to_create, batch_size=1000)
        logger.debug(f"已保存 {len(factor_values_to_create)} 条个股模型评分。")

        # 2. 保存交易预案
        plan_date = self.trade_date + timedelta(days=1)
        DailyTradingPlan.objects.filter(plan_date=plan_date).delete()
        
        plans_to_create = []
        for _, row in trading_plan_df.iterrows():
            plans_to_create.append(
                DailyTradingPlan(
                    plan_date=plan_date, stock_code_id=row['stock_code'],
                    rank=row['rank'], final_score=Decimal(str(row['final_score'])),
                    miop=row['miop'].quantize(Decimal('0.01')),
                    maop=row['maop'].quantize(Decimal('0.01')),
                    status=DailyTradingPlan.StatusChoices.PENDING,
                    strategy_dna="ML_MODEL:1.00" # 策略DNA现在固定为模型
                )
            )
        DailyTradingPlan.objects.bulk_create(plans_to_create)
        logger.debug(f"已保存 {len(plans_to_create)} 条交易预案。")

    def _log_to_db(self, level, message):
        logger.info(message)
        # 在回测等高性能场景下可以关闭
        # SystemLog.objects.create(log_level=level, module_name=MODULE_NAME, message=message)
        pass


####文件结束####

####selection_manager\service\stock_value_service.py####
# ==============================================================================
# 文件: selection_manager/service/stock_value_service.py (终极性能优化版)
# 描述: 提供个股模型评分的服务，使用完全向量化的因子计算引擎。
# ==============================================================================
import logging
import json
from pathlib import Path
from datetime import timedelta

import numpy as np
import pandas as pd
import joblib
from django.conf import settings
from scipy.stats import linregress

from common.models import DailyQuotes

logger = logging.getLogger(__name__)

# 因子计算所需的最大回溯期
FACTOR_LOOKBACK_BUFFER = 100

# ==============================================================================
#  高效向量化因子计算引擎 (High-Performance Vectorized Factor Engine)
# ==============================================================================
class VectorizedFactorEngine:
    """
    一个完全向量化的因子计算引擎。
    它接收面板数据，并一次性计算所有股票的因子值。
    """
    def __init__(self, panel_data: dict, feature_names: list):
        self.open = panel_data['open']
        self.high = panel_data['high']
        self.low = panel_data['low']
        self.close = panel_data['close']
        self.volume = panel_data['volume']
        self.amount = panel_data['amount']
        self.feature_names = feature_names
        self.epsilon = 1e-9
    def run(self) -> pd.DataFrame:
        calculator_methods = {
            'dynamic_ADX_CONFIRM': self._calc_adx_confirm,
            'dynamic_v2_MA_SLOPE': self._calc_v2_ma_slope,
            'dynamic_v2_MA_SCORE': self._calc_v2_ma_score,
            'dynamic_v2_CPC_Factor': self._calc_v2_cpc_factor,
            'dynamic_v2_VPCF': self._calc_v2_vpcf,
            'dynamic_BREAKOUT_PWR': self._calc_breakout_pwr,
            'dynamic_VOLUME_SURGE': self._calc_volume_surge,
            'dynamic_MOM_ACCEL': self._calc_mom_accel,
            'dynamic_RSI_OS': self._calc_rsi_os,
            'dynamic_NEG_DEV': self._calc_neg_dev,
            'dynamic_BOLL_LB': self._calc_boll_lb,
            'dynamic_LOW_VOL': self._calc_low_vol,
            'dynamic_MAX_DD': self._calc_max_dd,
            'dynamic_DOWNSIDE_RISK': self._calc_downside_risk,
            'dynamic_Old_D': self._calc_old_d,
            'dynamic_Old_I': self._calc_old_i,
            'dynamic_Old_M': self._calc_old_m,
        }
        all_factors = {}
        for factor_name in self.feature_names:
            if factor_name in calculator_methods:
                logger.debug(f"Vectorized calculation for: {factor_name}")
                all_factors[factor_name] = calculator_methods[factor_name]()
        return pd.DataFrame(all_factors)
    def _calculate_tr(self):
        """[内部辅助函数] 统一计算真实波幅 (True Range)"""
        tr1 = self.high - self.low
        tr2 = abs(self.high - self.close.shift(1))
        tr3 = abs(self.low - self.close.shift(1))
        return np.maximum(tr1, np.maximum(tr2, tr3))
    def _calc_adx_confirm(self, length=14, adx_threshold=25):
        move_up = self.high.diff()
        move_down = -self.low.diff()
        plus_dm = pd.DataFrame(np.where((move_up > move_down) & (move_up > 0), move_up, 0.0), index=self.high.index, columns=self.high.columns)
        minus_dm = pd.DataFrame(np.where((move_down > move_up) & (move_down > 0), move_down, 0.0), index=self.low.index, columns=self.low.columns)
        
        tr = self._calculate_tr() # 调用统一的TR计算函数
        alpha = 1 / length
        atr = tr.ewm(alpha=alpha, adjust=False).mean()
        plus_di = 100 * (plus_dm.ewm(alpha=alpha, adjust=False).mean() / (atr + self.epsilon))
        minus_di = 100 * (minus_dm.ewm(alpha=alpha, adjust=False).mean() / (atr + self.epsilon))
        
        di_sum = plus_di + minus_di
        dx = 100 * (abs(plus_di - minus_di) / di_sum.replace(0, np.inf))
        adx = dx.ewm(alpha=alpha, adjust=False).mean()
        
        condition = (adx.iloc[-1] > adx_threshold) & (plus_di.iloc[-1] > minus_di.iloc[-1])
        return adx.iloc[-1].where(condition, 0.0)
    def _calc_v2_ma_slope(self, ma_period=20, ema_period=20):
        ma = self.close.rolling(window=ma_period).mean()
        ma_roc = ma.pct_change(1)
        return ma_roc.ewm(span=ema_period, adjust=False).mean().iloc[-1]
    def _calc_v2_ma_score(self, p1=5, p2=10, p3=20):
        ma5 = self.close.rolling(window=p1).mean()
        ma10 = self.close.rolling(window=p2).mean()
        ma20 = self.close.rolling(window=p3).mean()
        spread1 = (self.close - ma5) / (ma5 + self.epsilon)
        spread2 = (ma5 - ma10) / (ma10 + self.epsilon)
        spread3 = (ma10 - ma20) / (ma20 + self.epsilon)
        return ((spread1 + spread2 + spread3) / 3.0).iloc[-1]
    def _calc_v2_cpc_factor(self, ema_period=10):
        price_range = self.high - self.low
        dcp = (2 * self.close - self.high - self.low) / (price_range + self.epsilon)
        return dcp.ewm(span=ema_period, adjust=False).mean().iloc[-1]
    def _calc_v2_vpcf(self, s=5, l=20, n_smooth=5):
        ma_close_s = self.close.rolling(window=s).mean()
        price_momentum = ma_close_s.pct_change(1)
        ma_amount_s = self.amount.rolling(window=s).mean()
        ma_amount_l = self.amount.rolling(window=l).mean()
        volume_level = (ma_amount_s / (ma_amount_l + self.epsilon)) - 1
        daily_score = price_momentum * volume_level
        return daily_score.ewm(span=n_smooth, adjust=False).mean().iloc[-1]
    def _calc_breakout_pwr(self, lookback=60, atr_period=14):
        high_lookback = self.high.rolling(window=lookback).max().shift(1)
        
        tr = self._calculate_tr() # 调用统一的TR计算函数
        atr = tr.ewm(alpha=1/atr_period, adjust=False).mean()
        
        return ((self.close - high_lookback) / (atr + self.epsilon)).iloc[-1]
    def _calc_volume_surge(self, lookback=20):
        avg_amount = self.amount.rolling(window=lookback).mean().shift(1)
        return (self.amount / (avg_amount + self.epsilon)).iloc[-1]
    def _calc_mom_accel(self, roc_period=5, shift_period=11):
        roc = self.close.pct_change(roc_period)
        roc_shifted = roc.shift(shift_period)
        # 使用 where 避免分母为0时产生 inf
        acceleration = (roc / roc_shifted).where(roc_shifted != 0, 1) - 1
        return acceleration.iloc[-1]
    def _calc_rsi_os(self, length=14):
        delta = self.close.diff()
        gain = delta.clip(lower=0)
        loss = -delta.clip(upper=0)
        avg_gain = gain.ewm(com=length - 1, adjust=False).mean()
        avg_loss = loss.ewm(com=length - 1, adjust=False).mean()
        rs = avg_gain / (avg_loss + self.epsilon)
        return (100 - (100 / (1 + rs))).iloc[-1]
    def _calc_neg_dev(self, period=60):
        ma = self.close.rolling(window=period).mean()
        return ((self.close - ma) / (ma + self.epsilon)).iloc[-1]
    def _calc_boll_lb(self, length=20, std=2.0):
        ma = self.close.rolling(window=length).mean()
        rolling_std = self.close.rolling(window=length).std()
        upper_band = ma + (rolling_std * std)
        lower_band = ma - (rolling_std * std)
        band_width = upper_band - lower_band
        return ((self.close - lower_band) / (band_width + self.epsilon)).iloc[-1]
    def _calc_low_vol(self, period=20):
        returns = self.close.pct_change()
        return returns.rolling(window=period).std().iloc[-1]
    def _calc_max_dd(self, period=60):
        rolling_max = self.close.rolling(window=period, min_periods=1).max()
        daily_dd = self.close / rolling_max - 1.0
        return daily_dd.rolling(window=period, min_periods=1).min().iloc[-1]
    def _calc_downside_risk(self, period=60):
        returns = self.close.pct_change()
        downside_returns = returns.clip(upper=0)
        return downside_returns.rolling(window=period).std().iloc[-1]
    def _calc_old_d(self, lookback_k=20, a_param=200.0):
        slopes = {}
        x_range = np.arange(lookback_k + 1)
        for stock_code in self.close.columns:
            series = self.close[stock_code].dropna()
            if len(series) < lookback_k + 1:
                slopes[stock_code] = np.nan
                continue
            
            y = series.iloc[-lookback_k-1:].values
            # 增加对y中NaN值的检查
            if np.isnan(y).any():
                slopes[stock_code] = np.nan
                continue
            slope, _, _, _, _ = linregress(x_range, y)
            denominator = series.iloc[-lookback_k-1]
            h_t_k = slope / (denominator + self.epsilon) if denominator != 0 else 0
            slopes[stock_code] = np.tanh(a_param * h_t_k)
        return pd.Series(slopes)
    def _calc_old_i(self, adx_period=14, adx_threshold=20.0, b_param=0.075):
        move_up = self.high.diff()
        move_down = -self.low.diff()
        plus_dm = pd.DataFrame(np.where((move_up > move_down) & (move_up > 0), move_up, 0.0), index=self.high.index, columns=self.high.columns)
        minus_dm = pd.DataFrame(np.where((move_down > move_up) & (move_down > 0), move_down, 0.0), index=self.low.index, columns=self.low.columns)
        
        tr = self._calculate_tr() # 调用统一的TR计算函数
        alpha = 1 / adx_period
        atr = tr.ewm(alpha=alpha, adjust=False).mean()
        plus_di = 100 * (plus_dm.ewm(alpha=alpha, adjust=False).mean() / (atr + self.epsilon))
        minus_di = 100 * (minus_dm.ewm(alpha=alpha, adjust=False).mean() / (atr + self.epsilon))
        di_sum = plus_di + minus_di
        dx = 100 * (abs(plus_di - minus_di) / di_sum.replace(0, np.inf))
        adx = dx.ewm(alpha=alpha, adjust=False).mean().iloc[-1]
        
        raw_i = np.tanh(b_param * (adx - adx_threshold))
        return raw_i.clip(lower=0)
    def _calc_old_m(self):
        d_t = self._calc_old_d()
        i_t = self._calc_old_i()
        return d_t * i_t

# ==============================================================================
#  主服务 (Main Service)
# ==============================================================================
class StockValueService:
    MODELS_DIR = settings.BASE_DIR / 'selection_manager' / 'ml_models'
    MODEL_FILE = MODELS_DIR / 'stock_lgbm_model.joblib'
    CONFIG_FILE = MODELS_DIR / 'stock_model_config.json'

    def __init__(self):
        self._model = None
        self._config = None
        self._feature_names = []
        self._dependencies_loaded = False
        self._load_dependencies()

    def _load_dependencies(self):
        if not self.MODEL_FILE.exists() or not self.CONFIG_FILE.exists():
            logger.error("个股评分模型或配置文件不存在。")
            return
        try:
            self._model = joblib.load(self.MODEL_FILE)
            with open(self.CONFIG_FILE, 'r') as f:
                self._config = json.load(f)
            self._feature_names = self._config['feature_names']
            logger.info("成功加载个股评分模型及配置。")
            self._dependencies_loaded = True
        except Exception as e:
            logger.error(f"加载个股评分模型依赖时出错: {e}", exc_info=True)

    def get_all_stock_scores(self, stock_pool: list, trade_date, m_value: float, preloaded_panels: dict = None) -> pd.Series:
        if not self._dependencies_loaded:
            logger.warning("模型未加载，返回空评分列表。")
            return pd.Series(dtype=float)
        panel_data = {}
        # --- [关键修正] 开始 ---
        if preloaded_panels:
            logger.debug("StockValueService 检测到预加载面板数据，直接使用。")
            # 直接使用预加载的数据，但要确保列名是 'amount'
            panel_data = preloaded_panels.copy()
            if 'turnover' in panel_data and 'amount' not in panel_data:
                panel_data['amount'] = panel_data.pop('turnover')
        else:
            logger.info("未提供预加载面板，StockValueService 将从数据库加载数据...")
            # 1. 高效加载数据 (回退逻辑)
            start_date = trade_date - timedelta(days=FACTOR_LOOKBACK_BUFFER * 2)
            quotes_qs = DailyQuotes.objects.filter(
                stock_code_id__in=stock_pool,
                trade_date__gte=start_date,
                trade_date__lte=trade_date
            ).values('trade_date', 'stock_code_id', 'open', 'high', 'low', 'close', 'volume', 'turnover', 'hfq_close')
            
            if not quotes_qs:
                logger.warning("在指定日期范围内未找到任何股票行情数据。")
                return pd.Series(dtype=float)
            all_quotes_df = pd.DataFrame.from_records(quotes_qs)
            
            # 2. 预处理：价格复权和列名统一
            logger.info("正在进行价格后复权处理...")
            numeric_cols = ['open', 'high', 'low', 'close', 'volume', 'turnover', 'hfq_close']
            for col in numeric_cols:
                all_quotes_df[col] = pd.to_numeric(all_quotes_df[col], errors='coerce')
            
            all_quotes_df['adj_factor'] = all_quotes_df['hfq_close'] / (all_quotes_df['close'] + 1e-9)
            
            all_quotes_df['open'] = all_quotes_df['open'] * all_quotes_df['adj_factor']
            all_quotes_df['high'] = all_quotes_df['high'] * all_quotes_df['adj_factor']
            all_quotes_df['low'] = all_quotes_df['low'] * all_quotes_df['adj_factor']
            all_quotes_df['close'] = all_quotes_df['hfq_close']
            all_quotes_df.rename(columns={'turnover': 'amount'}, inplace=True)
            # 3. 构建面板数据
            logger.info("构建面板数据...")
            for col in ['open', 'high', 'low', 'close', 'volume', 'amount']:
                panel = all_quotes_df.pivot(index='trade_date', columns='stock_code_id', values=col)
                full_date_range = pd.date_range(start=panel.index.min(), end=panel.index.max(), freq='B')
                panel = panel.reindex(full_date_range).ffill()
                panel_data[col] = panel
        # --- [关键修正] 结束 ---
        # 4. 使用向量化引擎计算所有特征
        logger.info("启动向量化因子计算引擎...")
        features_to_calc = [f for f in self._feature_names if f != 'market_m_value']
        engine = VectorizedFactorEngine(panel_data, features_to_calc)
        features_df = engine.run()

        # 4. 准备模型输入
        logger.info("准备模型输入并进行预测...")
        features_df['market_m_value'] = m_value
        features_df.dropna(inplace=True)
        
        if features_df.empty:
            logger.warning("所有股票在特征计算后都因NaN被剔除。")
            return pd.Series(dtype=float)

        # 保证特征顺序和数据类型
        model_input = features_df[self._feature_names].astype(float)
        
        # 5. 一次性预测所有股票
        scores = self._model.predict(model_input)
        
        # 6. 组装成最终的Series
        final_scores = pd.Series(scores, index=model_input.index)
        
        logger.info(f"成功为 {len(final_scores)} 只股票计算了模型评分。")
        return final_scores

####文件结束####

####selection_manager\management\commands\generate_m_value_csv.py####
# selection_manager/management/commands/generate_m_value_csv.py

import logging
import os
from decimal import Decimal

import pandas as pd
from django.conf import settings
from django.core.management.base import BaseCommand
from tqdm import tqdm

from common.models import IndexQuotesCsi300
from selection_manager.service.selection_service import SelectionService

# 获取logger实例
logger = logging.getLogger(__name__)

class Command(BaseCommand):
    """
    一个Django管理命令，用于计算沪深300指数从2010-08-19至2025-08-18的
    完整历史M值，并生成一个CSV文件供分析脚本使用。
    
    运行方式:
    python manage.py generate_m_value_csv
    """
    help = '计算沪深300历史M值并生成 m_value_csi300.csv 文件'

    def handle(self, *args, **options):
        self.stdout.write(self.style.SUCCESS('===== 开始计算沪深300历史M值 ====='))

        try:
            # 1. 一次性从数据库加载所有需要的沪深300行情数据
            self.stdout.write("正在从数据库加载沪深300历史行情数据...")
            quotes_qs = IndexQuotesCsi300.objects.all().order_by('trade_date').values('trade_date', 'close')
            if not quotes_qs:
                self.stdout.write(self.style.ERROR("错误：数据库表 tb_index_quotes_csi300 中没有数据。请先回填数据。"))
                return
            
            all_quotes_df = pd.DataFrame.from_records(quotes_qs)
            all_dates = all_quotes_df['trade_date'].tolist()
            self.stdout.write(f"数据加载完成，共 {len(all_dates)} 个交易日。")

            # 2. 初始化SelectionService并加载一次参数
            # 使用第一个日期进行初始化，后续在循环中更新日期
            service = SelectionService(trade_date=all_dates[0], mode='backtest')
            service._load_dynamic_parameters_and_defs()
            self.stdout.write("策略服务和参数初始化完成。")

            # 3. 循环计算每一天的M值
            results = []
            self.stdout.write("开始逐日计算M值...")
            LOOKBACK_BUFFER = 100
            if len(all_dates) <= LOOKBACK_BUFFER:
                self.stdout.write(self.style.ERROR(f"错误：总交易日数 ({len(all_dates)}) 不足以满足 {LOOKBACK_BUFFER} 天的回溯期。"))
                return
            # 使用tqdm创建进度条
            for current_date in tqdm(all_dates[LOOKBACK_BUFFER:], desc="计算M值进度"):
                # 更新服务的交易日期
                service.trade_date = current_date
                
                # 调用核心方法计算M值，按要求传入空stock_pool
                m_value = service._calculate_market_regime_M(stock_pool=[])
                
                # 从已加载的DataFrame中获取收盘价
                close_price = all_quotes_df.loc[all_quotes_df['trade_date'] == current_date, 'close'].iloc[0]
                
                results.append({
                    '日期': current_date,
                    'm值': m_value,
                    '沪深300收盘指数': float(close_price) # 转换为float以便pandas处理
                })

            if not results:
                self.stdout.write(self.style.WARNING("计算完成，但没有生成任何结果。"))
                return

            # 4. 将结果转换为DataFrame并保存为CSV
            self.stdout.write("所有M值计算完成，正在生成CSV文件...")
            results_df = pd.DataFrame(results)
            
            # 定义输出路径为项目根目录
            output_path = os.path.join(settings.BASE_DIR, 'm_value_csi300.csv')
            
            # 保存文件，使用 utf-8-sig 编码以确保Excel能正确打开
            results_df.to_csv(output_path, index=False, encoding='utf-8-sig', float_format='%.4f')

            self.stdout.write(self.style.SUCCESS(f"\n===== 任务成功完成！ ====="))
            self.stdout.write(f"文件已保存至: {output_path}")
            self.stdout.write(f"现在你可以运行 [M值关系分析.py] 脚本了。")

        except Exception as e:
            self.stdout.write(self.style.ERROR(f"任务执行过程中发生严重错误: {e}"))
            logger.error("生成M值CSV文件失败", exc_info=True)


####文件结束####

####selection_manager\management\commands\prepare_csi300_features.py####
# selection_manager/management/commands/prepare_csi300_features.py

import logging
import pickle
import json
from pathlib import Path

import numpy as np
import pandas as pd
import pandas_ta as ta
from django.core.management.base import BaseCommand
from django.conf import settings
from tqdm import tqdm

from common.models import IndexQuotesCsi300

logger = logging.getLogger(__name__)

# ==============================================================================
#  特征配置中心 (Pluggable Feature Configuration)
# ==============================================================================
# 通过修改此字典的True/False值，可以控制哪些特征被用于训练。
# 这是实现“可插拔”设计的核心。
FEATURE_CONFIG = {
    # 趋势动能 (MT) 维度
    'dynamic_ADX_CONFIRM': True,
    'dynamic_v2_MA_SLOPE': True,
    'dynamic_v2_MA_SCORE': True,
    'dynamic_v2_CPC_Factor': True,
    'dynamic_v2_VPCF': True,
    
    # 强势突破 (BO) 维度
    'dynamic_BREAKOUT_PWR': True,
    'dynamic_VOLUME_SURGE': True,
    'dynamic_MOM_ACCEL': True,

    # 均值回归 (MR) 维度
    'dynamic_RSI_OS': True,
    'dynamic_NEG_DEV': True,
    'dynamic_BOLL_LB': True,

    # 质量防御 (QD) 维度
    'dynamic_LOW_VOL': True,
    'dynamic_MAX_DD': True,
    'dynamic_DOWNSIDE_RISK': True,

    # 新因子
    'dynamic_MACD_SIGNAL': False,

    'dynamic_BREAKOUT_DURATION': False,

    # --- 老M值体系因子 ---
    'dynamic_Old_D': True,
    'dynamic_Old_I': True,
    'dynamic_Old_M': True,
}

# ==============================================================================
#  独立的因子计算器 (Decoupled Factor Calculator)
# ==============================================================================
class FactorCalculator:
    """
    一个独立的、解耦的因子计算器。
    它只接收一个标准的OHLCVA DataFrame，并计算所有预定义的因子。
    这个类将被复制到 m_value_service.py 中以保持解耦。
    """
    def __init__(self, df: pd.DataFrame):
        if not all(col in df.columns for col in ['open', 'high', 'low', 'close', 'volume', 'amount']):
            raise ValueError("输入DataFrame必须包含 'open', 'high', 'low', 'close', 'volume', 'amount' 列")
        self.df = df.copy()
        # 确保 pandas_ta 不会打印不必要的信息
        ta.Imports["verbose"] = False

    def run(self, config: dict) -> (pd.DataFrame, list):
        """
        根据配置运行所有启用的因子计算。
        返回一个包含所有因子值的DataFrame和使用的因子列表。
        """
        all_factors_df = pd.DataFrame(index=self.df.index)
        enabled_factors = []

        # 获取所有可用的计算方法
        calculator_methods = {
            'dynamic_ADX_CONFIRM': self._calc_adx_confirm,
            'dynamic_v2_MA_SLOPE': self._calc_v2_ma_slope,
            'dynamic_v2_MA_SCORE': self._calc_v2_ma_score,
            'dynamic_v2_CPC_Factor': self._calc_v2_cpc_factor,
            'dynamic_v2_VPCF': self._calc_v2_vpcf,
            'dynamic_BREAKOUT_PWR': self._calc_breakout_pwr,
            'dynamic_VOLUME_SURGE': self._calc_volume_surge,
            'dynamic_MOM_ACCEL': self._calc_mom_accel,
            'dynamic_RSI_OS': self._calc_rsi_os,
            'dynamic_NEG_DEV': self._calc_neg_dev,
            'dynamic_BOLL_LB': self._calc_boll_lb,
            'dynamic_LOW_VOL': self._calc_low_vol,
            'dynamic_MAX_DD': self._calc_max_dd,
            'dynamic_DOWNSIDE_RISK': self._calc_downside_risk,
            'dynamic_MACD_SIGNAL':self._calc_macd_signal,
            'dynamic_BREAKOUT_DURATION':self._calc_breakout_duration,
             # --- 新增老M值体系因子 ---
            'dynamic_Old_D': self._calc_old_d,
            'dynamic_Old_I': self._calc_old_i,
            'dynamic_Old_M': self._calc_old_m,
        }

        for factor_name, is_enabled in config.items():
            if is_enabled:
                if factor_name in calculator_methods:
                    logger.debug(f"Calculating factor: {factor_name}")
                    factor_series = calculator_methods[factor_name]()
                    all_factors_df[factor_name] = factor_series
                    enabled_factors.append(factor_name)
                else:
                    logger.warning(f"Factor '{factor_name}' is enabled in config but no calculation method found.")
        
        return all_factors_df, enabled_factors

    # --- 趋势动能 (MT) 因子 ---
    def _calc_adx_confirm(self, length=14, adx_threshold=25):
        adx_df = self.df.ta.adx(length=length, high=self.df['high'], low=self.df['low'], close=self.df['close'])
        adx_col, dmp_col, dmn_col = f'ADX_{length}', f'DMP_{length}', f'DMN_{length}'
        condition = (adx_df[adx_col] > adx_threshold) & (adx_df[dmp_col] > adx_df[dmn_col])
        return adx_df[adx_col].where(condition, 0.0).rename('dynamic_ADX_CONFIRM')

    def _calc_v2_ma_slope(self, ma_period=20, ema_period=20):
        ma = self.df['close'].rolling(window=ma_period).mean()
        ma_roc = ma.pct_change(1)
        return ma_roc.ewm(span=ema_period, adjust=False).mean().rename('dynamic_v2_MA_SLOPE')

    def _calc_v2_ma_score(self, p1=5, p2=10, p3=20):
        close = self.df['close']
        ma5 = close.rolling(window=p1).mean()
        ma10 = close.rolling(window=p2).mean()
        ma20 = close.rolling(window=p3).mean()
        spread1 = (close - ma5) / ma5.replace(0, 1e-9)
        spread2 = (ma5 - ma10) / ma10.replace(0, 1e-9)
        spread3 = (ma10 - ma20) / ma20.replace(0, 1e-9)
        return ((spread1 + spread2 + spread3) / 3.0).rename('dynamic_v2_MA_SCORE')

    def _calc_v2_cpc_factor(self, ema_period=10):
        high, low, close = self.df['high'], self.df['low'], self.df['close']
        price_range = high - low
        dcp = (2 * close - high - low) / price_range.replace(0, 1e-9)
        return dcp.ewm(span=ema_period, adjust=False).mean().rename('dynamic_v2_CPC_Factor')

    def _calc_v2_vpcf(self, s=5, l=20, n_smooth=5):
        ma_close_s = self.df['close'].rolling(window=s).mean()
        price_momentum = ma_close_s.pct_change(1)
        ma_amount_s = self.df['amount'].rolling(window=s).mean()
        ma_amount_l = self.df['amount'].rolling(window=l).mean()
        volume_level = (ma_amount_s / ma_amount_l.replace(0, 1e-9)) - 1
        daily_score = price_momentum * volume_level
        return daily_score.ewm(span=n_smooth, adjust=False).mean().rename('dynamic_v2_VPCF')

    # --- 强势突破 (BO) 因子 ---
    def _calc_breakout_pwr(self, lookback=60, atr_period=14):
        high_lookback = self.df['high'].rolling(window=lookback).max().shift(1)
        atr = self.df.ta.atr(length=atr_period, high=self.df['high'], low=self.df['low'], close=self.df['close'])
        return ((self.df['close'] - high_lookback) / atr.replace(0, 1e-9)).rename('dynamic_BREAKOUT_PWR')

    def _calc_volume_surge(self, lookback=20):
        avg_amount = self.df['amount'].rolling(window=lookback).mean().shift(1)
        return (self.df['amount'] / avg_amount.replace(0, 1e-9)).rename('dynamic_VOLUME_SURGE')

    def _calc_mom_accel(self, roc_period=5, shift_period=11):
        roc = self.df['close'].pct_change(roc_period)
        roc_shifted = roc.shift(shift_period)
        return ((roc / roc_shifted.replace(0, np.nan)) - 1).rename('dynamic_MOM_ACCEL')

    # --- 均值回归 (MR) 因子 ---
    def _calc_rsi_os(self, length=14):
        return self.df.ta.rsi(close=self.df['close'], length=length).rename('dynamic_RSI_OS')

    def _calc_neg_dev(self, period=60):
        ma = self.df['close'].rolling(window=period).mean()
        return ((self.df['close'] - ma) / ma.replace(0, 1e-9)).rename('dynamic_NEG_DEV')

    def _calc_boll_lb(self, length=20, std=2.0):
        boll = self.df.ta.bbands(close=self.df['close'], length=length, std=std)
        lower_band = boll[f'BBL_{length}_{std}']
        upper_band = boll[f'BBU_{length}_{std}']
        band_width = upper_band - lower_band
        return ((self.df['close'] - lower_band) / band_width.replace(0, 1e-9)).rename('dynamic_BOLL_LB')

    # --- 质量防御 (QD) 因子 ---
    def _calc_low_vol(self, period=20):
        returns = self.df['close'].pct_change()
        return returns.rolling(window=period).std().rename('dynamic_LOW_VOL')

    def _calc_max_dd(self, period=60):
        rolling_max = self.df['close'].rolling(window=period, min_periods=1).max()
        daily_dd = self.df['close'] / rolling_max - 1.0
        return daily_dd.rolling(window=period, min_periods=1).min().rename('dynamic_MAX_DD')

    def _calc_downside_risk(self, period=60):
        returns = self.df['close'].pct_change()
        downside_returns = returns.copy()
        downside_returns[downside_returns > 0] = 0
        return downside_returns.rolling(window=period).std().rename('dynamic_DOWNSIDE_RISK')
    
    # --- 新因子 ---
    def _calc_macd_signal(self, fast=12, slow=26, signal=9):
        macd_df = self.df.ta.macd(fast=fast, slow=slow, signal=signal)
        macd_line = macd_df[f'MACD_{fast}_{slow}_{signal}']
        signal_line = macd_df[f'MACDs_{fast}_{slow}_{signal}']
        # 因子定义为：MACD线上穿信号线的强度，且MACD线在0轴之上
        factor = (macd_line - signal_line).where(macd_line > 0, 0)
        return factor.rename('dynamic_MACD_SIGNAL')
    
    def _calc_breakout_duration(self, lookback=20):
        high_lookback = self.df['close'].rolling(window=lookback).max().shift(1)
        is_breakout = self.df['close'] > high_lookback
        
        # 计算连续为True的天数
        breakout_streaks = is_breakout.groupby((is_breakout != is_breakout.shift()).cumsum()).cumsum()
        return breakout_streaks.rename('dynamic_BREAKOUT_DURATION')
    

    def _calc_old_d(self, lookback_k=20, a_param=200.0):
        """
        计算老M值体系中的方向函数 D(t)。
        D(t) = tanh(a * h(t,K))
        h(t,K) 是过去K天不同周期线性回归斜率的均值。
        """
        from scipy.stats import linregress # 仅在此方法中需要
        close_prices = self.df['close']
        g_values_list = []
        
        # 为了向量化计算，我们创建一个包含所有需要回归的窗口的DataFrame
        # 对于每个交易日t，我们需要计算从t-k到t的回归，k从1到lookback_k
        for k in range(1, lookback_k + 1):
            # 截取 k+1 个数据点
            windows = close_prices.rolling(window=k + 1)
            
            # 使用apply函数对每个窗口进行线性回归
            # apply函数会比较慢，但对于这种复杂的窗口计算是必要的
            # 注意：linregress需要numpy数组
            slopes = windows.apply(lambda x: linregress(np.arange(len(x)), x).slope, raw=True)
            
            # 获取 t-k 日的收盘价
            close_t_minus_k = close_prices.shift(k)
            
            # 计算 g(t,k)
            g_tk = slopes / close_t_minus_k.replace(0, 1e-9)
            g_values_list.append(g_tk)
        # 将所有g(t,k)的值合并成一个DataFrame
        g_df = pd.concat(g_values_list, axis=1)
        
        # 计算 h(t,K)，即对每一行（每个交易日）的g值求均值
        h_t_k = g_df.mean(axis=1)
        
        # 计算 D(t)
        d_t = np.tanh(a_param * h_t_k)
        
        return d_t.rename('dynamic_Old_D')
    def _calc_old_i(self, adx_period=14, adx_threshold=20.0, b_param=0.075):
        """
        计算老M值体系中的强度函数 I(t)。
        I(t) = max(0, tanh(b * (ADX(t) - threshold)))
        """
        # pandas_ta库可以非常高效地计算ADX
        adx_df = self.df.ta.adx(length=adx_period, high=self.df['high'], low=self.df['low'], close=self.df['close'])
        adx_series = adx_df[f'ADX_{adx_period}']
        
        # 计算 I(t)
        raw_i = np.tanh(b_param * (adx_series - adx_threshold))
        i_t = raw_i.clip(lower=0) # 使用clip实现max(0, raw_i)
        
        return i_t.rename('dynamic_Old_I')
    def _calc_old_m(self):
        """
        计算老M值 OldM(t) = D(t) * I(t)。
        这个因子依赖于 _calc_old_d 和 _calc_old_i 的计算结果。
        为了效率，我们直接在这里调用它们，而不是重复计算。
        """
        # 为了避免重复计算，我们检查这些列是否已存在于一个临时的DataFrame中
        # 但在当前架构下，最简单的做法是重新计算一次，或者修改run方法
        # 这里我们选择直接计算，因为因子计算是独立的
        d_t = self._calc_old_d()
        i_t = self._calc_old_i()
        
        m_t = d_t * i_t
        
        return m_t.rename('dynamic_Old_M')




# ==============================================================================
#  主命令 (Main Command)
# ==============================================================================
class Command(BaseCommand):
    help = '[M-Value Refactor] 基于精选因子和连续夏普比率标签，为沪深300指数生成机器学习数据集。'

    # --- 路径和配置 ---
    MODELS_DIR = settings.BASE_DIR / 'selection_manager' / 'ml_models'
    DATASET_FILE = MODELS_DIR / 'm_value_dataset.pkl'
    MODEL_CONFIG_FILE = MODELS_DIR / 'm_value_model_config.json'

    # --- 新标签体系配置 ---
    LABEL_LOOKFORWARD = 3      # 向前看60个交易日计算夏普比率
    RISK_FREE_RATE_ANNUAL = 0.02 # 无风险年利率，设为4%
    TANH_SCALING_FACTOR = 1    # tanh的缩放因子a，使得夏普=1时接近饱和

    def _get_continuous_m_labels(self, df: pd.DataFrame) -> pd.Series:
        """
        根据未来60日年化夏普比率，计算连续的M值标签。
        标签公式: M = tanh(a * SharpeRatio)
        """
        self.stdout.write("步骤 2/4: 应用新的连续M值标签体系 (基于夏普比率)...")
        
        # 计算每日收益率
        returns = df['close'].pct_change()
        
        # 将年化无风险利率转换为日无风险利率
        # (1 + r_annual) = (1 + r_daily)^252  => r_daily = (1 + r_annual)^(1/252) - 1
        # 一年大约有252个交易日
        daily_risk_free_rate = (1 + self.RISK_FREE_RATE_ANNUAL)**(1/252) - 1
        
        # 计算超额收益率
        excess_returns = returns - daily_risk_free_rate
        
        # 使用高效的向量化方法计算未来60天的滚动指标
        # 为了计算未来60天，我们将数据向前移动60天，然后计算过去60天的滚动值
        # 这等价于在当前点计算未来60天的数据
        future_mean = excess_returns.shift(-self.LABEL_LOOKFORWARD).rolling(window=self.LABEL_LOOKFORWARD).mean()
        future_std = excess_returns.shift(-self.LABEL_LOOKFORWARD).rolling(window=self.LABEL_LOOKFORWARD).std()
        
        # 计算年化夏普比率
        # 年化因子 = sqrt(252)
        # 避免除以零
        annualized_sharpe_ratio = (future_mean / future_std.replace(0, np.nan)) * np.sqrt(252)
        
        # 应用tanh函数生成最终的M值标签
        m_labels = np.tanh(self.TANH_SCALING_FACTOR * annualized_sharpe_ratio)
        m_labels_raw = np.tanh(self.TANH_SCALING_FACTOR * annualized_sharpe_ratio)
        m_labels_smoothed = m_labels_raw.rolling(window=5, min_periods=1).mean()
        self.stdout.write(f"标签计算完成。缩放因子a={self.TANH_SCALING_FACTOR}, 无风险利率(年)={self.RISK_FREE_RATE_ANNUAL}")
        
        return m_labels_smoothed

    def handle(self, *args, **options):
        self.stdout.write(self.style.SUCCESS("===== [M-Value Refactor] 开始准备机器学习数据集 ====="))
        self.MODELS_DIR.mkdir(parents=True, exist_ok=True)

        # 1. 加载并准备数据
        self.stdout.write("步骤 1/4: 加载沪深300行情数据...")
        quotes_qs = IndexQuotesCsi300.objects.all().order_by('trade_date').values()
        df = pd.DataFrame.from_records(quotes_qs)
        df['trade_date'] = pd.to_datetime(df['trade_date'])
        df.set_index('trade_date', inplace=True)
        
        numeric_cols = ['open', 'high', 'low', 'close', 'volume', 'amount']
        for col in numeric_cols:
            df[col] = pd.to_numeric(df[col], errors='coerce')
        df.dropna(subset=numeric_cols, inplace=True)

        # 2. 生成标签 (已重构为连续M值)
        labels = self._get_continuous_m_labels(df)
        df['label'] = labels

        # 3. 计算特征
        self.stdout.write("步骤 3/4: 计算所有已启用的特征...")
        calculator = FactorCalculator(df)
        features_df, enabled_features = calculator.run(FEATURE_CONFIG)
        
        # 4. 对齐数据并保存
        self.stdout.write("步骤 4/4: 对齐特征和标签，并保存到文件...")
        
        # 合并特征和标签
        final_df = pd.concat([features_df, df['label']], axis=1)
        
        # 剔除所有包含NaN的行（通常是序列开头和结尾，以及标签计算的未来窗口）
        final_df.dropna(inplace=True)
        
        # 分离 X 和 y
        X = final_df[enabled_features]
        y = final_df['label'].astype(float) # 标签现在是浮点数
        
        self.stdout.write(f"数据集准备完成。总样本数: {len(X)}")
        self.stdout.write("标签（M值）统计信息:")
        self.stdout.write(str(y.describe()))
        
        # 保存数据集和配置
        dataset = {
            'X': X,
            'y': y,
            'index': X.index,
            'feature_names': enabled_features,
            # 'label_map' 不再需要，因为这是回归任务
        }
        with open(self.DATASET_FILE, 'wb') as f:
            pickle.dump(dataset, f)
        
        self.stdout.write(self.style.SUCCESS(f"数据集已成功保存至: {self.DATASET_FILE}"))
        
        # 保存模型配置，主要是特征列表，供预测时使用
        model_config = {'feature_names': enabled_features}
        with open(self.MODEL_CONFIG_FILE, 'w') as f:
            json.dump(model_config, f, indent=4)
        self.stdout.write(self.style.SUCCESS(f"模型配置文件已成功保存至: {self.MODEL_CONFIG_FILE}"))
        self.stdout.write(self.style.SUCCESS("===== [M-Value Refactor] 数据准备流程结束 ====="))

####文件结束####

####selection_manager\management\commands\prepare_stock_features.py####
# ==============================================================================
# 文件 1/4: selection_manager/management/commands/prepare_stock_features.py
# 描述: 为个股评分模型生成特征和标签数据集。(已改造为分批处理)
# ==============================================================================
import logging
import pickle
import json
import shutil # 导入shutil库用于删除目录
from pathlib import Path
from datetime import timedelta

import numpy as np
import pandas as pd
import pandas_ta as ta
from django.core.management.base import BaseCommand
from django.conf import settings
from tqdm import tqdm

from common.models import DailyQuotes, DailyFactorValues
from selection_manager.service.m_value_service import FactorCalculator # 复用M值服务中的因子计算器
from selection_manager.service.selection_service import MARKET_INDICATOR_CODE

logger = logging.getLogger(__name__)

# --- [配置区] ---
# 通过修改此处的配置，来控制数据集的生成方式
LABEL_CONFIG = {
    'mode': 'return',  # 'return' (未来收益率) 或 'sharpe' (未来夏普比率)
    'lookforward_days': 3, # 标签向前看的天数 (N)
    'risk_free_rate_annual': 0.02, # 年化无风险利率，仅在 'sharpe' 模式下使用
    'tanh_scaling_factor': 4.0, # tanh缩放因子，仅在 'sharpe' 模式下使用
}

# 因子计算所需的最大回溯期，应大于所有因子中最大的lookback period
# 例如，neg_dev(60), max_dd(60)等，给足100天buffer
FACTOR_LOOKBACK_BUFFER = 100

# --- [新增配置区] ---
# 分批处理的配置
BATCH_SIZE = 100 # 每次处理100只股票，以控制内存使用

class Command(BaseCommand):
    help = '为个股评分模型生成特征和标签数据集 (X, y)。采用分批处理以优化内存。'
    def add_arguments(self, parser):
        """添加命令行参数"""
        parser.add_argument(
            '--use-local-db',
            action='store_true',  # 这使它成为一个开关，存在即为True
            help='如果指定，则将数据源切换至 D:\\project\\mainDB.sqlite3 (需在settings.py中配置好local_sqlite)。'
        )
    # --- 路径配置 ---
    MODELS_DIR = settings.BASE_DIR / 'selection_manager' / 'ml_models'
    DATASET_FILE = MODELS_DIR / 'stock_features_dataset.pkl'
    MODEL_CONFIG_FILE = MODELS_DIR / 'stock_model_config.json' # 与个股模型共享配置
    
    # --- [新增] 临时文件存储路径 ---
    TEMP_DATA_DIR = MODELS_DIR / 'temp_feature_batches'


    def handle(self, *args, **options):
        """
        主处理函数，协调整个数据集的生成流程。
        改造后的流程：
        1. 全局准备：获取所有股票代码、M值、因子名等一次性数据。
        2. 分批处理：将股票代码分批，对每一批次执行“加载-计算-合并”并存为临时文件。
        3. 最终合并：将所有临时文件合并为最终数据集。
        4. 清理：删除临时文件。
        """

        use_local_db = options['use_local_db']
        self.db_alias = 'local_sqlite' if use_local_db else 'default'
        
        db_source_message = f"D:\\project\\mainDB.sqlite3 (别名: {self.db_alias})" if use_local_db else f"默认数据库 (别名: {self.db_alias})"
        self.stdout.write(self.style.SUCCESS(f"当前使用的数据源: {db_source_message}"))

        self.stdout.write(self.style.SUCCESS("===== 开始为个股评分模型准备机器学习数据集 (分批处理模式) ====="))
        
        # --- [改造] 步骤 0: 准备工作，创建临时目录 ---
        # 如果临时目录存在，先删除，确保一个干净的开始
        if self.TEMP_DATA_DIR.exists():
            shutil.rmtree(self.TEMP_DATA_DIR)
        self.TEMP_DATA_DIR.mkdir(parents=True, exist_ok=True)
        self.stdout.write(f"创建临时目录: {self.TEMP_DATA_DIR}")

        try:
            # --- [改造] 步骤 1: 一次性加载全局/轻量级数据 ---
            self.stdout.write("步骤 1/5: 加载全局数据 (股票列表, M值)...")
            all_stock_codes, m_values_series, start_date = self._load_global_data()
            if not all_stock_codes:
                self.stdout.write(self.style.ERROR("错误: 数据库中没有可用的股票代码。"))
                return
            
            # 从M值模型配置中获取所有需要计算的因子名称
            feature_names = self._get_feature_names()

            # --- [改造] 步骤 2: 分批生成特征和标签，并保存为临时文件 ---
            self.stdout.write(f"步骤 2/5: 开始分批处理 {len(all_stock_codes)} 只股票，每批 {BATCH_SIZE} 只...")
            
            # 将所有股票代码分批
            stock_batches = [all_stock_codes[i:i + BATCH_SIZE] for i in range(0, len(all_stock_codes), BATCH_SIZE)]
            
            # 使用tqdm显示批次处理进度
            batch_iterator = tqdm(enumerate(stock_batches), total=len(stock_batches), desc="处理批次")
            
            intermediate_files = [] # 用于存储生成的中间文件名

            for i, batch_codes in batch_iterator:
                batch_iterator.set_description(f"处理批次 {i+1}/{len(stock_batches)}")
                self.stdout.write(f"\n  - [批次 {i+1}] 开始加载 {len(batch_codes)} 只股票的行情数据...")
                # 2.1 加载当前批次的行情数据
                quotes_df = self._load_batch_quotes(batch_codes, start_date)
                if quotes_df.empty:
                    self.stdout.write(self.style.WARNING(f"警告: 批次 {i+1} 未能加载到任何数据，已跳过。"))
                    continue
                self.stdout.write(f"  - [批次 {i+1}] 行情数据加载完成，共 {len(quotes_df)} 条记录。开始生成标签...")
                # 2.2 为当前批次生成标签
                labels_df = self._generate_labels(quotes_df)
                self.stdout.write(f"  - [批次 {i+1}] 标签生成完成。开始计算特征...")
                # 2.3 为当前批次计算因子特征
                features_df = self._calculate_batch_features(quotes_df, feature_names)
                self.stdout.write(f"  - [批次 {i+1}] 标签生成完成。开始计算特征...")
                # 2.4 合并批次内的特征、M值和标签
                # 将M值作为一个特征加入
                features_df['market_m_value'] = features_df.index.get_level_values('trade_date').map(m_values_series)
                
                # 合并批次数据
                batch_final_df = features_df.join(labels_df, how='inner')
                batch_final_df.dropna(inplace=True)

                if batch_final_df.empty:
                    continue

                # 2.5 将处理好的批次数据保存到临时文件
                temp_file_path = self.TEMP_DATA_DIR / f'batch_{i}.pkl'
                with open(temp_file_path, 'wb') as f:
                    pickle.dump(batch_final_df, f)
                intermediate_files.append(temp_file_path)

            if not intermediate_files:
                self.stdout.write(self.style.ERROR("错误: 所有批次处理后未生成任何有效数据。请检查数据范围或因子计算。"))
                return

            # --- [改造] 步骤 3 & 4: 合并所有临时文件 ---
            self.stdout.write(f"\n步骤 3/5 & 4/5: 合并 {len(intermediate_files)} 个中间文件...")
            all_dfs = []
            for file_path in tqdm(intermediate_files, desc="合并文件"):
                with open(file_path, 'rb') as f:
                    batch_df = pickle.load(f)
                    all_dfs.append(batch_df)
            
            final_df = pd.concat(all_dfs, ignore_index=False) # ignore_index=False保留(date, code)多级索引

            # --- [无改动] 步骤 5: 保存最终数据集和配置 ---
            self.stdout.write("步骤 5/5: 保存最终数据集和模型配置文件...")
            # 在最终合并后的DataFrame中加入market_m_value特征名
            if 'market_m_value' not in feature_names:
                feature_names.append('market_m_value')

            X = final_df[feature_names]
            y = final_df['label']

            self.stdout.write(f"数据集准备完成。总样本数: {len(X)}")
            self.stdout.write("标签 (label) 统计信息:")
            self.stdout.write(str(y.describe()))

            dataset = {'X': X, 'y': y, 'index': X.index, 'feature_names': feature_names}
            with open(self.DATASET_FILE, 'wb') as f:
                pickle.dump(dataset, f)
            self.stdout.write(self.style.SUCCESS(f"数据集已成功保存至: {self.DATASET_FILE}"))

            model_config = {'feature_names': feature_names}
            with open(self.MODEL_CONFIG_FILE, 'w') as f:
                json.dump(model_config, f, indent=4)
            self.stdout.write(self.style.SUCCESS(f"模型配置文件已成功保存至: {self.MODEL_CONFIG_FILE}"))
            
        finally:
            # --- [新增] 清理步骤 ---
            # 无论成功与否，都尝试删除临时目录
            if self.TEMP_DATA_DIR.exists():
                shutil.rmtree(self.TEMP_DATA_DIR)
                self.stdout.write(self.style.SUCCESS(f"临时目录已清理: {self.TEMP_DATA_DIR}"))
        
        self.stdout.write(self.style.SUCCESS("===== 数据准备流程结束 ====="))

    def _load_global_data(self):
        """
        [新增] 一次性从数据库加载全局共享且数据量较小的数据。
        - 所有唯一的股票代码列表。
        - 市场M值时间序列。
        - 计算并返回全局的数据起始日期。
        """
        # 确定数据加载的起始日期
        first_quote = DailyQuotes.objects.order_by('trade_date').first()
        if not first_quote:
            return [], pd.Series(), None
        
        start_date = first_quote.trade_date + timedelta(days=FACTOR_LOOKBACK_BUFFER)
        self.stdout.write(f"全局数据加载起始日期 (已考虑因子计算缓冲): {start_date}")

        # 加载所有唯一的股票代码
        all_stock_codes = list(DailyQuotes.objects.using(self.db_alias).values_list('stock_code_id', flat=True).distinct())
        
        # 加载M值
        m_values_qs = DailyFactorValues.objects.filter(
            stock_code_id=MARKET_INDICATOR_CODE,
            factor_code_id='dynamic_M_VALUE',
            trade_date__gte=start_date
        ).values('trade_date', 'raw_value')
        m_values_df = pd.DataFrame.from_records(m_values_qs)
        m_values_series = pd.Series()
        if not m_values_df.empty:
            m_values_series = m_values_df.set_index('trade_date')['raw_value'].astype(float)
        
        return all_stock_codes, m_values_series, start_date
    
    def _load_batch_quotes(self, batch_codes: list, start_date):
        """
        [新增] 从数据库加载一个批次股票的日线行情数据。
        """
        # 加载指定股票批次的日线行情
        quotes_qs = DailyQuotes.objects.using(self.db_alias).filter(
            trade_date__gte=start_date,
            stock_code_id__in=batch_codes # 核心改动：只查询当前批次的股票
        ).values(
            'trade_date', 'stock_code_id', 'open', 'high', 'low', 'close', 'volume', 'turnover', 'hfq_close'
        )
        if not quotes_qs.exists():
            return pd.DataFrame()

        quotes_df = pd.DataFrame.from_records(quotes_qs)
        numeric_cols = ['open', 'high', 'low', 'close', 'volume', 'turnover', 'hfq_close']
        for col in numeric_cols:
            quotes_df[col] = pd.to_numeric(quotes_df[col], errors='coerce')
        
        quotes_df['adj_factor'] = quotes_df['hfq_close'] / (quotes_df['close'] + 1e-9)
        
        # 3. 计算后复权的 open, high, low
        quotes_df['hfq_open'] = quotes_df['open'] * quotes_df['adj_factor']
        quotes_df['hfq_high'] = quotes_df['high'] * quotes_df['adj_factor']
        quotes_df['hfq_low'] = quotes_df['low'] * quotes_df['adj_factor']
        
        # 4. 为了后续计算器接口统一，重命名列
        #    现在 'open', 'high', 'low', 'close' 都代表后复权价格
        final_df = pd.DataFrame({
            'trade_date': quotes_df['trade_date'],
            'stock_code_id': quotes_df['stock_code_id'],
            'open': quotes_df['hfq_open'],
            'high': quotes_df['hfq_high'],
            'low': quotes_df['hfq_low'],
            'close': quotes_df['hfq_close'], # 直接使用hfq_close作为复权收盘价
            'volume': quotes_df['volume'],
            'amount': quotes_df['turnover'] # 同时在这里完成turnover到amount的重命名
        })
        
        return final_df


    def _generate_labels(self, quotes_df: pd.DataFrame) -> pd.DataFrame:
        """
        [无改动] 根据配置为给定的DataFrame生成标签。
        此函数逻辑不变，现在作用于小批量的DataFrame，因此内存友好。
        """
        df = quotes_df.set_index(['trade_date', 'stock_code_id'])['close'].unstack()
        df.replace(0, np.nan, inplace=True)
        if LABEL_CONFIG['mode'] == 'return':
            # 计算未来N日收益率
            future_price = df.shift(-LABEL_CONFIG['lookforward_days'])
            labels = (future_price / df) - 1
            labels=np.tanh(LABEL_CONFIG['tanh_scaling_factor'] * labels)
        elif LABEL_CONFIG['mode'] == 'sharpe':
            # 计算未来N日夏普比率
            returns = df.pct_change(fill_method=None)
            daily_rf = (1 + LABEL_CONFIG['risk_free_rate_annual'])**(1/252) - 1
            excess_returns = returns - daily_rf
            
            future_mean = excess_returns.shift(-LABEL_CONFIG['lookforward_days']).rolling(window=LABEL_CONFIG['lookforward_days']).mean()
            future_std = excess_returns.shift(-LABEL_CONFIG['lookforward_days']).rolling(window=LABEL_CONFIG['lookforward_days']).std()
            
            annualized_sharpe = (future_mean / future_std.replace(0, np.nan)) * np.sqrt(252)
            labels = np.tanh(LABEL_CONFIG['tanh_scaling_factor'] * annualized_sharpe)
        else:
            raise ValueError(f"未知的标签模式: {LABEL_CONFIG['mode']}")

        return labels.stack().rename('label').to_frame()

    def _get_feature_names(self):
        """
        [新增] 封装了获取因子名称列表的逻辑，只执行一次。
        """
        try:
            with open(settings.BASE_DIR / 'selection_manager' / 'ml_models' / 'm_value_model_config.json', 'r') as f:
                m_value_config = json.load(f)
            feature_names = m_value_config['feature_names']
            self.stdout.write("成功从'm_value_model_config.json'加载因子列表。")
        except FileNotFoundError:
            self.stdout.write(self.style.ERROR("错误: M值模型配置文件 'm_value_model_config.json' 不存在。"))
            # 如果M值模型不存在，则使用一个预定义的因子列表
            feature_names = [
                'dynamic_ADX_CONFIRM', 'dynamic_v2_MA_SLOPE', 'dynamic_v2_MA_SCORE',
                'dynamic_v2_CPC_Factor', 'dynamic_v2_VPCF', 'dynamic_BREAKOUT_PWR',
                'dynamic_VOLUME_SURGE', 'dynamic_MOM_ACCEL', 'dynamic_RSI_OS',
                'dynamic_NEG_DEV', 'dynamic_BOLL_LB', 'dynamic_LOW_VOL',
                'dynamic_MAX_DD', 'dynamic_DOWNSIDE_RISK', 'dynamic_Old_D',
                'dynamic_Old_I', 'dynamic_Old_M'
            ]
            self.stdout.write(self.style.WARNING(f"将使用默认的因子列表: {feature_names}"))
        return feature_names

    def _calculate_batch_features(self, quotes_df: pd.DataFrame, feature_names: list):
        """
        [名称和签名有改动] 对一个批次的股票计算所有因子特征。
        原_calculate_all_features，逻辑不变，但现在处理的是小批量的DataFrame。
        """
        all_features_list = []
        stock_groups = quotes_df.groupby('stock_code_id')
        
        # 这里的tqdm现在显示单批次内的股票计算进度，可以禁用以减少日志输出
        for stock_code, group_df in stock_groups: # tqdm(stock_groups, desc="计算批次内因子", leave=False)
            #group_df = group_df.rename(columns={'turnover': 'amount'})
            group_df = group_df.set_index('trade_date').sort_index()
            
            # 确保数据连续，填充缺失的交易日
            min_date, max_date = group_df.index.min(), group_df.index.max()
            if pd.isna(min_date) or pd.isna(max_date):
                continue
            full_date_range = pd.date_range(start=min_date, end=max_date, freq='B')
            group_df = group_df.reindex(full_date_range).ffill()
            
            if len(group_df) < FACTOR_LOOKBACK_BUFFER:
                continue

            # 使用复用的因子计算器
            calculator = FactorCalculator(group_df)
            stock_features_df = calculator.run(feature_names)
            stock_features_df['stock_code_id'] = stock_code
            all_features_list.append(stock_features_df)

        if not all_features_list:
            return pd.DataFrame()
            
        # 合并批次中所有股票的特征
        final_features_df = pd.concat(all_features_list)
        final_features_df = final_features_df.reset_index().rename(columns={'index': 'trade_date'})
        final_features_df = final_features_df.set_index(['trade_date', 'stock_code_id'])
        
        return final_features_df


####文件结束####

####selection_manager\management\commands\train_csi300_model_test.py####
# selection_manager/management/commands/train_csi300_model_test.py

import logging
import pickle
import json

import numpy as np
import pandas as pd
import lightgbm as lgb
from django.core.management.base import BaseCommand
from django.conf import settings
from sklearn.model_selection import TimeSeriesSplit
from sklearn.metrics import mean_squared_error, r2_score
# 移除分类相关的导入
# from sklearn.utils.class_weight import compute_sample_weight
import joblib
import optuna

logger = logging.getLogger(__name__)

class Command(BaseCommand):
    help = '[M-Value Refactor] 训练LightGBM回归模型以直接预测M值。'

    # --- 路径配置 ---
    MODELS_DIR = settings.BASE_DIR / 'selection_manager' / 'ml_models'
    DATASET_FILE = MODELS_DIR / 'm_value_dataset.pkl'
    MODEL_FILE = MODELS_DIR / 'm_value_lgbm_model.joblib'
    MODEL_CONFIG_FILE = MODELS_DIR / 'm_value_model_config.json'

    def handle(self, *args, **options):
        self.stdout.write(self.style.SUCCESS("===== [M-Value Refactor] 开始训练LightGBM回归模型 ====="))

        # 1. 加载数据集
        self.stdout.write(f"步骤 1/4: 从 {self.DATASET_FILE} 加载数据集...")
        try:
            with open(self.DATASET_FILE, 'rb') as f:
                dataset = pickle.load(f)
            X, y, feature_names = dataset['X'], dataset['y'], dataset['feature_names']
            # label_map 不再存在
        except FileNotFoundError:
            self.stdout.write(self.style.ERROR(f"错误: 数据集文件 {self.DATASET_FILE} 不存在。请先运行 'prepare_csi300_features' 命令。"))
            return

        # 2. 定义模型和交叉验证
        self.stdout.write("步骤 2/4: 设置回归模型参数和时间序列交叉验证...")
        
        # LightGBM 回归模型参数
        lgbm_params = {
            # --- 核心参数 (定义模型的基本任务和类型) ---
            'objective': 'regression',      # 目标函数: 'regression' (或 'regression_l1', 'regression_l2') 表示这是一个回归问题。模型的目标是最小化均方误差(L2损失)。
            # 'num_class' 参数在回归任务中不需要
            'boosting_type': 'gbdt',        # 提升类型: 'gbdt' (Gradient Boosting Decision Tree) 是最经典、最常用的算法。
            'metric': 'rmse',               # 评估指标: 'rmse' (Root Mean Squared Error, 均方根误差) 是回归问题中最常用的评估指标，用于监控验证集性能和早停。
            
            # --- 性能与速度 (影响训练效率和模型学习能力) ---
            'n_estimators': 5000,           # 迭代次数 (树的数量): 模型要构建的树的总数。
                                            # 改大: 允许模型进行更多轮的学习，可能捕捉更复杂的模式，但增加训练时间。
                                            # 改小: 训练速度更快，但可能导致欠拟合。
                                            # 后果: 通常设置一个较大的值（如1000-10000），并配合早停使用，让模型在验证集性能不再提升时自动停止，从而找到最佳迭代次数。
            'learning_rate': 0.01,          # 学习率: 控制每次迭代（每棵树）对最终结果的贡献程度。
                                            # 改小 (如0.005): 模型学习得更慢、更精细，需要更多的 'n_estimators' 才能达到好的效果，但通常能找到泛化能力更好的模型。
                                            # 改大 (如0.1): 模型学习得更快，但容易跳过最优解，导致模型性能下降。
                                            # 后果: 'learning_rate' 和 'n_estimators' 强相关。推荐策略是：低 'learning_rate' (如 0.01-0.05) + 高 'n_estimators' + 早停。
            'n_jobs': -1,                   # 并行线程数: '-1' 表示使用所有可用的CPU核心，以最大化训练速度。
            'seed': 42,                     # 随机种子: 用于确保每次训练的结果可复现。只要种子不变，数据划分、特征选择等随机过程的结果就会固定。
            'verbose': -1,                  # 日志详细程度: '-1' 表示不输出训练过程中的详细日志，保持控制台输出干净。
            
            # --- 控制过拟合 (关键调优区，防止模型在新数据上表现差) ---
            'num_leaves': 31,               # 每棵树的最大叶子节点数: 控制模型复杂度的核心参数。
                                            # 改大: 允许树模型学习到更复杂的规则，可能提升训练集表现，但极易导致过拟合。
                                            # 改小: 限制树的复杂度，防止过拟合，但过小会使模型过于简单，导致欠拟合。
                                            # 后果: 它的值应小于 2^max_depth。'31' 是一个常用的、稳健的默认值。
            'max_depth': -1,                # 树的最大深度: 限制树可以生长的最大层数。在LightGBM中，通常优先用 'num_leaves' 控制复杂度，'max_depth'设为-1（不限制）。
            'subsample': 0.8,               # 样本采样比例 (行采样): 每次迭代时，从总训练数据中随机采样的比例。
                                            # 改小 (如0.7): 每次只用一部分数据训练，增加了模型的随机性，有助于防止过拟合，提高泛化能力。值必须在 (0, 1.0] 之间。
            'colsample_bytree': 0.8,        # 特征采样比例 (列采样): 每次迭代时，从总特征中随机选择的比例。
                                            # 改小 (如0.7): 每次只用一部分特征来建树，有助于防止模型过度依赖少数几个强特征，从而防止过拟合。
            'reg_alpha': 0.1,               # L1 正则化项: 对模型权重施加L1惩罚。
            'reg_lambda': 0.1,              # L2 正则化项: 对模型权重施加L2惩罚。
        }

        # 步骤 3/4: 使用 Optuna 进行超参数优化和验证
        self.stdout.write("步骤 3/4: 使用 Optuna 进行超参数优化...")
        # 将数据的后20%作为验证集，前80%作为训练集
        split_point = int(len(X) * 0.8)
        X_train, X_val = X.iloc[:split_point], X.iloc[split_point:]
        y_train, y_val = y.iloc[:split_point], y.iloc[split_point:]
        self.stdout.write(f"训练集大小: {len(X_train)}, 验证集大小: {len(X_val)}")
        
        # 回归任务不需要计算样本权重
        # sample_weights = compute_sample_weight(...)

        # 定义 Optuna 的目标函数 (objective function)
        def objective(trial):
            # --- 定义要搜索的参数空间 ---
            params_to_tune = {
                'num_leaves': trial.suggest_int('num_leaves', 10, 100),
                'max_depth': trial.suggest_int('max_depth', 3, 100),
                'learning_rate': trial.suggest_float('learning_rate', 0.001, 0.05, log=True),
                'subsample': trial.suggest_float('subsample', 0.6, 1.0),
                'colsample_bytree': trial.suggest_float('colsample_bytree', 0.6, 1.0),
                'reg_alpha': trial.suggest_float('reg_alpha', 1e-3, 1.0, log=True),
                'reg_lambda': trial.suggest_float('reg_lambda', 1e-3, 1.0, log=True),
            }
            
            # 合并基础参数和当前尝试的参数
            current_params = lgbm_params.copy()
            current_params.update(params_to_tune)
            
            # --- 使用时序交叉验证进行评估 ---
            tscv = TimeSeriesSplit(n_splits=5) 
            rmses = []
            for train_index, val_index in tscv.split(X):
                X_train_fold, X_val_fold = X.iloc[train_index], X.iloc[val_index]
                y_train_fold, y_val_fold = y.iloc[train_index], y.iloc[val_index]
                
                model = lgb.LGBMRegressor(**current_params)
                
                # 训练模型
                model.fit(X_train_fold, y_train_fold)
                
                # 在验证集上进行预测
                val_preds = model.predict(X_val_fold)
                
                # 计算均方根误差
                rmse = np.sqrt(mean_squared_error(y_val_fold, val_preds))
                rmses.append(rmse)
                
            # 返回所有折叠分数的平均值，Optuna将最小化这个平均值
            return np.mean(rmses)

        # --- 运行 Optuna 优化 ---
        self.stdout.write("开始参数搜索 (n_trials=50)...")
        study = optuna.create_study(direction='minimize') # 目标是最小化 RMSE
        study.optimize(objective, n_trials=5) # 尝试 50 组参数组合
        
        # --- 获取并报告最佳参数 ---
        best_params = lgbm_params.copy()
        best_params.update(study.best_params)
        self.stdout.write(self.style.SUCCESS(f"\n搜索完成！最佳验证集 RMSE: {study.best_value:.4f}"))
        self.stdout.write(self.style.SUCCESS(f"找到的最佳参数: {study.best_params}"))
        
        # --- 使用最佳参数在验证集上进行最终评估 ---
        self.stdout.write(self.style.SUCCESS("\n--- 使用最佳参数在验证集上进行评估 ---"))
        best_model = lgb.LGBMRegressor(**best_params)
        best_model.fit(X_train, y_train,
                       eval_set=[(X_val, y_val)],
                       eval_metric='rmse',
                       callbacks=[lgb.early_stopping(100, verbose=False)])
        
        val_preds = best_model.predict(X_val)
        val_rmse = np.sqrt(mean_squared_error(y_val, val_preds))
        val_r2 = r2_score(y_val, val_preds)
        self.stdout.write(f"最终验证集 RMSE: {val_rmse:.4f}")
        self.stdout.write(f"最终验证集 R^2 Score: {val_r2:.4f}")

        # 步骤 4/4: 使用最佳参数训练最终模型并保存
        self.stdout.write("\n步骤 4/4: 使用最佳参数训练最终模型并保存...")
        self.stdout.write("\n--- 训练最终模型 (使用全部数据和最佳参数) ---")
        final_model = lgb.LGBMRegressor(**best_params)
        
        # 回归任务不需要样本权重
        final_model.fit(X, y)
        
        # 保存模型
        joblib.dump(final_model, self.MODEL_FILE)
        self.stdout.write(self.style.SUCCESS(f"最终模型已保存至: {self.MODEL_FILE}"))
        
        # 显示并保存特征重要性
        feature_importance_df = pd.DataFrame({
            'feature': feature_names,
            'importance': final_model.feature_importances_
        }).sort_values('importance', ascending=False)
        self.stdout.write("\n--- 特征重要性 ---")
        self.stdout.write(str(feature_importance_df.head(20)))
        
        # 更新模型配置文件，加入特征重要性
        try:
            with open(self.MODEL_CONFIG_FILE, 'r') as f:
                model_config = json.load(f)
            
            model_config['feature_importance'] = feature_importance_df.to_dict('records')
            model_config['best_params'] = {k: (v.isoformat() if isinstance(v, pd.Timestamp) else v) for k, v in study.best_params.items()}
            
            with open(self.MODEL_CONFIG_FILE, 'w') as f:
                json.dump(model_config, f, indent=4)
            self.stdout.write(self.style.SUCCESS(f"特征重要性和最佳参数已更新至: {self.MODEL_CONFIG_FILE}"))
        except Exception as e:
            self.stdout.write(self.style.ERROR(f"更新模型配置文件时出错: {e}"))
            
        self.stdout.write(self.style.SUCCESS("===== [M-Value Refactor] 模型训练流程结束！ ====="))

####文件结束####

####selection_manager\management\commands\train_stock_model.py####
# ==============================================================================
# 文件 2/4: selection_manager/management/commands/train_stock_model.py
# 描述: 训练个股评分的LightGBM回归模型。
# ==============================================================================
import logging
import pickle
import json

import numpy as np
import pandas as pd
import lightgbm as lgb
from django.core.management.base import BaseCommand
from django.conf import settings
from sklearn.model_selection import TimeSeriesSplit
from sklearn.metrics import mean_squared_error, r2_score
import joblib
import optuna

logger = logging.getLogger(__name__)

class Command(BaseCommand):
    help = '训练个股评分的LightGBM回归模型。'

    # --- 路径配置 ---
    MODELS_DIR = settings.BASE_DIR / 'selection_manager' / 'ml_models'
    DATASET_FILE = MODELS_DIR / 'stock_features_dataset.pkl'
    MODEL_FILE = MODELS_DIR / 'stock_lgbm_model.joblib'
    MODEL_CONFIG_FILE = MODELS_DIR / 'stock_model_config.json'

    def handle(self, *args, **options):
        self.stdout.write(self.style.SUCCESS("===== 开始训练个股评分模型 (LightGBM Regressor) ====="))

        # 1. 加载数据集
        self.stdout.write(f"步骤 1/4: 从 {self.DATASET_FILE} 加载数据集...")
        try:
            with open(self.DATASET_FILE, 'rb') as f:
                dataset = pickle.load(f)
            X, y, feature_names = dataset['X'], dataset['y'], dataset['feature_names']
        except FileNotFoundError:
            self.stdout.write(self.style.ERROR(f"错误: 数据集文件 {self.DATASET_FILE} 不存在。请先运行 'prepare_stock_features' 命令。"))
            return

        # 2. 定义模型和交叉验证
        self.stdout.write("步骤 2/4: 设置回归模型参数和时间序列交叉验证...")
        
        # LightGBM 回归模型参数 (与M值模型风格一致)
        lgbm_params = {
            'objective': 'regression_l1', # 使用L1损失 (MAE)，对异常值更鲁棒
            'boosting_type': 'gbdt',
            'metric': 'rmse',
            'n_estimators': 2000, # 减少迭代次数，因为数据集更大
            'learning_rate': 0.001,
            'n_jobs': -1,
            'seed': 42,
            'verbose': -1,
            'num_leaves': 63, # 允许更复杂的树
            'max_depth': -1,
            'subsample': 0.8,
            'colsample_bytree': 0.7,
            'reg_alpha': 0.2,
            'reg_lambda': 0.2,
        }

        # 3. 使用 Optuna 进行超参数优化和验证
        self.stdout.write("步骤 3/4: 使用 Optuna 进行超参数优化...")
        
        # 由于数据集可能非常大，我们只取最后一部分数据进行快速的超参数搜索
        # 例如，只用最后20%的数据进行调优
        sample_frac_for_tuning = 0.2
        tuning_data_size = int(len(X) * sample_frac_for_tuning)
        X_tuning = X.iloc[-tuning_data_size:]
        y_tuning = y.iloc[-tuning_data_size:]
        self.stdout.write(f"为加速调优，仅使用后 {tuning_data_size} 条数据进行参数搜索。")

        def objective(trial):
            params_to_tune = {
                'num_leaves': trial.suggest_int('num_leaves', 20, 150),
                'learning_rate': trial.suggest_float('learning_rate', 0.01, 0.1, log=True),
                'subsample': trial.suggest_float('subsample', 0.6, 1.0),
                'colsample_bytree': trial.suggest_float('colsample_bytree', 0.6, 1.0),
                'reg_alpha': trial.suggest_float('reg_alpha', 1e-2, 10.0, log=True),
                'reg_lambda': trial.suggest_float('reg_lambda', 1e-2, 10.0, log=True),
            }
            current_params = lgbm_params.copy()
            current_params.update(params_to_tune)
            
            tscv = TimeSeriesSplit(n_splits=5)
            rmses = []
            for train_index, val_index in tscv.split(X_tuning):
                X_train_fold, X_val_fold = X_tuning.iloc[train_index], X_tuning.iloc[val_index]
                y_train_fold, y_val_fold = y_tuning.iloc[train_index], y_tuning.iloc[val_index]
                
                model = lgb.LGBMRegressor(**current_params)
                model.fit(X_train_fold, y_train_fold,
                          eval_set=[(X_val_fold, y_val_fold)],
                          callbacks=[lgb.early_stopping(50, verbose=False)])
                
                val_preds = model.predict(X_val_fold)
                rmse = np.sqrt(mean_squared_error(y_val_fold, val_preds))
                rmses.append(rmse)
            return np.mean(rmses)

        self.stdout.write("开始参数搜索 (n_trials=30)...")
        study = optuna.create_study(direction='minimize')
        study.optimize(objective, n_trials=30) # 减少尝试次数以适应大数据集
        
        best_params = lgbm_params.copy()
        best_params.update(study.best_params)
        self.stdout.write(self.style.SUCCESS(f"\n搜索完成！最佳验证集 RMSE: {study.best_value:.4f}"))
        self.stdout.write(self.style.SUCCESS(f"找到的最佳参数: {study.best_params}"))

        # 步骤 4/4: 使用最佳参数在全部数据上训练最终模型并保存
        self.stdout.write("\n步骤 4/4: 使用最佳参数在全部数据上训练最终模型并保存...")
        
        # 使用时间序列划分法，将最后20%作为验证集来展示最终性能
        split_point = int(len(X) * 0.8)
        X_train, X_val = X.iloc[:split_point], X.iloc[split_point:]
        y_train, y_val = y.iloc[:split_point], y.iloc[split_point:]

        final_model = lgb.LGBMRegressor(**best_params)
        final_model.fit(X_train, y_train,
                        eval_set=[(X_val, y_val)],
                        eval_metric='rmse',
                        callbacks=[lgb.early_stopping(100, verbose=True)])
        
        # 在验证集上评估最终模型
        val_preds = final_model.predict(X_val)
        val_rmse = np.sqrt(mean_squared_error(y_val, val_preds))
        val_r2 = r2_score(y_val, val_preds)
        self.stdout.write(self.style.SUCCESS(f"\n--- 最终模型在验证集上的性能 ---"))
        self.stdout.write(f"RMSE: {val_rmse:.4f}")
        self.stdout.write(f"R^2 Score: {val_r2:.4f}")

        # 保存模型
        joblib.dump(final_model, self.MODEL_FILE)
        self.stdout.write(self.style.SUCCESS(f"最终模型已保存至: {self.MODEL_FILE}"))
        
        # 显示并保存特征重要性
        feature_importance_df = pd.DataFrame({
            'feature': feature_names,
            'importance': final_model.feature_importances_
        }).sort_values('importance', ascending=False)
        self.stdout.write("\n--- 特征重要性 ---")
        self.stdout.write(str(feature_importance_df.head(20)))
        
        # 更新模型配置文件
        try:
            with open(self.MODEL_CONFIG_FILE, 'r') as f:
                model_config = json.load(f)
            
            model_config['feature_importance'] = feature_importance_df.to_dict('records')
            model_config['best_params'] = {k: v for k, v in study.best_params.items()}
            
            with open(self.MODEL_CONFIG_FILE, 'w') as f:
                json.dump(model_config, f, indent=4)
            self.stdout.write(self.style.SUCCESS(f"特征重要性和最佳参数已更新至: {self.MODEL_CONFIG_FILE}"))
        except Exception as e:
            self.stdout.write(self.style.ERROR(f"更新模型配置文件时出错: {e}"))
            
        self.stdout.write(self.style.SUCCESS("===== 个股评分模型训练流程结束！ ====="))

####文件结束####

####trade_manager\__init__.py####

####文件结束####

####trade_manager\admin.py####
from django.contrib import admin

# Register your models here.

####文件结束####

####trade_manager\apps.py####
# trade_manager/apps.py

import os
import sys
from django.apps import AppConfig
import logging

logger = logging.getLogger(__name__)

class TradeManagerConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'trade_manager'

    def ready(self):
        # # 关键修正：通过检查环境变量 RUN_MAIN 来防止调度器在重载主进程中启动两次
        # # 这个环境变量是 Django 的 autoreloader 在启动子进程时设置的。
        # # 我们只想在运行实际应用的子进程中启动调度器。
        # if os.environ.get('RUN_MAIN'):
        #     logger.info("检测到 Django 应用工作进程，准备初始化调度器...")
        #     from .service import scheduler_service
        #     # 确保调度器只启动一次
        #     if not scheduler_service.scheduler.running:
        #          scheduler_service.start()
        #     else:
        #          logger.warning("调度器已在运行，跳过重复启动。")
        # else:
        #     logger.info("检测到 Django 管理或重载主进程，跳过调度器初始化。")
        return


####文件结束####

####trade_manager\models.py####
from django.db import models

# Create your models here.

####文件结束####

####trade_manager\tests.py####
from django.test import TestCase

# Create your tests here.

####文件结束####

####trade_manager\urls.py####
"""
URL configuration for autoTrade project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path,include
from . import views
urlpatterns = [
    path('beforeFixRun', views.before_fix_run),
    path('initParam',views.initialize_strategy_parameters),
    path('simulateTrade', views.simulate_trade)
]

####文件结束####

####trade_manager\views.py####
from datetime import date,datetime
from django.shortcuts import render
from django.http.response import JsonResponse
from trade_manager.service.before_fix_service import BeforeFixService
from trade_manager.service.decision_order_service import DecisionOrderService
from trade_manager.service.simulate_trade import SimulateTradeService
import json
from django.views.decorators.http import require_http_methods
# Create your views here.
@require_http_methods(["POST"])
def before_fix_run(request):
    if request.method=='POST':
        body= json.loads(request.body)
        selection_date=datetime.strptime(body['date'], "%Y-%m-%d").date()
        service=BeforeFixService(selection_date)
        service.run()
        return JsonResponse({
            'result':'成功'
        })
@require_http_methods(["GET"])
def initialize_strategy_parameters(request):
    if request.method=='GET':
        DecisionOrderService.initialize_strategy_parameters()
        return JsonResponse({
            'result':'成功'
        })

@require_http_methods(["POST"])
def simulate_trade(request):
    if request.method=='POST':
        body= json.loads(request.body)
        start_date=body['startDate']
        end_date=body['endDate']
        service=SimulateTradeService()
        result=service.run_backtest(start_date=start_date,end_date=end_date)
        return JsonResponse(result)
####文件结束####

####trade_manager\management\commands\run_backtest.py####
# ==============================================================================
# 文件 2/5: trade_manager/management/commands/run_backtest.py (新增)
# 描述: 用于从命令行启动回测的 Command 文件。
# ==============================================================================
from django.core.management.base import BaseCommand, CommandParser
from trade_manager.service.simulate_trade import SimulateTradeService
from decimal import Decimal

class Command(BaseCommand):
    help = '运行一个完整的交易策略回测'

    def add_arguments(self, parser: CommandParser):
        parser.add_argument(
            '--start',
            type=str,
            required=True,
            help='回测起始日期 (格式: YYYY-MM-DD)'
        )
        parser.add_argument(
            '--end',
            type=str,
            required=True,
            help='回测结束日期 (格式: YYYY-MM-DD)'
        )
        parser.add_argument(
            '--capital',
            type=Decimal,
            required=True,
            help='初始资金'
        )

    def handle(self, *args, **options):
        start_date = options['start']
        end_date = options['end']
        initial_capital = options['capital']

        self.stdout.write(self.style.SUCCESS(f'===== 开始执行回测任务 ====='))
        self.stdout.write(f'  - 起始日期: {start_date}')
        self.stdout.write(f'  - 结束日期: {end_date}')
        self.stdout.write(f'  - 初始资金: {initial_capital:.2f}')

        try:
            service = SimulateTradeService()
            # 注意：我们将所有参数都传递给 run_backtest 方法
            result = service.run_backtest(
                start_date=start_date,
                end_date=end_date,
                initial_capital=initial_capital
            )
            
            self.stdout.write(self.style.SUCCESS('\n===== 回测执行完毕 ====='))
            self.stdout.write(f'最终性能指标: {result}')

        except Exception as e:
            self.stdout.write(self.style.ERROR(f'回测过程中发生严重错误: {e}'))
            # 在生产环境中，可能需要更详细的错误处理和日志记录
            raise e


####文件结束####

####trade_manager\management\commands\run_m_distribution_backtest.py####
# trade_manager/management/commands/run_m_distribution_backtest.py

from django.core.management.base import BaseCommand, CommandParser
from trade_manager.service.m_distribution_backtest_service import MDistributionBacktestService

class Command(BaseCommand):
    help = '运行一个新的、基于M值胜率分布的回测模块'

    def add_arguments(self, parser: CommandParser):
        parser.add_argument(
            '--start',
            type=str,
            required=True,
            help='回测起始日期 (格式: YYYY-MM-DD)'
        )
        parser.add_argument(
            '--end',
            type=str,
            required=True,
            help='回测结束日期 (格式: YYYY-MM-DD)'
        )

        parser.add_argument(
            '--single_strategy_mode',
            action='store_true', # 这会创建一个布尔标志，如果命令行包含此参数，则其值为True
            help='开启单策略M值胜率分布回测模式，会额外为每个策略独立运行回测。'
        )

    def handle(self, *args, **options):
        start_date = options['start']
        end_date = options['end']
        single_strategy_mode = options['single_strategy_mode']
        self.stdout.write(self.style.SUCCESS('===== 开始执行M值胜率分布回测 ====='))
        self.stdout.write(f'  - 起始日期: {start_date}')
        self.stdout.write(f'  - 结束日期: {end_date}')

        try:
            service = MDistributionBacktestService(start_date=start_date, end_date=end_date,single_strategy_mode=single_strategy_mode)
            service.run()
            
            self.stdout.write(self.style.SUCCESS('\n===== M值胜率分布回测执行完毕 ====='))

        except Exception as e:
            self.stdout.write(self.style.ERROR(f'回测过程中发生严重错误: {e}'))
            raise e


####文件结束####

####trade_manager\management\commands\run_scheduler.py####
# trade_manager/management/commands/run_scheduler.py

from django.core.management.base import BaseCommand
from trade_manager.service import scheduler_service
import logging
import time
logger = logging.getLogger(__name__)
class Command(BaseCommand):
    help = '启动自动化交易的 APScheduler 调度器'

    def handle(self, *args, **options):
        self.stdout.write(self.style.SUCCESS('正在启动调度器服务...'))
        scheduler_service.start()
        try:
            # 这是关键：让主进程进入一个无限循环，以防止脚本退出
            # 这样后台的调度器线程才能一直存活
            while True:
                time.sleep(1)  # 每秒检查一次，降低CPU占用
        except (KeyboardInterrupt, SystemExit):
            # 当接收到退出信号时（如Ctrl+C或uWSGI的停止命令）
            # 优雅地关闭调度器
            logger.info("接收到退出信号，正在关闭调度器...")
            scheduler_service.scheduler.shutdown()
            logger.info("调度器已成功关闭。")
            self.stdout.write(self.style.SUCCESS('调度器服务已优雅地停止。'))
        self.stdout.write(self.style.SUCCESS('调度器服务已停止。'))


####文件结束####

####trade_manager\service\backtest_reporter.py####
# ==============================================================================
# 文件 3/5: trade_manager/service/backtest_reporter.py (新增)
# 描述: 负责生成和发送回测邮件报告的模块。
# ==============================================================================
import base64
import io
import logging
from datetime import date
from decimal import Decimal
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import matplotlib.dates as mdates

import pandas as pd
from django.db import connections

from common.models.backtest_logs import BacktestDailyLog, BacktestOperationLog
from common.models.positions import Position
from data_manager.service.email_handler import EmailHandler

logger = logging.getLogger(__name__)

class BacktestReporter:
    """
    回测报告生成与发送器。
    """
    def __init__(self, schema_name: str, start_date: date, current_date: date, initial_capital: Decimal):
        self.schema_name = schema_name
        self.start_date = start_date
        self.current_date = current_date
        self.initial_capital = initial_capital
        self.email_handler = EmailHandler()
        self.recipients = ['876858298@qq.com','850696281@qq.com']#,'285173686@qq.com','850696281@qq.com'
    def _execute_query(self, query: str, params: list = None) -> list[dict]:
        """在指定 schema 中执行原生 SQL 查询并返回结果"""
        with connections['default'].cursor() as cursor:
            cursor.execute(f'SET search_path TO "{self.schema_name}", public;')
            cursor.execute(query, params or [])
            columns = [col[0] for col in cursor.description]
            return [dict(zip(columns, row)) for row in cursor.fetchall()]

    def _generate_report_data(self) -> dict:
        """准备邮件报告所需的所有数据"""
        data = {}

        # 1. 关键指标
        daily_logs = self._execute_query(
            f"SELECT trade_date, total_assets FROM {BacktestDailyLog._meta.db_table} ORDER BY trade_date"
        )
        df_daily = pd.DataFrame(daily_logs)
        df_daily['total_assets'] = df_daily['total_assets'].astype(float)
        
        # 胜率
        sell_ops = self._execute_query(
            f"SELECT exit_reason FROM {BacktestOperationLog._meta.db_table} WHERE direction = 'SELL'"
        )
        if sell_ops:
            total_sells = len(sell_ops)
            profit_sells = sum(1 for op in sell_ops if op['exit_reason'] == 'TAKE_PROFIT')
            data['win_rate'] = profit_sells / total_sells if total_sells > 0 else 0.0
        else:
            data['win_rate'] = 0.0
        
        # 最大回撤
        df_daily['peak'] = df_daily['total_assets'].cummax()
        df_daily['drawdown'] = (df_daily['total_assets'] - df_daily['peak']) / df_daily['peak']
        data['max_drawdown'] = df_daily['drawdown'].min() if not df_daily.empty else 0.0

        # 年化收益率
        final_assets = float(df_daily['total_assets'].iloc[-1]) if not df_daily.empty else float(self.initial_capital)
        days_passed = (self.current_date - self.start_date).days
        if days_passed > 0:
            data['annualized_return'] = ((final_assets / float(self.initial_capital)) ** (365.0 / days_passed)) - 1
        else:
            data['annualized_return'] = 0.0

        # 2. 资金曲线图数据
        data['plot_data'] = self._execute_query(
            f"SELECT trade_date, total_assets, market_m_value FROM {BacktestDailyLog._meta.db_table} ORDER BY trade_date"
        )

        # 3. 当前持仓
        data['current_holdings'] = self._execute_query(
            f"""
            SELECT p.stock_code, si.stock_name, p.entry_price, p.quantity, 
                   p.current_take_profit, p.current_stop_loss, dq.close as current_price
            FROM {Position._meta.db_table} p
            JOIN public.tb_stock_info si ON p.stock_code = si.stock_code
            LEFT JOIN public.tb_daily_quotes dq ON p.stock_code = dq.stock_code AND dq.trade_date = %s
            WHERE p.status = 'open'
            """, [self.current_date]
        )
        for h in data['current_holdings']:
            entry_price = h['entry_price']
            if entry_price and entry_price > 0:
                # 新的计算方式：将止盈/止损价表示为成本价的百分比
                h['profit_level_pct'] = h['current_take_profit'] / entry_price
                h['loss_level_pct'] = h['current_stop_loss'] / entry_price
            else:
                # 处理 entry_price 无效的情况
                h['profit_level_pct'] = Decimal('0.0')
                h['loss_level_pct'] = Decimal('0.0')

        # 4. 收益排名
        all_ops = self._execute_query(f"SELECT stock_code, stock_name, direction, amount FROM {BacktestOperationLog._meta.db_table}")
        profits = {}
        for op in all_ops:
            key = (op['stock_code'], op['stock_name'])
            if op['direction'] == 'BUY':
                profits[key] = profits.get(key, 0) - op['amount']
            else: # SELL
                profits[key] = profits.get(key, 0) + op['amount']
        # 总收益 = 已实现盈亏 + 未实现盈亏
        #        = (卖出总额 - 买入总额) + (当前市值 - 持仓成本)
        #        = (卖出总额) - (已平仓部分的买入成本) + (当前市值)
        # 之前的循环已经计算了 (卖出总额 - 全部买入成本)，所以我们只需加上当前市值即可。
        for holding in data['current_holdings']:
            key = (holding['stock_code'], holding['stock_name'])
            
            # 处理当天可能没有行情数据的情况，若无当前价则按入场价计算，浮动盈亏为0
            current_price = holding['current_price'] or holding['entry_price']
            
            # 计算当前持仓的总市值
            current_market_value = holding['quantity'] * current_price
            
            # 将当前市值加到该股票的累计收益中
            profits[key] = profits.get(key, 0) + current_market_value
        profit_list = [{'stock_code': k[0], 'stock_name': k[1], 'profit': v} for k, v in profits.items()]
        data['profit_ranking'] = sorted(profit_list, key=lambda x: x['profit'], reverse=True)

        return data

    def _generate_plot_base64(self, plot_data: list[dict]) -> str:
        if not plot_data:
            return ""
        
        try:
            plt.rcParams['font.sans-serif'] = ['SimHei', 'Microsoft YaHei']
            plt.rcParams['axes.unicode_minus'] = False
        except Exception as e:
            pass
        
        try:
            df = pd.DataFrame(plot_data)
            # 确保数据类型正确
            df['trade_date'] = pd.to_datetime(df['trade_date'])
            df['total_assets'] = pd.to_numeric(df['total_assets'])
            df['market_m_value'] = pd.to_numeric(df['market_m_value'])

            if df.empty:
                return ""

            plt.style.use('seaborn-v0_8-whitegrid')
            fig, ax1 = plt.subplots(figsize=(14, 7))

            # 绘制主曲线
            ax1.plot(df['trade_date'], df['total_assets'], color='dodgerblue', label='money', linewidth=2)
            ax1.set_xlabel('date', fontsize=12)
            ax1.set_ylabel('money', color='dodgerblue', fontsize=12)
            ax1.tick_params(axis='y', labelcolor='dodgerblue')
            ax1.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: format(int(x), ',')))

            # 绘制副坐标轴曲线
            ax2 = ax1.twinx()
            ax2.plot(df['trade_date'], df['market_m_value'], color='coral', linestyle='--', label='M', alpha=0.7)
            ax2.set_ylabel('M', color='coral', fontsize=12)
            ax2.tick_params(axis='y', labelcolor='coral')
            ax2.axhline(0, color='grey', linestyle=':', linewidth=1)

            # ======================= 主要修改点 =======================
            # 1. 更健壮和简化的X轴刻度逻辑
            num_days = (df['trade_date'].max() - df['trade_date'].min()).days
            
            if num_days <= 60:  # 2个月以内，按周显示
                locator = mdates.WeekdayLocator(byweekday=mdates.MO)
                formatter = mdates.DateFormatter('%m-%d')
            elif num_days <= 365 * 2: # 2年以内，按季度显示
                locator = mdates.MonthLocator(interval=3)
                formatter = mdates.DateFormatter('%Y-%m')
            elif num_days <= 365 * 5: # 5年以内，按半年显示
                locator = mdates.MonthLocator(interval=6)
                formatter = mdates.DateFormatter('%Y-%m')
            else:  # 超过5年，按年显示
                locator = mdates.YearLocator()
                formatter = mdates.DateFormatter('%Y')
            
            ax1.xaxis.set_major_locator(locator)
            ax1.xaxis.set_major_formatter(formatter)

            # 2. 移除 fig.autofmt_xdate()，并手动设置标签旋转，避免冲突
            plt.setp(ax1.get_xticklabels(), rotation=30, ha='right')
            # ========================================================

            fig.suptitle('Money-M(t)', fontsize=16, weight='bold')
            fig.legend(loc='upper left', bbox_to_anchor=(0.1, 0.9))
            
            # 使用 tight_layout 替代
            plt.tight_layout(rect=[0, 0, 1, 0.96])

            # 保存图像到内存
            buf = io.BytesIO()
            plt.savefig(buf, format='png', dpi=100)
            plt.close(fig)
            buf.seek(0)
            return base64.b64encode(buf.getvalue()).decode('utf-8')
        finally:
            pass



    def _format_html_content(self, data: dict, plot_base64: str) -> str:
        
        # ======================= 修复颜色逻辑 =======================
        # 修复：盈利 (value > 0) 为绿色，亏损 (value < 0) 为红色
        def get_row_style(value):
            if value > 0:
                return 'style="background-color: #e9f5e9; color: #1e7e34;"'  # 绿色背景，深绿色文字
            elif value < 0:
                return 'style="background-color: #fdeaea; color: #c82333;"'  # 红色背景，深红色文字
            else:
                return '' # 中性
        # ==========================================================
        # Part 1: Key Metrics
        html = f"""
        <h2>关键指标 (截至 {self.current_date.strftime('%Y-%m-%d')})</h2>
        <table class="summary-table">
            <tr>
                <th>胜率</th><td>{data['win_rate']:.2%}</td>
                <th>最大回撤</th><td style="color: #c82333;">{data['max_drawdown']:.2%}</td>
                <th>年化收益率</th><td>{data['annualized_return']:.2%}</td>
            </tr>
        </table>
        """
        # Part 2: Plot
        html += f"""
        <h2>资金与M值变化趋势</h2>
        <div style="text-align: center;">
            <img src="data:image/png;base64,{plot_base64}" alt="Performance Chart" style="max-width: 100%;">
        </div>
        """
        # Part 3: Current Holdings
        html += "<h2>当前持仓情况</h2>"
        if data['current_holdings']:
            html += """
            <table class="data-table">
                <thead><tr><th>股票代码</th><th>股票名称</th><th>入场价</th><th>当前价</th><th>浮动盈亏</th><th>止盈价格</th><th>止损价格</th><th>止盈线位置</th><th>止损线位置</th></tr></thead>
                <tbody>
            """
            for h in data['current_holdings']:
                current_price = h['current_price'] or h['entry_price']
                profit_loss = current_price - h['entry_price']
                profit_loss_rate = (current_price / h['entry_price'] - 1) if h['entry_price'] else 0
                style = get_row_style(profit_loss)
                profit_level_str = f"{h['profit_level_pct']:.2%}"
                loss_level_str = f"{h['loss_level_pct']:.2%}"
                html += f"""
                <tr {style}>
                    <td>{h['stock_code']}</td>
                    <td>{h['stock_name']}</td>
                    <td>{h['entry_price']:.2f}</td>
                    <td>{current_price:.2f}</td>
                    <td>{profit_loss_rate:.2%}</td>
                    <td>{h['current_take_profit']:.2f}</td>
                    <td>{h['current_stop_loss']:.2f}</td>
                    <td style="color: #c82333;">{profit_level_str}</td>
                    <td style="color: #1e7e34;">{loss_level_str}</td>
                </tr>
                """
            html += "</tbody></table>"
        else:
            html += "<p>当前无持仓。</p>"
        # Part 4: Profit Ranking
        html += "<h2>各股累计收益排名</h2>"
        if data['profit_ranking']:
            html += """
            <table class="data-table">
                <thead><tr><th>排名</th><th>股票代码</th><th>股票名称</th><th>累计收益(元)</th></tr></thead>
                <tbody>
            """
            for i, p in enumerate(data['profit_ranking'], 1):
                # 这里复用上面修改好的颜色逻辑
                style = get_row_style(p['profit'])
                html += f"""
                <tr {style}>
                    <td>{i}</td>
                    <td>{p['stock_code']}</td>
                    <td>{p['stock_name']}</td>
                    <td>{p['profit']:,.2f}</td>
                </tr>
                """
            html += "</tbody></table>"
        else:
            html += "<p>暂无已平仓的交易。</p>"
        # Final HTML structure (保持不变)
        final_html = f"""
        <!DOCTYPE html>
        <html lang="zh-CN">
        <head>
            <meta charset="UTF-8">
            <title>回测报告</title>
            <style>
                body {{ font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; margin: 20px; background-color: #f4f7f6; color: #333; }}
                h2 {{ color: #0056b3; border-bottom: 2px solid #e0e0e0; padding-bottom: 8px; margin-top: 30px; }}
                table {{ width: 100%; border-collapse: collapse; margin-top: 15px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }}
                th, td {{ padding: 12px 15px; text-align: left; border-bottom: 1px solid #ddd; }}
                th {{ background-color: #f8f9fa; }}
                .summary-table th {{ width: 15%; background-color: #e9ecef; }}
                .summary-table td {{ font-weight: bold; font-size: 1.1em; }}
                .data-table tbody tr:hover {{ background-color: #f1f1f1; }}
            </style>
        </head>
        <body>
            <h1>回测进度报告: {self.start_date}~{self.current_date}回测</h1>
            {html}
        </body>
        </html>
        """
        return final_html

    def send_report(self):
        """生成并发送报告邮件"""
        logger.info(f"[{self.schema_name}] 正在生成截至 {self.current_date} 的回测报告...")
        try:
            report_data = self._generate_report_data()
            plot_base64 = self._generate_plot_base64(report_data.get('plot_data', []))
            html_content = self._format_html_content(report_data, plot_base64)
            subject = f"回测报告 ({self.start_date}~{self.current_date}) - {self.current_date.strftime('%Y-%m-%d')}"
            
            self.email_handler.send_email(
                recipients=self.recipients,
                subject=subject,
                html_content=html_content
            )
            logger.info(f"[{self.start_date}~{self.current_date}] 回测报告邮件已成功发送。")
        except Exception as e:
            logger.error(f"[{self.start_date}~{self.current_date}] 生成或发送回测报告时失败: {e}", exc_info=True)


####文件结束####

####trade_manager\service\before_fix_service.py####
# trade_manager/service/before_fix_service.py

import logging
from datetime import date, timedelta, datetime
from decimal import Decimal, ROUND_HALF_UP
from django.utils import timezone
from django.db import transaction
from django.db.models import Q

# 导入项目内的模型
from common.models import (
    CorporateAction,
    DailyTradingPlan,
    Position,
    DailyQuotes,
    SystemLog
)

# 配置日志记录器
logger = logging.getLogger(__name__)


class BeforeFixService:
    """
    T日开盘前校准与预案修正服务。

    职责:
    1. 检查当天是否已成功执行过，防止重复运行。
    2. 获取T日的除权除息事件。
    3. 计算受影响股票的价格调整比率。
    4. 根据比率修正“每日交易预案”中的MIOP和MAOP。
    5. 根据比率修正“持仓信息”中的止盈止损价。
    6. 对近期发生配股的股票进行特殊风险处理。
    """
    MODULE_NAME = '盘前校准与预案修正'
    # 可配置参数
    MAX_PLAN_LOOKBACK_DAYS = 14  # 查找交易预案的最大回溯天数
    RIGHTS_ISSUE_LOOKBACK_DAYS = 30 # 配股事件特殊处理的回溯交易日数

    def __init__(self, execution_date: date = None):
        """
        初始化服务。
        :param execution_date: T日，即执行校准的日期。如果为None，则默认为当天。
        """
        self.t_day = execution_date if execution_date else date.today()
        self.t_minus_1_day = None
        self.adjustment_ratios = {} # 存储 {stock_code: ratio}
        logger.debug(f"[{self.MODULE_NAME}] 服务初始化，目标T日: {self.t_day}")

    def _log_to_db(self, level: str, message: str):
        """辅助方法：将日志写入数据库"""
        try:
            SystemLog.objects.create(
                log_level=level,
                module_name=self.MODULE_NAME,
                message=message
            )
        except Exception as e:
            logger.error(f"无法将日志写入数据库: {e}")

    def _is_trading_day(self, check_date: date) -> bool:
        """检查指定日期是否为交易日"""
        is_trade_day = DailyQuotes.objects.filter(trade_date=check_date).exists()
        logger.info(f"检查日期 {check_date} 是否为交易日: {'是' if is_trade_day else '否'}")
        return is_trade_day

    def _get_last_trading_day(self, from_date: date) -> date | None:
        """获取指定日期之前的最后一个交易日"""
        last_day = DailyQuotes.objects.filter(
            trade_date__lt=from_date
        ).order_by('-trade_date').values_list('trade_date', flat=True).first()
        
        if last_day:
            logger.info(f"{from_date} 的前一个交易日 (T-1) 是: {last_day}")
        else:
            logger.warning(f"无法找到 {from_date} 的前一个交易日。")
        return last_day

    def _find_latest_pending_plan_date(self) -> date | None:
        """从T日开始向前回溯，查找最新的一个包含待执行预案的日期"""
        for i in range(self.MAX_PLAN_LOOKBACK_DAYS):
            check_date = self.t_day - timedelta(days=i)
            if DailyTradingPlan.objects.filter(
                plan_date=check_date,
                status=DailyTradingPlan.StatusChoices.PENDING
            ).exists():
                logger.info(f"找到待执行的交易预案，预案日期为: {check_date}")
                return check_date
        logger.warning(f"在过去 {self.MAX_PLAN_LOOKBACK_DAYS} 天内未找到任何待执行的交易预案。")
        return None

    def _calculate_adjustment_ratios(self, events: list[CorporateAction]) -> tuple[Decimal, Decimal]:
        """
        核心算法：根据事件列表计算除权除息参考价。
        处理顺序：1.除息 -> 2.送/转股 -> 3.配股
        """
        price_ratio = Decimal('1.0')
        quantity_ratio = Decimal('1.0')


        
        # 按事件类型优先级排序
        event_priority = {
            CorporateAction.EventType.DIVIDEND: 1,
            CorporateAction.EventType.BONUS: 2,
            CorporateAction.EventType.TRANSFER: 2,
            CorporateAction.EventType.SPLIT: 2
            #CorporateAction.EventType.RIGHTS: 3,
        }
        sorted_events = sorted(events, key=lambda e: event_priority.get(e.event_type, 99))

        for event in sorted_events:
            # 送股/转增股/并股/拆股 (除权)
            if event.event_type in [CorporateAction.EventType.BONUS, CorporateAction.EventType.TRANSFER, CorporateAction.EventType.SPLIT]:
                if event.shares_before and event.shares_after and event.shares_after > 0:
                    # 价格比率 = 旧股数 / 新股数
                    price_ratio *= (event.shares_before / event.shares_after)
                    # 数量比率 = 新股数 / 旧股数
                    quantity_ratio *= (event.shares_after / event.shares_before)
        
        return price_ratio, quantity_ratio

    @transaction.atomic
    def run(self):
        """执行盘前校准与修正的主流程"""

        self.t_minus_1_day = self._get_last_trading_day(self.t_day)
        if not self.t_minus_1_day:
            logger.error(f"无法确定T-1日，任务终止。")
            return

        # a. 获取T日所有除权除息信息
        events_on_t_day = CorporateAction.objects.filter(ex_dividend_date=self.t_day)
        if not events_on_t_day.exists():
            logger.debug(f"T日 ({self.t_day}) 无除权除息事件，无需校准。")
            return

        # 按股票代码分组事件
        events_by_stock = {}
        for event in events_on_t_day:
            if event.event_type != CorporateAction.EventType.RIGHTS:
                 events_by_stock.setdefault(event.stock_code, []).append(event)
        
        affected_codes = list(events_by_stock.keys())
        if not affected_codes:
            logger.info("T日只有配股事件，常规校准流程跳过。")
            self._handle_rights_issue_special_case() # 仍然要处理配股的特殊情况
            return
        logger.info(f"T日共有 {len(affected_codes)} 只股票发生股权事件。")

        # 获取这些股票在T-1日的收盘价
        quotes_qs = DailyQuotes.objects.filter(
            trade_date=self.t_minus_1_day,
            stock_code_id__in=affected_codes
        )
        # 使用字典推导式构建我们需要的映射关系
        quotes_t_minus_1 = {quote.stock_code_id: quote for quote in quotes_qs}
        self.adjustment_ratios = {} 
        # b. 计算价格调整比率
        for stock_code, events in events_by_stock.items():
            if stock_code not in quotes_t_minus_1:
                logger.warning(f"股票 {stock_code} 在T-1日({self.t_minus_1_day})无行情数据（可能停牌），跳过校准。")
                continue
            
            close_t_minus_1 = quotes_t_minus_1[stock_code].close
            if close_t_minus_1 <= 0:
                logger.warning(f"股票 {stock_code} 在T-1日收盘价为0或负数，不合理，跳过校准。")
                continue
            # 1. 计算送/转/拆/并股的比率
            price_ratio_st, quantity_ratio_st = self._calculate_adjustment_ratios(events)
            # 2. 计算分红的价格影响
            total_dividend = sum(e.dividend_per_share for e in events if e.event_type == CorporateAction.EventType.DIVIDEND and e.dividend_per_share)
            
            price_ratio_div = Decimal('1.0')
            if total_dividend > 0:
                # 分红的价格调整比率 = (收盘价 - 分红) / 收盘价
                price_ratio_div = (close_t_minus_1 - total_dividend) / close_t_minus_1
            # 3. 合并总比率
            final_price_ratio = price_ratio_st * price_ratio_div
            final_quantity_ratio = quantity_ratio_st # 分红不影响数量
            self.adjustment_ratios[stock_code] = (final_price_ratio, final_quantity_ratio)
            
            logger.info(f"股票 {stock_code}: T-1收盘价={close_t_minus_1}, "
                        f"价格调整比率={final_price_ratio:.6f}, "
                        f"数量调整比率={final_quantity_ratio:.6f}")

        # c. 修正交易预案
        self._process_trading_plans()

        # d. 修正持仓风控
        self._process_positions()

        # e. 配股事件特殊处理
        self._handle_rights_issue_special_case()

        logger.info(f"[{self.MODULE_NAME}] 任务成功完成。共处理 {len(self.adjustment_ratios)} 只股票的常规校准。")

    def _process_trading_plans(self):
        """修正交易预案中的MIOP和MAOP"""
        plan_date_to_fix = self._find_latest_pending_plan_date()
        if not plan_date_to_fix:
            return

        plans_to_fix = DailyTradingPlan.objects.filter(
            plan_date=plan_date_to_fix,
            status=DailyTradingPlan.StatusChoices.PENDING,
            stock_code__in=self.adjustment_ratios.keys()
        )

        plans_to_update = []
        for plan in plans_to_fix:
            price_ratio, _ = self.adjustment_ratios[plan.stock_code_id]
            original_miop = plan.miop
            original_maop = plan.maop
            
            plan.miop = (original_miop * price_ratio).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            plan.maop = (original_maop * price_ratio).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            
            plans_to_update.append(plan)
            logger.info(f"交易预案修正: {plan.stock_code_id}, MIOP: {original_miop}->{plan.miop}, MAOP: {original_maop}->{plan.maop}")

        if plans_to_update:
            DailyTradingPlan.objects.bulk_update(plans_to_update, ['miop', 'maop'])
            logger.info(f"成功批量更新 {len(plans_to_update)} 条交易预案。")

    def _process_positions(self):
        """修正持仓中的止盈止损价"""
        positions_to_fix = Position.objects.filter(
            status=Position.StatusChoices.OPEN,
            stock_code__in=self.adjustment_ratios.keys()
        )

        positions_to_update = []
        update_fields = ['entry_price', 'quantity', 'current_stop_loss', 'current_take_profit']
        for pos in positions_to_fix:
            price_ratio, quantity_ratio = self.adjustment_ratios[pos.stock_code_id]
            
            original_ep = pos.entry_price
            original_qty = pos.quantity
            original_sl = pos.current_stop_loss
            original_tp = pos.current_take_profit
            # 【新增】调整成本价
            pos.entry_price = (original_ep * price_ratio).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            
            # 【新增】调整持仓数量，并取整到股
            pos.quantity = int((Decimal(str(original_qty)) * quantity_ratio).to_integral_value(rounding=ROUND_HALF_UP))
            # 【修改】调整止盈止损价
            pos.current_stop_loss = (original_sl * price_ratio).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            pos.current_take_profit = (original_tp * price_ratio).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            
            positions_to_update.append(pos)
            logger.info(f"持仓风控修正: {pos.stock_code_id}, "
                        f"成本价: {original_ep:.2f} -> {pos.entry_price:.2f}, "
                        f"数量: {original_qty} -> {pos.quantity}, "
                        f"止损: {original_sl:.2f} -> {pos.current_stop_loss:.2f}, "
                        f"止盈: {original_tp:.2f} -> {pos.current_take_profit:.2f}")

        if positions_to_update:
            Position.objects.bulk_update(positions_to_update, ['current_stop_loss', 'current_take_profit'])
            logger.info(f"成功批量更新 {len(positions_to_update)} 条持仓记录。")

    def _handle_rights_issue_special_case(self):
        """处理30个交易日内有配股事件的股票"""
        # 1. 获取过去30个交易日的日期列表
        recent_trading_days = list(
            DailyQuotes.objects.filter(trade_date__lte=self.t_day)
            .order_by('-trade_date')
            .values_list('trade_date', flat=True)[:self.RIGHTS_ISSUE_LOOKBACK_DAYS]
        )
        if not recent_trading_days:
            logger.warning("无法获取最近交易日列表，跳过配股特殊处理。")
            return

        # 2. 查找在此期间发生配股的股票
        rights_issue_stocks = list(
            CorporateAction.objects.filter(
                event_type=CorporateAction.EventType.RIGHTS,
                ex_dividend_date__in=recent_trading_days
            ).values_list('stock_code', flat=True).distinct()
        )
        if not rights_issue_stocks:
            logger.info("近期无配股事件，无需特殊处理。")
            return
        
        logger.warning(f"检测到 {len(rights_issue_stocks)} 只股票近期有配股事件: {rights_issue_stocks}，将进行风险剔除。")

        # 3. 处理交易预案
        plan_date_to_fix = self._find_latest_pending_plan_date()
        if plan_date_to_fix:
            plans_to_void = DailyTradingPlan.objects.filter(
                plan_date=plan_date_to_fix,
                status=DailyTradingPlan.StatusChoices.PENDING,
                stock_code__in=rights_issue_stocks
            )
            plans_to_update = []
            for plan in plans_to_void:
                plan.miop = Decimal('99999.00')
                plan.maop = Decimal('0.00')
                plans_to_update.append(plan)
            
            if plans_to_update:
                DailyTradingPlan.objects.bulk_update(plans_to_update, ['miop', 'maop'])
                logger.info(f"配股风险处理：将 {len(plans_to_update)} 条交易预案的MIOP/MAOP置为无效。")

        # 4. 处理持仓
        positions_to_void = Position.objects.filter(
            status=Position.StatusChoices.OPEN,
            stock_code__in=rights_issue_stocks
        )
        positions_to_update = []
        for pos in positions_to_void:
            pos.current_take_profit = Decimal('0.00')
            pos.current_stop_loss = Decimal('99999.00')
            positions_to_update.append(pos)
        
        if positions_to_update:
            Position.objects.bulk_update(positions_to_update, ['current_take_profit', 'current_stop_loss'])
            logger.info(f"配股风险处理：将 {len(positions_to_update)} 条持仓的止盈/止损置为紧急退出状态。")


# --- 如何在项目中使用这个服务 ---
# 你可以在一个Django Management Command或者定时任务（如Celery）中调用它
#
# from trade_manager.service.before_fix_service import BeforeFixService
#
# def run_daily_premarket_fix():
#     # 默认使用当天日期
#     service = BeforeFixService()
#     service.run()
#
# def run_backtest_premarket_fix(some_date):
#     # 传入指定日期进行回测
#     service = BeforeFixService(execution_date=some_date)
#     service.run()


####文件结束####

####trade_manager\service\db_utils.py####
# trade_manager/service/db_utils.py

import contextlib
import logging
import threading
from django.db import connections
from django.db.backends.signals import connection_created

logger = logging.getLogger(__name__)

# 使用线程局部存储来安全地在多线程环境中传递 schema 名称
_db_context = threading.local()

def backtest_schema_handler(sender, connection, **kwargs):
    """
    Django `connection_created` 信号的处理器。
    当一个新的数据库连接被创建时，此函数会被调用。
    它会检查当前线程是否在 `use_backtest_schema` 上下文中，
    如果是，则立即为这个新连接设置正确的 search_path。
    """
    if hasattr(_db_context, 'schema_name') and _db_context.schema_name:
        schema_name = _db_context.schema_name
        logger.debug(f"新数据库连接创建，为其设置 search_path -> {schema_name}, public")
        with connection.cursor() as cursor:
            # 使用参数化查询防止SQL注入
            cursor.execute("SET search_path TO %s, public;", [schema_name])

# 将信号处理器连接到 `connection_created` 信号
# dispatch_uid 确保即使代码被多次导入，信号处理器也只连接一次
connection_created.connect(backtest_schema_handler, dispatch_uid="set_backtest_search_path")

@contextlib.contextmanager
def use_backtest_schema(schema_name: str):
    """
    一个上下文管理器，用于在特定代码块内将所有数据库操作重定向到指定的 schema。

    用法:
    with use_backtest_schema('my_backtest_schema'):
        # 此处所有的 Django ORM 操作都会在 'my_backtest_schema' 中进行
        MyModel.objects.create(...)
    """
    # 进入 with 块时，设置线程局部变量
    _db_context.schema_name = schema_name
    # 强制关闭当前线程的现有连接，以确保下一个查询会创建一个新连接，从而触发信号处理器
    connections['default'].close()
    try:
        # 将控制权交还给 with 块内的代码
        yield
    finally:
        # 退出 with 块时（无论成功还是异常），清理线程局部变量
        if hasattr(_db_context, 'schema_name'):
            del _db_context.schema_name
        # 再次关闭连接，以便后续操作能恢复到默认的 search_path
        connections['default'].close()
        logger.debug("已退出回测 schema 上下文，恢复默认 search_path。")


####文件结束####

####trade_manager\service\decision_order_service.py####
# trade_manager/service/decision_order_service.py
# 版本: 2.0 - M(t)驱动的动态风险管理
# 描述: 此版本重构了止盈止损计算逻辑，使其与动态选股策略的市场状态判断(M(t))保持一致。
#       解决了旧版在非趋势行情中止损价可能高于止盈价的严重逻辑问题。

import logging
from datetime import date, timedelta
from decimal import Decimal, ROUND_HALF_UP
import pandas as pd
import pandas_ta as ta

from django.db import transaction
from django.utils import timezone

from common.models import (
    DailyTradingPlan,
    Position,
    TradeLog,
    StrategyParameters,
    DailyQuotes,
    SystemLog,
    DailyFactorValues  # 新增导入
)
from .trade_handler import ITradeHandler
from selection_manager.service.selection_service import MARKET_INDICATOR_CODE # 新增导入

# 配置日志记录器
logger = logging.getLogger(__name__)

class DecisionOrderService:
    """
    开盘决策与下单模块 (V2.0 - 动态风险版)。

    该服务负责在T日开盘后的黄金时间内，根据预案、实际开盘价和账户状态，
    做出最终的买入决策，并执行下单。其核心特色是，在订单成交后，
    能够根据T-1日的市场状态M(t)，为新持仓计算动态的、自适应的止盈止损价。
    """
    MODULE_NAME = '开盘决策与下单(动态风险版)'
    MAX_PLAN_LOOKBACK_DAYS = 14

    def __init__(self, handler: ITradeHandler, execution_date: date = None):
        """
        初始化服务。

        :param handler: 一个实现了 ITradeHandler 接口的实例，用于与交易环境交互。
        :param execution_date: T日，即执行决策的日期。如果为None，则默认为当天。
        """
        if not isinstance(handler, ITradeHandler):
            raise TypeError("传入的 handler 必须是 ITradeHandler 的一个实例。")
      
        self.handler = handler
        self.execution_date = execution_date if execution_date else date.today()
        self.params = self._load_strategy_parameters()
      
        # 新增：用于存储当日动态计算结果的实例变量
        self.current_max_positions = 0
        self.final_nominal_principal = Decimal('0.0')
 
        # 【全新】调用新的初始化引擎
        self._initialize_position_sizing_engine()
      
        logger.debug(f"[{self.MODULE_NAME}] 服务初始化。执行T日: {self.execution_date}")
        logger.debug(f"策略参数加载成功: {len(self.params)}个")
        logger.debug(f"当日动态最大持仓数: {self.current_max_positions}")
        logger.debug(f"当日动态单位名义本金: {self.final_nominal_principal:.2f}")

    def _initialize_position_sizing_engine(self):
        """
        【全新方法】
        在服务初始化时，完成所有基于T-1日M(t)的仓位 sizing 计算。
        """
        try:
            # 1. 获取T-1交易日
            t_minus_1_date = DailyQuotes.objects.filter(trade_date__lt=self.execution_date).latest('trade_date').trade_date
        except DailyQuotes.DoesNotExist:
            logger.error(f"无法找到 {self.execution_date} 的前一个交易日，动态仓位管理无法启动，将使用默认值。")
            self.current_max_positions = self.params.get('MIN_POSITIONS_COUNT', 1)
            self.final_nominal_principal = Decimal('0.0') # 导致无法买入
            return
 
        # 2. 获取T-1日的市场状态M(t)
        market_regime_M = self._get_market_regime_M(t_minus_1_date)
        market_regime_S = self._get_market_regime_S(t_minus_1_date)
        logger.info(f"获取到 T-1 ({t_minus_1_date}) 的 M(t) = {market_regime_M:.4f}")
 
        # 3. 计算当日动态最大持仓数
        self.current_max_positions = self._calculate_dynamic_max_positions(market_regime_M)
        
        # 4. 计算当日动态单位名义本金
        self.final_nominal_principal = self._calculate_dynamic_nominal_principal(market_regime_M, t_minus_1_date)
 
    def _get_market_regime_M(self, t_minus_1_date: date) -> Decimal:
        """
        【全新方法】
        从数据库获取指定日期的 M(t) 值。
        """
        try:
            m_value_record = DailyFactorValues.objects.get(
                stock_code_id=MARKET_INDICATOR_CODE,
                trade_date=t_minus_1_date,
                factor_code_id='dynamic_M_VALUE'
            )
            return m_value_record.raw_value
        except DailyFactorValues.DoesNotExist:
            logger.error(f"严重警告: 无法在 {t_minus_1_date} 找到市场状态M(t)值！将使用最保守的中性值0.0进行计算。")
            return Decimal('0.0')
        
    def _get_market_regime_S(self, t_minus_1_date: date) -> Decimal:
        """
        【全新方法】
        从数据库获取指定日期的 S(t) 值。
        """
        try:
            m_value_record = DailyFactorValues.objects.get(
                stock_code_id=MARKET_INDICATOR_CODE,
                trade_date=t_minus_1_date,
                factor_code_id='dynamic_S_VALUE'
            )
            return m_value_record.raw_value
        except DailyFactorValues.DoesNotExist:
            logger.error(f"严重警告: 无法在 {t_minus_1_date} 找到市场状态S(t)值！将使用最保守的中性值0.0进行计算。")
            return Decimal('0.0')
 
    def _calculate_dynamic_max_positions(self, M_t: Decimal) -> int:
        """
        【全新方法】
        根据M(t)计算动态最大持仓数 Current_Max_Positions。
        """
        S_min_pos = self.params['RISK_ADJ_POS_FLOOR_PCT']
        
        # i. 计算总仓位数风险缩放因子 S_pos(M(t))
        S_pos = S_min_pos + (1 - S_min_pos) * (M_t + 1) / 2
        
        # ii. 计算理论最大仓位数
        base_max_pos = self.params['ORIGINAL_MAX_POSITIONS']
        theoretical_max = Decimal(base_max_pos) * S_pos
        
        # iii. 取整并应用下限
        min_pos_count = self.params['MIN_POSITIONS_COUNT']
        current_max_positions = max(min_pos_count, int(theoretical_max.to_integral_value(rounding='ROUND_FLOOR')))
        current_max_positions=base_max_pos
        logger.debug(f"动态持仓数计算: S_pos={S_pos:.4f}, 理财持仓={theoretical_max:.2f}, 最终取整={current_max_positions}")
        return current_max_positions
 
    def _calculate_dynamic_nominal_principal(self, M_t: Decimal, t_minus_1_date: date) -> Decimal:
        """
        【全新方法】
        根据M(t)计算动态单位名义本金 Final_Nominal_Principal。
        """
        # i. 获取当前总资产
        cash_balance = self.handler.get_available_balance()
        positions_market_value = Decimal('0.0')
        open_positions = Position.objects.filter(status=Position.StatusChoices.OPEN)
        if open_positions.exists():
            for pos in open_positions:
                try:
                    quote = DailyQuotes.objects.get(stock_code_id=pos.stock_code_id, trade_date=t_minus_1_date)
                    positions_market_value += quote.close * pos.quantity
                except DailyQuotes.DoesNotExist:
                    positions_market_value += pos.entry_price * pos.quantity
        
        total_assets = cash_balance + positions_market_value
        logger.debug(f"总资产计算: 现金{cash_balance:.2f} + 持仓市值{positions_market_value:.2f} = {total_assets:.2f}")
 
        # ii. 计算基准单位名义本金
        base_max_pos = self.params['ORIGINAL_MAX_POSITIONS']
        if base_max_pos <= 0: return Decimal('0.0')
        baseline_unit_principal = total_assets / Decimal(base_max_pos)
        
        # iii. 计算单位名义本金风险缩放因子 S_cap(M(t))
        S_min_cap = self.params['RISK_ADJ_CAPITAL_FLOOR_PCT']
        S_cap = S_min_cap + (1 - S_min_cap) * (M_t + 1) / 2
        # if M_t > Decimal('0.5'):
        #     S_cap = Decimal('1.0')
        # elif M_t > Decimal('0.0'):
        #     S_cap = Decimal('0.5')
        # else:
        #     S_cap = Decimal('0.0')
        epsilon = Decimal(1e-9)
        if abs(M_t) < epsilon:
            S_cap=Decimal('0.0')
        elif M_t<Decimal('0.0'):
            S_cap=Decimal('0.0')
        else:
            S_cap=min(M_t*2,Decimal('1.0'))
            #Decimal('1.0')
        
        #S_cap=Decimal('1.0')
        # iv. 计算动态调整后的名义本金
        adjusted_unit_principal = baseline_unit_principal * S_cap
        
        logger.debug(f"动态名义本金计算: 基准本金={baseline_unit_principal:.2f}, S_cap={S_cap:.4f}, 调整后本金={adjusted_unit_principal:.2f}")
        
        # v. 确定最终下单名义本金 - 注意：与可用现金的比较将在下单时进行
        return adjusted_unit_principal

    def _log_to_db(self, level: str, message: str):
        """辅助方法：将日志写入数据库"""
        # 在高频回测中可以注释掉此方法以提高性能
        # SystemLog.objects.create(
        #     log_level=level,
        #     module_name=self.MODULE_NAME,
        #     message=message
        # )
        pass
    def _find_relevant_plan_date(self) -> date | None:
        # 1. 计算查询的起始日期
        start_date = self.execution_date - timedelta(days=self.MAX_PLAN_LOOKBACK_DAYS - 1)
        
        # 2. 执行一次数据库查询
        latest_plan = DailyTradingPlan.objects.filter(
            plan_date__gte=start_date,  # gte = greater than or equal to (大于等于)
            plan_date__lte=self.execution_date, # lte = less than or equal to (小于等于)
            status=DailyTradingPlan.StatusChoices.PENDING
        ).order_by('-plan_date').first() # 按日期降序排列，并取第一个
    
        # 3. 处理查询结果
        if latest_plan:
            found_date = latest_plan.plan_date
            if found_date != self.execution_date:
                logger.info(f"执行日 {self.execution_date} 无预案，回溯找到待执行预案，其生成日期为: {found_date}")
            else:
                logger.debug(f"找到当天 {found_date} 的待执行预案。")
            return found_date
        
        # 如果查询结果为空
        logger.warning(f"在过去 {self.MAX_PLAN_LOOKBACK_DAYS} 天内（从 {self.execution_date} 开始回溯）未找到任何待执行的交易预案。")
        return None
    def _load_strategy_parameters(self) -> dict:
        """从数据库加载所有策略参数到内存"""
        params = {}
        # 定义需要加载的参数及其默认值
        # 注意：这里的键名应与 initialize_strategy_parameters 中定义的完全一致
        required_params = {
            # 通用参数
            #'MAX_POSITIONS': '3',
            'MAX_CAPITAL_PER_POSITION': '20000.00',
            'k_slip': '0.002',
            'lookback_atr': '14',
            # 新版动态风险参数
            'risk_adj_tp_pct_min': '0.15',
            'risk_adj_tp_pct_max': '0.15',
            'risk_adj_sl_atr_min': '2',
            'risk_adj_sl_atr_max': '2',
            'risk_adj_max_loss_pct': '0.1',
            # 全新动态仓位参数
            'ORIGINAL_MAX_POSITIONS': '5',
            'MIN_POSITIONS_COUNT': '1',
            'RISK_ADJ_POS_FLOOR_PCT': '0.2',
            'RISK_ADJ_CAPITAL_FLOOR_PCT': '0.5',
        }
      
        db_params = {p.param_name: p.param_value for p in StrategyParameters.objects.all()}
      
        for key, default_value in required_params.items():
            value = db_params.get(key, Decimal(str(default_value)))
            if key in ['ORIGINAL_MAX_POSITIONS', 'MIN_POSITIONS_COUNT', 'lookback_atr']:
                params[key] = int(value)
            else:
                params[key] = Decimal(str(value))
        return params

    # --- 暴露给外部调度的核心函数 ---

    def adjust_trading_plan_daily(self):
        """
        函数一：执行每日交易预案再调整 (逻辑不变)。
        """
        logger.debug(f"开始执行 {self.execution_date} 的交易预案二次筛选...")
        relevant_plan_date = self._find_relevant_plan_date()
        if not relevant_plan_date:
            msg = f"在 {self.execution_date} 及之前 {self.MAX_PLAN_LOOKBACK_DAYS} 天内没有找到任何待执行的交易预案。"
            logger.debug(msg)
            self._log_to_db('WARNING', msg)
            return
        plans_today = DailyTradingPlan.objects.filter(
            plan_date=relevant_plan_date,
            status=DailyTradingPlan.StatusChoices.PENDING
        ).order_by('rank')

        if not plans_today.exists():
            msg = f"在 {self.execution_date} 没有找到待执行的交易预案。"
            logger.debug(msg)
            self._log_to_db('WARNING', msg)
            return

        plans_to_cancel = []
        for plan in plans_today:
            try:
                open_price = self.handler.get_opening_price(plan.stock_code_id)
                if open_price <= 0:
                    logger.warning(f"股票 {plan.stock_code_id} 开盘价为0或无效，视为不符合条件。")
                    plan.status = DailyTradingPlan.StatusChoices.CANCELLED
                    plans_to_cancel.append(plan)
                    continue

                if not (plan.miop <= open_price <= plan.maop):
                    msg = (f"预案 {plan.stock_code_id} (Rank:{plan.rank}) 开盘价 {open_price} "
                           f"不在区间 [{plan.miop}, {plan.maop}] 内，已作废。")
                    logger.debug(msg)
                    plan.status = DailyTradingPlan.StatusChoices.CANCELLED
                    plans_to_cancel.append(plan)

            except Exception as e:
                msg = f"获取 {plan.stock_code_id} 开盘价时发生错误: {e}，该预案作废。"
                logger.error(msg)
                self._log_to_db('ERROR', msg)
                plan.status = DailyTradingPlan.StatusChoices.CANCELLED
                plans_to_cancel.append(plan)

        if plans_to_cancel:
            with transaction.atomic():
                DailyTradingPlan.objects.bulk_update(plans_to_cancel, ['status'])
            logger.debug(f"成功作废 {len(plans_to_cancel)} 条不符合开盘条件的交易预案。")
        else:
            logger.debug("所有待执行预案均符合开盘价条件。")

    def execute_orders(self):
        """
        函数二：进行下单 (逻辑不变)。
        """
        logger.debug(f"开始执行 {self.execution_date} 的下单流程...")

        open_positions_count = Position.objects.filter(status=Position.StatusChoices.OPEN).count()
        # 使用动态计算的当日最大持仓数
        remaining_slots = self.current_max_positions - open_positions_count

        if remaining_slots <= 0:
            msg = f"当前持仓数 {open_positions_count} 已达或超过当日动态上限 {self.current_max_positions}，不进行买入。"
            logger.debug(msg)
            self._log_to_db('WARNING', msg)
            return

        relevant_plan_date = self._find_relevant_plan_date()
        if not relevant_plan_date:
            msg = f"在 {self.execution_date} 及之前 {self.MAX_PLAN_LOOKBACK_DAYS} 天内没有找到任何待执行的交易预案可供下单。"
            logger.debug(msg)
            self._log_to_db('INFO', msg)
            return

        candidates = DailyTradingPlan.objects.filter(
            plan_date=relevant_plan_date,
            status=DailyTradingPlan.StatusChoices.PENDING
        ).order_by('rank')
 
        if not candidates.exists():
            msg = f"在 {self.execution_date} 无符合条件的买入标的。"
            logger.debug(msg)
            self._log_to_db('INFO', msg)
            return

        for candidate in candidates:
            try:
                stock_code = candidate.stock_code_id
                open_price = self.handler.get_opening_price(stock_code)
              
                k_slip = self.params['k_slip']
                limit_price = (open_price * (Decimal('1.0') + k_slip)).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
 
                # 获取下单时最终的名义本金
                available_balance = self.handler.get_available_balance()
                
                # self.final_nominal_principal 是已按M(t)调整过的值
                # 再结合硬性风控和流动性约束
                nominal_principal = min(
                    self.final_nominal_principal, 
                    self.params['MAX_CAPITAL_PER_POSITION'], 
                    available_balance
                )
                nominal_principal=nominal_principal*min(Decimal('1.0'),Decimal(2.0)*max(Decimal('0.0'),candidate.final_score))
                logger.debug(f"标的 {stock_code}: 动态调整后本金={self.final_nominal_principal:.2f}, "
                             f"单仓上限={self.params['MAX_CAPITAL_PER_POSITION']:.2f}, "
                             f"可用现金={available_balance:.2f}. "
                             f"选股评分={available_balance:.2f}. "
                             f"最终名义本金={nominal_principal:.2f}")
 
                if limit_price <= 0:
                    logger.debug(f"标的 {stock_code}: 计算出的下单限价无效（{limit_price}），跳过。")
                    continue
 
                shares_to_buy = int(nominal_principal / limit_price)
                quantity = (shares_to_buy // 100) * 100
 
                if quantity < 100:
                    msg = (f"标的 {stock_code}: 计算出的名义本金 {nominal_principal:.2f} 不足以购买一手（100股）。")
                    logger.warning(msg)
                    self._log_to_db('WARNING', msg)
                    continue
 
                msg = (f"确定唯一买入标的: {candidate.stock_code.stock_name}({stock_code}) (Rank:{candidate.rank})。 "
                       f"计划以限价 {limit_price} 买入 {quantity} 股。")
                logger.info(msg)
                self._log_to_db('INFO', msg)
              
                self.handler.place_buy_order(stock_code, limit_price, quantity)
              
                candidate.status = DailyTradingPlan.StatusChoices.EXECUTED
                candidate.save()
 
                return
 
            except Exception as e:
                msg = f"处理候选股 {candidate.stock_code_id} 时发生严重错误: {e}"
                logger.error(msg, exc_info=True)
                self._log_to_db('CRITICAL', msg)
                continue
 
        logger.debug(f"已尝试所有 {len(candidates)} 个候选标的，均未成功买入。")

    def calculate_stop_profit_loss(self, trade_id: int):
        """
        函数三：止盈止损区间计算 (V2.0 重构版)。
        在订单成交后，为新持仓计算并更新由M(t)驱动的动态止盈止损价。
 
        :param trade_id: 已成交的买入交易在 tb_trade_log 中的唯一ID。
        """
        logger.debug(f"开始为 trade_id={trade_id} 计算动态止盈止损区间...")
        try:
            with transaction.atomic():
                # 1. 获取交易和持仓信息
                trade_log = TradeLog.objects.select_for_update().get(
                    trade_id=trade_id,
                    trade_type=TradeLog.TradeTypeChoices.BUY,
                    status=TradeLog.StatusChoices.FILLED
                )
                position = Position.objects.select_for_update().get(pk=trade_log.position_id)
 
                if position.current_stop_loss > 0 and position.current_take_profit > 0:
                    logger.warning(f"Position ID {position.position_id} 似乎已计算过止盈止损，将跳过。")
                    return
 
                stock_code = trade_log.stock_code_id
                aep = trade_log.price
                buy_date = trade_log.trade_datetime.date()
                t_minus_1_date = DailyQuotes.objects.filter(trade_date__lt=buy_date).latest('trade_date').trade_date
              
                # 2. 获取计算所需的核心数据：M(t) 和 ATR
                # 2.1 获取 T-1 日的市场状态 M(t)
                try:
                    m_value_record = DailyFactorValues.objects.get(
                        stock_code_id=MARKET_INDICATOR_CODE,
                        trade_date=t_minus_1_date,
                        factor_code_id='dynamic_M_VALUE'
                    )
                    market_regime_M = m_value_record.raw_value
                except DailyFactorValues.DoesNotExist:
                    logger.error(f"无法找到 {t_minus_1_date} 的市场状态M(t)值！将使用中性值0.0进行计算。")
                    market_regime_M = Decimal('0.0')

                # 2.2 获取计算 ATR 所需的历史行情
                lookback_days = self.params['lookback_atr'] + 50 # 增加buffer
                start_date_for_calc = t_minus_1_date - timedelta(days=lookback_days * 2)
 
                quotes_qs = DailyQuotes.objects.filter(
                    stock_code_id=stock_code,
                    trade_date__gte=start_date_for_calc,
                    trade_date__lte=t_minus_1_date
                ).order_by('trade_date')
 
                if len(quotes_qs) < self.params['lookback_atr']:
                    raise ValueError(f"股票 {stock_code} 在 {t_minus_1_date} 前的历史数据不足，无法计算ATR。")
 
                df = pd.DataFrame.from_records(quotes_qs.values('high', 'low', 'close'))
                df = df.astype(float)
 
                atr_series = ta.atr(df['high'], df['low'], df['close'], length=self.params['lookback_atr'])
                atr_14_buy = Decimal(str(atr_series.iloc[-1])) if not atr_series.empty else Decimal('0.0')

                # 3. 计算动态止盈价 g_new(y)
                tp_min = self.params['risk_adj_tp_pct_min']
                tp_max = self.params['risk_adj_tp_pct_max']
                tp_pct = tp_min + (tp_max - tp_min) * (market_regime_M + 1) / 2
                take_profit_price = aep * (1 + tp_pct)

                # 4. 计算自适应止损价 h_new(z)
                # 4.1 计算动态ATR乘数 k_h(M(t))
                kh_min = self.params['risk_adj_sl_atr_min']
                kh_max = self.params['risk_adj_sl_atr_max']
                k_h_dynamic = kh_min + (kh_max - kh_min) * (market_regime_M + 1) / 2
                
                # 4.2 计算动态波动止损线
                z1_dynamic_atr = aep - k_h_dynamic * atr_14_buy

                # 4.3 计算绝对最大亏损底线
                z2_max_loss = aep * (1 - self.params['risk_adj_max_loss_pct'])
              
                # 4.4 取最严格的止损位（价格最高者），但是止损率不能低于0.5%
                stop_loss_price =min(aep *Decimal('0.995'),max(z1_dynamic_atr, z2_max_loss))
              
                logger.debug(f"[{stock_code}] 止损线比较 (基于M(t)={market_regime_M:.4f}): "
                            f"动态ATR止损(乘数{k_h_dynamic:.2f})={z1_dynamic_atr:.2f}, "
                            f"绝对最大亏损={z2_max_loss:.2f}")
 
                # 5. 更新持仓信息表
                position.current_take_profit = take_profit_price.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
                position.current_stop_loss = stop_loss_price.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
                
                # 最终校验，防止出现极端情况
                if position.current_stop_loss >= position.current_take_profit:
                    logger.critical(f"严重逻辑错误！计算后止损价({position.current_stop_loss})仍高于或等于止盈价({position.current_take_profit})。将使用最大亏损底线作为止损。")
                    position.current_stop_loss = z2_max_loss.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)

                position.save(update_fields=['current_take_profit', 'current_stop_loss'])
                loss_pct = (aep - position.current_stop_loss) / aep if aep > 0 else Decimal('0.0')
                msg = (f"成功计算并更新 Position ID {position.position_id} ({stock_code}) 的动态风控价格: "
                       f"购入价={aep:.2f}, 止盈价={position.current_take_profit:.2f} (目标收益率 {tp_pct:.2%}), "
                       f"止损价={position.current_stop_loss:.2f} (最大容忍亏损 {loss_pct:.2%})")
                logger.info(msg)
                self._log_to_db('INFO', msg)
 
        except TradeLog.DoesNotExist:
            logger.error(f"Trade ID {trade_id} 不存在或不满足计算条件（非买入/未成交）。")
        except Position.DoesNotExist:
            logger.error(f"与 Trade ID {trade_id} 关联的 Position 不存在。")
        except Exception as e:
            msg = f"为 Trade ID {trade_id} 计算动态止盈止损时发生严重错误: {e}"
            logger.critical(msg, exc_info=True)
            self._log_to_db('CRITICAL', msg)
            raise

    # --- 工具函数 ---

    @staticmethod
    def initialize_strategy_parameters():
        """
        工具函数：初始化本模块所需的策略参数到数据库。
        这是一个幂等操作，可以安全地重复运行。
        """
        logger.info("开始初始化[开盘决策与下单模块-动态风险版]的策略参数...")

        params_to_define = {
            # 通用参数
            #'MAX_POSITIONS': {'value': '3', 'group': 'POSITION_MGMT', 'desc': '最大可具备的总仓位数'},
            'MAX_CAPITAL_PER_POSITION': {'value': '20000.00', 'group': 'POSITION_MGMT', 'desc': '每仓最大投入资金数(元)'},
            'k_slip': {'value': '0.002', 'group': 'ORDER_EXEC', 'desc': '下单滑点系数, 用于计算限价单价格'},
            'lookback_atr': {'value': '14', 'group': 'INDICATORS', 'desc': 'ATR计算周期'},
            
            # 新版 M(t) 驱动的动态风险参数
            'risk_adj_tp_pct_min': {'value': '0.15', 'group': 'RISK_ADJUSTED', 'desc': 'M(t)驱动-最小止盈目标百分比 (熊市)'},
            'risk_adj_tp_pct_max': {'value': '0.15', 'group': 'RISK_ADJUSTED', 'desc': 'M(t)驱动-最大止盈目标百分比 (牛市)'},
            'risk_adj_sl_atr_min': {'value': '2', 'group': 'RISK_ADJUSTED', 'desc': 'M(t)驱动-最小ATR止损乘数 (熊市)'},
            'risk_adj_sl_atr_max': {'value': '2', 'group': 'RISK_ADJUSTED', 'desc': 'M(t)驱动-最大ATR止损乘数 (牛市)'},
            'risk_adj_max_loss_pct': {'value': '0.1', 'group': 'RISK_ADJUSTED', 'desc': 'M(t)驱动-绝对最大亏损百分比'},
            # --- 全新动态仓位管理参数 ---
            'ORIGINAL_MAX_POSITIONS': {'value': '5', 'group': 'DYNAMIC_POS_MGMT', 'desc': '【动态仓位】策略基准最大持仓数'},
            'MIN_POSITIONS_COUNT': {'value': '1', 'group': 'DYNAMIC_POS_MGMT', 'desc': '【动态仓位】最小持仓数硬下限'},
            'RISK_ADJ_POS_FLOOR_PCT': {'value': '0.1', 'group': 'DYNAMIC_POS_MGMT', 'desc': '【动态仓位】总仓位数缩放因子的下限 S_min_pos (例如0.4代表最差情况持有基准的40%)'},
            'RISK_ADJ_CAPITAL_FLOOR_PCT': {'value': '0.6', 'group': 'DYNAMIC_POS_MGMT', 'desc': '【动态仓位】单位名义本金缩放因子的下限 S_min_cap (例如0.6代表最差情况投入基准的60%)'},
        
            # --- 追踪止盈参数 ---
            'trailing_tp_increment_pct': {'value': '0.02', 'group': 'TRAILING_STOP', 'desc': '追踪止盈的步进百分比'},
            'trailing_sl_buffer_pct': {'value': '0.015', 'group': 'TRAILING_STOP', 'desc': '追踪止盈的回撤缓冲百分比'},
        
        }

        with transaction.atomic():
            for name, data in params_to_define.items():
                StrategyParameters.objects.update_or_create(
                    param_name=name,
                    defaults={
                        'param_value': Decimal(data['value']),
                        'group_name': data['group'],
                        'description': data['desc']
                    }
                )
      
        logger.info(f"成功初始化/更新 {len(params_to_define)} 个动态风险策略参数。")

####文件结束####

####trade_manager\service\decision_order_service_old.py####
# trade_manager/service/decision_order_service.py

import logging
from datetime import date, timedelta
from decimal import Decimal, ROUND_HALF_UP
import pandas as pd
import pandas_ta as ta

from django.db import transaction
from django.utils import timezone

from common.models import (
    DailyTradingPlan,
    Position,
    TradeLog,
    StrategyParameters,
    DailyQuotes,
    SystemLog
)
from .trade_handler import ITradeHandler

# 配置日志记录器
logger = logging.getLogger(__name__)

class DecisionOrderService:
    """
    开盘决策与下单模块。

    该服务负责在T日开盘后的黄金时间内，根据预案、实际开盘价和账户状态，
    做出最终的买入决策，并执行下单。同时，它也提供了在订单成交后计算
    止盈止损区间的功能。
    """
    MODULE_NAME = '开盘决策与下单'

    def __init__(self, handler: ITradeHandler, execution_date: date = None):
        """
        初始化服务。

        :param handler: 一个实现了 ITradeHandler 接口的实例，用于与交易环境交互。
        :param execution_date: T日，即执行决策的日期。如果为None，则默认为当天。
                               此参数为回测模块提供了设置模拟日期的入口。
        """
        if not isinstance(handler, ITradeHandler):
            raise TypeError("传入的 handler 必须是 ITradeHandler 的一个实例。")
        
        self.handler = handler
        self.execution_date = execution_date if execution_date else date.today()
        self.params = self._load_strategy_parameters()
        
        logger.debug(f"[{self.MODULE_NAME}] 服务初始化。执行T日: {self.execution_date}")
        logger.debug(f"策略参数加载成功: {self.params}")

    def _log_to_db(self, level: str, message: str):
        """辅助方法：将日志写入数据库"""
        SystemLog.objects.create(
            log_level=level,
            module_name=self.MODULE_NAME,
            message=message
        )

    def _load_strategy_parameters(self) -> dict:
        """从数据库加载所有策略参数到内存"""
        params = {}
        # 定义需要加载的参数及其默认值，以防数据库中没有
        required_params = {
            'MAX_POSITIONS': 2,
            'MAX_CAPITAL_PER_POSITION': 25000.00,
            'k_slip': 0.002,
            'Base_Target': 0.07,
            'k_g1': 1.5,
            'Max_Target': 0.20,
            'k_h1': 2.0,
            'k_h2': 3.0,
            'Max_Loss_Percent': 0.08,
            'lookback_atr': 14,
            'lookback_adx': 14,
            'lookback_ma20': 20,
            'param_adx_threshold': 25
        }
        
        db_params = {p.param_name: p.param_value for p in StrategyParameters.objects.all()}
        
        for key, default_value in required_params.items():
            # 优先使用数据库中的值，否则使用默认值
            value = db_params.get(key, Decimal(str(default_value)))
            # 将需要整数的参数转换为int
            if key in ['MAX_POSITIONS', 'lookback_atr', 'lookback_adx', 'lookback_ma20', 'param_adx_threshold']:
                params[key] = int(value)
            else:
                params[key] = Decimal(str(value))
        return params

    # --- 暴露给外部调度的核心函数 ---

    def adjust_trading_plan_daily(self):
        """
        函数一：执行每日交易预案再调整。
        根据实际开盘价与剩余仓位进行二次筛选，关闭不会被选择的交易预案。
        """
        logger.debug(f"开始执行 {self.execution_date} 的交易预案二次筛选...")
        
        plans_today = DailyTradingPlan.objects.filter(
            plan_date=self.execution_date,
            status=DailyTradingPlan.StatusChoices.PENDING
        ).order_by('rank')

        if not plans_today.exists():
            msg = f"在 {self.execution_date} 没有找到待执行的交易预案。"
            logger.warning(msg)
            self._log_to_db('WARNING', msg)
            return

        plans_to_cancel = []
        for plan in plans_today:
            try:
                open_price = self.handler.get_opening_price(plan.stock_code)
                if open_price <= 0:
                    logger.warning(f"股票 {plan.stock_code} 开盘价为0或无效，视为不符合条件。")
                    plan.status = DailyTradingPlan.StatusChoices.CANCELLED
                    plans_to_cancel.append(plan)
                    continue

                if not (plan.miop <= open_price <= plan.maop):
                    msg = (f"预案 {plan.stock_code} (Rank:{plan.rank}) 开盘价 {open_price} "
                           f"不在区间 [{plan.miop}, {plan.maop}] 内，已作废。")
                    logger.debug(msg)
                    plan.status = DailyTradingPlan.StatusChoices.CANCELLED
                    plans_to_cancel.append(plan)

            except Exception as e:
                msg = f"获取 {plan.stock_code} 开盘价时发生错误: {e}，该预案作废。"
                logger.error(msg)
                self._log_to_db('ERROR', msg)
                plan.status = DailyTradingPlan.StatusChoices.CANCELLED
                plans_to_cancel.append(plan)

        if plans_to_cancel:
            with transaction.atomic():
                DailyTradingPlan.objects.bulk_update(plans_to_cancel, ['status'])
            logger.info(f"成功作废 {len(plans_to_cancel)} 条不符合开盘条件的交易预案。")
        else:
            logger.info("所有待执行预案均符合开盘价条件。")

    def execute_orders(self):
        """
        函数二：进行下单。
        读取预案表，选择最优标的，计算仓位和价格，并调用处理器执行下单。
        """
        logger.info(f"开始执行 {self.execution_date} 的下单流程...")

        # 1. 检查剩余仓位
        open_positions_count = Position.objects.filter(status=Position.StatusChoices.OPEN).count()
        remaining_slots = self.params['MAX_POSITIONS'] - open_positions_count

        if remaining_slots <= 0:
            msg = f"当前持仓数 {open_positions_count} 已达上限 {self.params['MAX_POSITIONS']}，今日不进行买入操作。"
            logger.warning(msg)
            self._log_to_db('WARNING', msg)
            return

        #2. 获取所有待处理的候选标的
        candidates = DailyTradingPlan.objects.filter(
            plan_date=self.execution_date,
            status=DailyTradingPlan.StatusChoices.PENDING
        ).order_by('rank')
 
        if not candidates.exists():
            msg = f"在 {self.execution_date} 无符合条件的买入标的。"
            logger.info(msg)
            self._log_to_db('INFO', msg)
            return

        # 3. 遍历所有候选标的，直到成功买入一个
        for candidate in candidates:
            try:
                stock_code = candidate.stock_code
                open_price = self.handler.get_opening_price(stock_code)
                
                # 计算下单限价
                k_slip = self.params['k_slip']
                limit_price = (open_price * (Decimal('1.0') + k_slip)).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
 
                # 计算本次交易可用资金
                available_balance = self.handler.get_available_balance()
                capital_per_slot = available_balance / Decimal(remaining_slots)
                nominal_principal = min(capital_per_slot, self.params['MAX_CAPITAL_PER_POSITION'])
 
                # 计算购入股数
                if limit_price <= 0:
                    logger.warning(f"标的 {stock_code}: 计算出的下单限价无效（{limit_price}），跳过。")
                    continue # 尝试下一个候选
 
                shares_to_buy = int(nominal_principal / limit_price)
                quantity = (shares_to_buy // 100) * 100 # 向下取整到100的倍数
 
                if quantity < 100:
                    msg = (f"标的 {stock_code}: 计算出的名义本金 {nominal_principal:.2f} 不足以购买一手（100股），"
                           f"所需金额约为 {limit_price * 100:.2f}。放弃本次交易。")
                    logger.warning(msg)
                    self._log_to_db('WARNING', msg)
                    continue # 资金不足，尝试下一个候选
 
                # 4. 执行下单
                msg = (f"确定唯一买入标的: {stock_code} (Rank:{candidate.rank})。 "
                       f"计划以限价 {limit_price} 买入 {quantity} 股。")
                logger.info(msg)
                self._log_to_db('INFO', msg)
                
                self.handler.place_buy_order(stock_code, limit_price, quantity)
                
                # 标记预案为已执行
                candidate.status = DailyTradingPlan.StatusChoices.EXECUTED
                candidate.save()
 
                # 成功买入后，立即退出函数，外层循环会决定是否继续买入下一个仓位
                return
 
            except Exception as e:
                msg = f"处理候选股 {candidate.stock_code} 时发生严重错误: {e}"
                logger.error(msg, exc_info=True)
                self._log_to_db('CRITICAL', msg)
                continue # 发生异常，继续尝试下一个候选
 
        # 如果循环正常结束，说明所有候选股都无法买入
        logger.info(f"已尝试所有 {len(candidates)} 个候选标的，均未成功买入。")

    def calculate_stop_profit_loss(self, trade_id: int):
        """
        函数三：止盈止损区间计算 (修正版)。
        在订单成交后，为新持仓计算并更新初始的止盈止损价。
 
        :param trade_id: 已成交的买入交易在 tb_trade_log 中的唯一ID。
        """
        logger.info(f"开始为 trade_id={trade_id} 计算止盈止损区间...")
        try:
            with transaction.atomic():
                # 1. 获取交易和持仓信息
                trade_log = TradeLog.objects.select_for_update().get(
                    trade_id=trade_id,
                    trade_type=TradeLog.TradeTypeChoices.BUY,
                    status=TradeLog.StatusChoices.FILLED
                )
                position = Position.objects.select_for_update().get(pk=trade_log.position_id)
 
                if position.current_stop_loss > 0:
                    logger.warning(f"Position ID {position.position_id} 似乎已计算过止盈止损，将跳过。")
                    return
 
                stock_code = trade_log.stock_code_id
                aep = trade_log.price
                buy_date = trade_log.trade_datetime.date()
                
                # 2. 获取计算所需行情数据 (避免未来函数)
                lookback_days = self.params['lookback_adx'] + 50
                start_date_for_calc = buy_date - timedelta(days=lookback_days * 2)
                end_date_for_calc = buy_date - timedelta(days=1)
 
                quotes_qs = DailyQuotes.objects.filter(
                    stock_code_id=stock_code,
                    trade_date__gte=start_date_for_calc,
                    trade_date__lte=end_date_for_calc
                ).order_by('trade_date')
 
                if len(quotes_qs) < max(self.params['lookback_atr'], self.params['lookback_adx'], self.params['lookback_ma20']):
                    raise ValueError(f"股票 {stock_code} 在 {end_date_for_calc} 前的历史数据不足，无法计算指标。")
 
                df = pd.DataFrame.from_records(quotes_qs.values('high', 'low', 'close'))
                df = df.astype(float)
 
                # 3. 计算所有必需指标
                atr_series = ta.atr(df['high'], df['low'], df['close'], length=self.params['lookback_atr'])
                atr_14_buy = Decimal(str(atr_series.iloc[-1]))
 
                ma20_series = ta.sma(df['close'], length=self.params['lookback_ma20'])
                ma20_buy = Decimal(str(ma20_series.iloc[-1]))
 
                adx_df = ta.adx(df['high'], df['low'], df['close'], length=self.params['lookback_adx'])
                adx_14_buy = Decimal(str(adx_df[f'ADX_{self.params["lookback_adx"]}'].iloc[-1]))
 
                # 4. 计算止盈价 g(y) - 逻辑不变
                profit_margin = min(
                    self.params['Base_Target'] + self.params['k_g1'] * (atr_14_buy / aep),
                    self.params['Max_Target']
                )
                take_profit_price = aep * (Decimal('1.0') + profit_margin)
 
                # 5. 计算止损价 h(z) - 严格按照需求文档逻辑
                # 5.1 根据ADX判断市场状态，选择z_final
                adx_threshold = self.params['param_adx_threshold']
                if adx_14_buy > adx_threshold:
                    # 趋势状态，使用较窄的ATR乘数
                    z_final = aep - self.params['k_h1'] * atr_14_buy
                else:
                    # 震荡状态，使用较宽的ATR乘数
                    z_final = aep - self.params['k_h2'] * atr_14_buy
 
                # 5.2 计算其他止损线
                z2_technical = ma20_buy
                z3_max_loss = aep * (Decimal('1.0') - self.params['Max_Loss_Percent'])
                
                # 5.3 取最严格的止损位（价格最高者）
                stop_loss_price = max(z_final, z2_technical, z3_max_loss)
                
                logger.info(f"[{stock_code}] 止损线比较: 趋势位={z_final:.2f}, 技术位={z2_technical:.2f}, 底线={z3_max_loss:.2f}")
 
                # 6. 更新持仓信息表
                position.current_take_profit = take_profit_price.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
                position.current_stop_loss = stop_loss_price.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
                position.save(update_fields=['current_take_profit', 'current_stop_loss'])
 
                msg = (f"成功计算并更新 Position ID {position.position_id} ({stock_code}) 的风控价格: "
                       f"购入价={aep}, 止盈价={position.current_take_profit}, 止盈率={((Decimal('1.0') + profit_margin)*100):.2f}%, 止损价={position.current_stop_loss}, 止损率={((position.current_stop_loss/aep)*100):.2f}%")
                logger.info(msg)
                self._log_to_db('INFO', msg)
 
        except TradeLog.DoesNotExist:
            logger.error(f"Trade ID {trade_id} 不存在或不满足计算条件（非买入/未成交）。")
        except Position.DoesNotExist:
            logger.error(f"与 Trade ID {trade_id} 关联的 Position 不存在。")
        except Exception as e:
            msg = f"为 Trade ID {trade_id} 计算止盈止损时发生严重错误: {e}"

    # --- 工具函数 ---

    @staticmethod
    def initialize_strategy_parameters():
        """
        工具函数：初始化本模块所需的策略参数到数据库。
        这是一个幂等操作，可以安全地重复运行。
        """
        logger.info("开始初始化[开盘决策与下单模块]的策略参数...")

        params_to_define = {
            # 仓位管理
            'MAX_POSITIONS': {'value': '2', 'group': 'POSITION_MGMT', 'desc': '最大可具备的总仓位数'},
            'MAX_CAPITAL_PER_POSITION': {'value': '25000.00', 'group': 'POSITION_MGMT', 'desc': '每仓最大投入资金数(元)'},
            # 下单参数
            'k_slip': {'value': '0.002', 'group': 'ORDER_EXEC', 'desc': '下单滑点系数, 用于计算限价单价格'},
            # 止盈参数 g(y)
            'Base_Target': {'value': '0.07', 'group': 'TAKE_PROFIT', 'desc': '基础止盈目标百分比'},
            'k_g1': {'value': '1.5', 'group': 'TAKE_PROFIT', 'desc': 'ATR溢价乘数, 用于动态调整止盈目标'},
            'Max_Target': {'value': '0.20', 'group': 'TAKE_PROFIT', 'desc': '最大止盈目标百分比上限'},
            # 止损参数 h(z)
            'k_h1': {'value': '2.0', 'group': 'STOP_LOSS', 'desc': '趋势市ATR止损乘数 (盘中动态使用)'},
            'k_h2': {'value': '3.0', 'group': 'STOP_LOSS', 'desc': '震荡市ATR止损乘数 (用于计算初始止损)'},
            'Max_Loss_Percent': {'value': '0.08', 'group': 'STOP_LOSS', 'desc': '最大回撤容忍度(绝对亏损百分比上限)'},
            # 指标周期
            'lookback_atr': {'value': '14', 'group': 'INDICATORS', 'desc': 'ATR计算周期'},
            'lookback_adx': {'value': '14', 'group': 'INDICATORS', 'desc': 'ADX计算周期'},
            'lookback_ma20': {'value': '20', 'group': 'INDICATORS', 'desc': 'MA20计算周期'},
        }

        with transaction.atomic():
            for name, data in params_to_define.items():
                StrategyParameters.objects.update_or_create(
                    param_name=name,
                    defaults={
                        'param_value': Decimal(data['value']),
                        'group_name': data['group'],
                        'description': data['desc']
                    }
                )
        
        logger.info(f"成功初始化/更新 {len(params_to_define)} 个策略参数。")


####文件结束####

####trade_manager\service\m_distribution_backtest_service.py####
# trade_manager/service/m_distribution_backtest_service.py (替换全部内容)

import logging
from datetime import date, timedelta, datetime
from decimal import Decimal

import pandas as pd
from django.db import connections, transaction
from django.core.management import call_command
from django.utils import timezone

from common.models import (
    DailyQuotes, StockInfo, CorporateAction, FactorDefinitions, StrategyParameters,
    DailyFactorValues, IndexQuotesCsi300, Position, TradeLog, DailyTradingPlan
)
from common.models.backtest_logs import MDistributionBacktestLog
from selection_manager.service.selection_service import SelectionService
from trade_manager.service.decision_order_service import DecisionOrderService
from .db_utils import use_backtest_schema
from .m_distribution_reporter import MDistributionReporter
from trade_manager.service.simulate_trade import SimulateTradeService
from trade_manager.service.simulate_trade_handler import SimulateTradeHandler
from .position_monitor_logic import PositionMonitorLogic
from common.models import Position
logger = logging.getLogger(__name__)
STRATEGIES = ['MT', 'BO', 'QD', 'MR','OLD']
class MDistributionBacktestService:
    """
    M值胜率分布回测服务 (V2 - 修正版)。
    
    核心流程:
    1. 创建独立的数据库schema进行回测，与主环境隔离。
    2. 按天循环，每天运行SelectionService生成并保存交易预案（包含策略DNA）。
    3. 从数据库读取预案，对每个预案进行“前向追溯”。
    4. 将每次模拟交易的结果记录到专用的日志表中。
    5. 回测结束后，调用报告模块生成分析报告。
    """
    
    def __init__(self, start_date: str, end_date: str, single_strategy_mode: bool = False):
        self.start_date = date.fromisoformat(start_date)
        self.end_date = date.fromisoformat(end_date)
        self.backtest_run_id = f"m_dist_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        self.max_holding_days = 90
        self.single_strategy_mode = single_strategy_mode
        self.params = {}
    def _get_next_trading_day(self, from_date: date) -> date | None: return (DailyQuotes.objects .filter(trade_date__gte=from_date) .order_by('trade_date') .values_list('trade_date', flat=True) .first())

    def _simulate_intraday_monitoring(self, position_dict: dict, daily_quote: dict) -> tuple[str, Decimal, Decimal, Decimal]:
        """
        [重写] 对单个持仓在一天内进行高保真监控模拟。
        此函数现在完全复用 PositionMonitorLogic 的逻辑。
        """
        open_p, high_p, low_p = daily_quote['open'], daily_quote['high'], daily_quote['low']
        
        # 初始化临时的、内存中的持仓状态
        temp_sl = position_dict['current_stop_loss']
        temp_tp = position_dict['current_take_profit']
        
        # 1. 开盘价检查 (黑天鹅事件)
        # 创建一个临时的、不落表的Position对象以适配接口
        temp_position_obj = Position(
            entry_price=position_dict['entry_price'],
            current_stop_loss=temp_sl,
            current_take_profit=temp_tp
        )
        decision_open = PositionMonitorLogic.check_and_decide(temp_position_obj, open_p, self.params)
        
        if decision_open['action'] == 'SELL':
            # 开盘价直接触发卖出，以开盘价成交
            exit_price = min(open_p, decision_open['exit_price']) # 取更不利的价格
            logger.debug(f"    -> 监控: 开盘价 {open_p:.2f} 触发卖出，成交价 {exit_price:.2f}")
            return 'SOLD', exit_price, temp_sl, temp_tp
        elif decision_open['action'] == 'UPDATE':
            # 开盘价触发了风控线更新
            temp_sl = decision_open['updates'].get('current_stop_loss', temp_sl)
            temp_tp = decision_open['updates'].get('current_take_profit', temp_tp)
            logger.debug(f"    -> 监控: 开盘价更新风控线. SL: {temp_sl:.2f}, TP: {temp_tp:.2f}")
        # 2. 日内循环试探 (最低价 -> 最高价)
        while True:
            action_taken_in_loop = False
            
            # 2.1 试探最低价是否触发卖出
            temp_position_obj.current_stop_loss = temp_sl
            temp_position_obj.current_take_profit = temp_tp
            decision_low = PositionMonitorLogic.check_and_decide(temp_position_obj, low_p, self.params)
            
            if decision_low['action'] == 'SELL':
                # 最低价触发卖出，以止损价成交
                logger.debug(f"    -> 监控: 最低价 {low_p:.2f} 触发卖出，成交价 {decision_low['exit_price']:.2f}")
                return 'SOLD', decision_low['exit_price'], temp_sl, temp_tp
            # 2.2 试探最高价是否触发更新
            decision_high = PositionMonitorLogic.check_and_decide(temp_position_obj, high_p, self.params)
            
            if decision_high['action'] == 'UPDATE':
                new_sl = decision_high['updates'].get('current_stop_loss', temp_sl)
                new_tp = decision_high['updates'].get('current_take_profit', temp_tp)
                
                # 只有当风控线实际发生变化时，才认为有动作发生
                if new_sl != temp_sl or new_tp != temp_tp:
                    logger.debug(f"    -> 监控: 最高价 {high_p:.2f} 触发风控线更新. SL: {new_sl:.2f}, TP: {new_tp:.2f}")
                    temp_sl, temp_tp = new_sl, new_tp
                    action_taken_in_loop = True
            # 如果本轮循环没有更新任何风控线，则说明价格波动已稳定在当前风控区间内，可以跳出循环
            if not action_taken_in_loop:
                break
        
        # 3. 如果未触发卖出，则返回持有状态和最终更新的风控线
        return 'HOLD', Decimal('0.0'), temp_sl, temp_tp
    
    def _setup_backtest_schema(self):
        """
        【最终修正版】在 Schema 中准备回测环境，并集成索引/约束优化逻辑。
        """
        logger.info(f"--- 1. 在 Schema '{self.backtest_run_id}' 中准备回测环境 (集成索引优化) ---")
        
        with connections['default'].cursor() as cursor:
            cursor.execute(f'CREATE SCHEMA IF NOT EXISTS "{self.backtest_run_id}";')
            cursor.execute(f'SET search_path TO "{self.backtest_run_id}";')
            call_command('migrate')
        logger.info("表结构创建完成。")
        tables_to_copy = [
            StockInfo, DailyQuotes, CorporateAction, FactorDefinitions,
            StrategyParameters, DailyFactorValues, IndexQuotesCsi300
        ]
        
        logger.info(f"准备从 'public' schema 复制基础数据到 '{self.backtest_run_id}'...")
        with transaction.atomic(), connections['default'].cursor() as cursor:
            # 确保后续操作都在新schema下
            cursor.execute(f'SET search_path TO "{self.backtest_run_id}";')
            
            for model in tables_to_copy:
                table_name = model._meta.db_table
                logger.info(f"  - 正在处理表: {table_name}")
                
                # =========================================================================
                # 1. 获取并暂存索引和约束的定义
                # =========================================================================
                # 1a. 获取普通索引 (不包括由UNIQUE或PRIMARY KEY约束创建的索引)
                cursor.execute("""
                    SELECT indexdef
                    FROM pg_indexes
                    WHERE schemaname = %s AND tablename = %s
                    AND indexname NOT IN (
                        SELECT conname FROM pg_constraint WHERE conrelid = %s::regclass
                    );
                """, [self.backtest_run_id, table_name, f'"{self.backtest_run_id}"."{table_name}"'])
                plain_indexes_to_recreate = [row[0] for row in cursor.fetchall()]
                # 1b. 获取约束 (外键、唯一、主键等)
                cursor.execute("""
                    SELECT 'ALTER TABLE ' || quote_ident(conrelid::regclass::text) || ' ADD CONSTRAINT ' || quote_ident(conname) || ' ' || pg_get_constraintdef(oid)
                    FROM pg_constraint
                    WHERE conrelid = %s::regclass;
                """, [f'"{self.backtest_run_id}"."{table_name}"'])
                constraints_to_recreate = [row[0] for row in cursor.fetchall()]
                
                # =========================================================================
                # 2. 删除所有约束和索引以极大地加速数据插入
                # =========================================================================
                for const_def in constraints_to_recreate:
                    const_name = const_def.split('ADD CONSTRAINT ')[1].split(' ')[0]
                    logger.debug(f"      - 删除约束: {const_name}")
                    cursor.execute(f'ALTER TABLE "{table_name}" DROP CONSTRAINT IF EXISTS {const_name} CASCADE;')
                for index_def in plain_indexes_to_recreate:
                    try:
                        index_name = index_def.split(' ')[2]
                        logger.debug(f"      - 删除索引: {index_name}")
                        cursor.execute(f'DROP INDEX IF EXISTS "{index_name}";')
                    except IndexError:
                        logger.warning(f"无法从 '{index_def}' 解析索引名称，跳过删除。")
                # =========================================================================
                # 3. 高效复制数据
                # =========================================================================
                logger.info(f"    - 正在从 public.{table_name} 复制数据...")
                sql = f'INSERT INTO "{table_name}" SELECT * FROM public."{table_name}";'
                cursor.execute(sql)
                logger.info(f"    - 数据复制完成。")
                # =========================================================================
                # 4. 重建索引和约束
                # =========================================================================
                logger.info(f"    - 正在重建 '{table_name}' 的索引和约束...")
                # 4a. 重建普通索引
                for index_def in plain_indexes_to_recreate:
                    logger.debug(f"      - 重建索引: {index_def}")
                    cursor.execute(index_def)
                
                # 4b. 重建约束 (这会自动重建它们的底层索引)
                #     注意：主键约束必须最先重建
                constraints_to_recreate.sort(key=lambda x: 'PRIMARY KEY' not in x)
                for const_def in constraints_to_recreate:
                    logger.debug(f"      - 重建约束: {const_def}")
                    cursor.execute(const_def)
                # =========================================================================
                # 5. 重置自增主键序列 (如果存在)
                # =========================================================================
                find_serial_sql = """
                    SELECT a.attname, pg_get_serial_sequence(quote_ident(n.nspname) || '.' || quote_ident(c.relname), a.attname)
                    FROM pg_class c
                    JOIN pg_attribute a ON a.attrelid = c.oid
                    JOIN pg_namespace n ON c.relnamespace = n.oid
                    WHERE n.nspname = %s AND c.relname = %s AND a.attnum > 0 AND NOT a.attisdropped
                    AND pg_get_serial_sequence(quote_ident(n.nspname) || '.' || quote_ident(c.relname), a.attname) IS NOT NULL;
                """
                cursor.execute(find_serial_sql, [self.backtest_run_id, table_name])
                serial_columns = cursor.fetchall()
                for column_name, sequence_name in serial_columns:
                    if sequence_name:
                        logger.info(f"    - 发现自增列 '{column_name}'，正在重置其序列 '{sequence_name}'...")
                        update_sequence_sql = f"""
                            SELECT setval('{sequence_name}', COALESCE((SELECT MAX("{column_name}") FROM "{table_name}"), 0) + 1, false);
                        """
                        cursor.execute(update_sequence_sql)
        
        logger.info("基础数据复制完成，并已完成索引优化。")
    def _load_parameters(self):
        """
        [新增] 在回测开始前加载所有需要的策略参数。
        参考 simulate_trade.py 的实现。
        """
        logger.info("加载回测所需策略参数...")
        # 从 StrategyParameters 表中一次性加载所有参数
        all_params = {p.param_name: p.param_value for p in StrategyParameters.objects.all()}
        
        # 定义 PositionMonitorLogic 中可能用到的参数及其默认值
        required_params = {
            'trailing_tp_increment_pct': '0.02',
            'trailing_sl_buffer_pct': '0.015',
            # 这里可以添加其他未来可能用到的参数
        }
        for key, default_value in required_params.items():
            # 优先使用数据库的值，否则使用默认值
            self.params[key] = all_params.get(key, Decimal(default_value))
        
        logger.info(f"策略参数加载完成: {self.params}")
    def run(self):
        try:
            with use_backtest_schema(self.backtest_run_id):
                self._setup_backtest_schema()
                self._load_parameters()
                trading_days = list(DailyQuotes.objects.filter(
                    trade_date__gte=self.start_date,
                    trade_date__lte=self.end_date
                ).values_list('trade_date', flat=True).distinct().order_by('trade_date'))
                # --- [修正版] 低内存滚动窗口数据加载逻辑 ---
                logger.info("--- [滚动窗口] 开始准备数据 ---")
                lookback_window_size = 250
                extra_buffer_days = 20
                
                preload_start_date = trading_days[0] - timedelta(days=lookback_window_size + extra_buffer_days)
                
                logger.info(f"一次性查询数据库，时间窗口: {preload_start_date} to {self.end_date}")
                
                quotes_iterator = DailyQuotes.objects.filter(
                    trade_date__gte=preload_start_date,
                    trade_date__lte=self.end_date
                ).order_by('trade_date', 'stock_code_id').values(
                    'trade_date', 'stock_code_id', 'open', 'high', 'low', 'close', 'volume', 'turnover', 'hfq_close'
                ).iterator(chunk_size=20000)
                quotes_by_date = {}
                for row in quotes_iterator:
                    trade_date = row['trade_date']
                    if trade_date not in quotes_by_date:
                        quotes_by_date[trade_date] = []
                    quotes_by_date[trade_date].append(row)
                
                logger.info("初始化第一个滚动窗口面板...")
                all_loaded_dates = sorted(quotes_by_date.keys())
                first_backtest_day = trading_days[0]
                initial_window_dates = [d for d in all_loaded_dates if d <= first_backtest_day]
                initial_rows = [row for d in initial_window_dates for row in quotes_by_date.get(d, [])]
                
                if not initial_rows:
                    raise ValueError("初始化滚动窗口失败，没有获取到任何数据。")
                df_window = pd.DataFrame(initial_rows)
                df_window['trade_date'] = pd.to_datetime(df_window['trade_date'])
                
                rolling_panels = {}
                for col in ['open', 'high', 'low', 'close', 'volume', 'turnover', 'hfq_close']:
                    panel = df_window.pivot(index='trade_date', columns='stock_code_id', values=col).astype(float)
                    rolling_panels[col] = panel
                
                logger.info(f"滚动窗口初始化完成。")
                logger.info(f"--- 2. 开始日度回测循环 ({len(trading_days)}天) ---")
                last_sent_month = None
                for i, t_minus_1 in enumerate(trading_days):
                    logger.info(f"\n{'='*20} 模拟预案日: {t_minus_1} ({i+1}/{len(trading_days)}) {'='*20}")
                    if i > 0:
                        new_day_data = quotes_by_date.get(t_minus_1)
                        if new_day_data:
                            logger.debug(f"滚动窗口: 移除 {rolling_panels['close'].index[0].date()}, 添加 {t_minus_1}")
                            for key in rolling_panels:
                                rolling_panels[key] = rolling_panels[key].iloc[1:]
                            
                            df_new_day = pd.DataFrame(new_day_data)
                            df_new_day['trade_date'] = pd.to_datetime(df_new_day['trade_date'])
                            for col in ['open', 'high', 'low', 'close', 'volume', 'turnover', 'hfq_close']:
                                new_row = df_new_day.pivot(index='trade_date', columns='stock_code_id', values=col).astype(float)
                                rolling_panels[col] = pd.concat([rolling_panels[col], new_row])
                        else:
                            logger.warning(f"日期 {t_minus_1} 在预加载数据中不存在，窗口未滚动。")
                    # 1. 运行标准的M动态策略
                    logger.info(f"  Running M-Dynamic Strategy for {t_minus_1}...")
                    selection_service_dynamic = SelectionService(trade_date=t_minus_1, mode='backtest', one_strategy=None,preloaded_panels=rolling_panels)
                    selection_service_dynamic.run_selection()
                    plan_date_for_t = t_minus_1 + timedelta(days=1)
                    plans_dynamic = DailyTradingPlan.objects.filter(plan_date=plan_date_for_t)
                    if not plans_dynamic.exists():
                        logger.info(f"    在M动态策略下未生成任何交易预案。")
                    else:
                        for plan in plans_dynamic:
                            self._trace_forward_and_log(t_minus_1, plan, selection_service_dynamic.market_regime_M, one_stratage_mode=None)
                    # 2. 如果开启了单策略模式，则循环运行
                    if self.single_strategy_mode:
                        for strategy_name in STRATEGIES:
                            logger.info(f"  Running Single Strategy '{strategy_name}' for {t_minus_1}...")
                            selection_service_single = SelectionService(trade_date=t_minus_1, mode='backtest', one_strategy=strategy_name,preloaded_panels=rolling_panels)
                            selection_service_single.run_selection()
                            
                            # 注意：run_selection会覆盖旧预案，所以需要重新查询
                            plans_single = DailyTradingPlan.objects.filter(plan_date=plan_date_for_t)
                            if not plans_single.exists():
                                logger.info(f"    在单策略 {strategy_name} 下未生成任何交易预案。")
                                continue
                            
                            for plan in plans_single:
                                self._trace_forward_and_log(t_minus_1, plan, selection_service_single.market_regime_M, one_stratage_mode=strategy_name)
                    # --- 邮件发送逻辑 ---
                    is_last_day = (i == len(trading_days) - 1)
                    current_month = t_minus_1.month
                    send_mail_flag = False

                    if is_last_day:
                        send_mail_flag = True
                        logger.info("回测结束，触发最终邮件报告。")
                    elif last_sent_month is not None and current_month != last_sent_month:
                        send_mail_flag = True
                        logger.info(f"月份从 {last_sent_month} 变为 {current_month}，触发月度邮件报告。")
                    
                    if send_mail_flag:
                        reporter = MDistributionReporter(self.backtest_run_id,f"{self.start_date}至{t_minus_1}")
                        reporter.generate_and_send_report()
                    
                    last_sent_month = current_month
                    # --- 邮件发送逻辑结束 ---


        except Exception as e:
            logger.critical(f"M值分布回测过程中发生严重错误: {e}", exc_info=True)
        finally:
            # 清理schema（可以暂时注释掉以便调试）
            # with connections['default'].cursor() as cursor:
            #     cursor.execute(f'DROP SCHEMA IF EXISTS "{self.backtest_run_id}" CASCADE;')
            # logger.info(f"已清理回测环境 Schema: {self.backtest_run_id}")
            pass

    def _trace_forward_and_log(self, t_minus_1: date, plan_obj: DailyTradingPlan, m_value: float, one_stratage_mode: str = None):
        """对单个预案 (数据库对象) 进行前向追溯并记录结果"""
        stock_code = plan_obj.stock_code_id
        logger.debug(f"  -> 开始追溯股票: {stock_code}")
        actual_entry_date = self._get_next_trading_day(plan_obj.plan_date)
        if not actual_entry_date:
            logger.warning(f"    从 {plan_obj.plan_date} 起未找到后续交易日，跳过 {stock_code}。")
            return
        try:
            entry_day_quote = DailyQuotes.objects.get(stock_code_id=stock_code, trade_date=actual_entry_date)
            entry_date = actual_entry_date
            entry_price = entry_day_quote.open
        except DailyQuotes.DoesNotExist:
            logger.warning(f"    无法在 {actual_entry_date} 找到 {stock_code} 的行情数据，跳过。")
            return
        try:
            if entry_price<plan_obj.miop or entry_price>plan_obj.maop:
                logger.debug(f"{stock_code}该股票不在开盘区间跳过此股票。")
                return
            tp_price, sl_price, tp_rate, sl_rate = self._get_simulated_stop_profit_loss(stock_code, entry_date, entry_price)
        except ValueError as e:
            logger.warning(f"    无法为 {stock_code} 计算止盈止损: {e}，跳过此股票。")
            return
        # 初始化内存中的持仓状态
        position_state = {
            'entry_price': entry_price,
            'current_stop_loss': sl_price,
            'current_take_profit': tp_price,
        }
        future_quotes_qs = DailyQuotes.objects.filter(
            stock_code_id=stock_code,
            trade_date__gt=entry_date
        ).order_by('trade_date').values('trade_date', 'open', 'high', 'low', 'close')[:self.max_holding_days]
        
        future_quotes = list(future_quotes_qs)
        if not future_quotes:
            logger.warning(f"    {stock_code} 在入场后无后续行情数据，无法追溯。")
            return

        exit_info = None
        for i, quote_dict in enumerate(future_quotes):
            status, exit_price, new_sl, new_tp = self._simulate_intraday_monitoring(position_state, quote_dict)
        
            if status == 'SOLD':
                final_reason = 'TAKE_PROFIT' if exit_price >= entry_price else 'STOP_LOSS'
                exit_info = {'date': quote_dict['trade_date'], 'price': exit_price, 'reason': final_reason, 'period': i + 1}
                break
            else: # HOLD
                position_state['current_stop_loss'] = new_sl
                position_state['current_take_profit'] = new_tp
            
        
        if not exit_info:
            last_quote = future_quotes[-1]
            exit_info = {'date': last_quote['trade_date'], 'price': last_quote['close'], 'reason': 'END_OF_PERIOD', 'period': len(future_quotes)}
        
        actual_return = (exit_info['price'] / entry_price) - 1 if entry_price > 0 else 0

        MDistributionBacktestLog.objects.create(
            backtest_run_id=self.backtest_run_id,
            plan_date=t_minus_1,
            stock_code=stock_code,
            stock_name=plan_obj.stock_code.stock_name,
            m_value_at_plan=Decimal(str(m_value)),
            strategy_dna=plan_obj.strategy_dna,
            entry_date=entry_date,
            entry_price=entry_price,
            exit_date=exit_info['date'],
            exit_price=exit_info['price'],
            exit_reason=exit_info['reason'],
            holding_period=exit_info['period'],
            preset_take_profit_rate=tp_rate,
            preset_stop_loss_rate=sl_rate,
            actual_return_rate=actual_return,
            one_stratage_mode=one_stratage_mode
        )
        logger.info(f"    [记录成功] {stock_code}: 入场 {entry_date}@{entry_price:.2f}, 出场 {exit_info['date']}@{exit_info['price']:.2f}, 原因: {exit_info['reason']}")

    def _get_simulated_stop_profit_loss(self, stock_code: str, entry_date: date, entry_price: Decimal):
        """复用DecisionOrderService逻辑计算止盈止损，但不实际修改数据库"""
        tp_price, sl_price, tp_rate, sl_rate = (Decimal(0), Decimal(0), Decimal(0), Decimal(0))
        simulated_trade_time = timezone.make_aware(datetime.combine(entry_date, datetime.min.time()))
        with transaction.atomic():
            temp_position = Position.objects.create(
                stock_code_id=stock_code, entry_price=entry_price, quantity=100,
                entry_datetime=simulated_trade_time, status=Position.StatusChoices.OPEN,
                current_stop_loss=Decimal('0.00'),
                current_take_profit=Decimal('0.00')
            )
            temp_trade_log = TradeLog.objects.create(
                position=temp_position, stock_code_id=stock_code, trade_datetime=simulated_trade_time,
                trade_type=TradeLog.TradeTypeChoices.BUY, status=TradeLog.StatusChoices.FILLED,
                price=entry_price, quantity=100,
                commission=0,
                stamp_duty=0
            )
            dummy_sim_service = SimulateTradeService()
            dummy_handler = SimulateTradeHandler(dummy_sim_service)
            decision_service = DecisionOrderService(handler=dummy_handler, execution_date=entry_date)
            decision_service.calculate_stop_profit_loss(trade_id=temp_trade_log.trade_id)

            temp_position.refresh_from_db()
            tp_price = temp_position.current_take_profit
            sl_price = temp_position.current_stop_loss
            
            if entry_price > 0:
                tp_rate = (tp_price / entry_price) - 1
                sl_rate = 1 - (sl_price / entry_price)

            transaction.set_rollback(True)
            
        if tp_price == 0 or sl_price == 0:
            raise ValueError("计算出的止盈止损价无效")
            
        return tp_price, sl_price, tp_rate, sl_rate


####文件结束####

####trade_manager\service\m_distribution_reporter.py####
# trade_manager/service/m_distribution_reporter.py (替换整个文件)

import logging
import base64
import io
from decimal import Decimal
import pandas as pd
import numpy as np
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from datetime import date, timedelta,datetime
from django.db.models import Q

from common.models.backtest_logs import MDistributionBacktestLog
from data_manager.service.email_handler import EmailHandler

logger = logging.getLogger(__name__)

class MDistributionReporter:
    """
    M值胜率分布回测的报告生成与发送器 (V2 - 多策略对比版)。
    """
    def __init__(self, backtest_run_id: str, date_range_text: str):
        self.backtest_run_id = backtest_run_id
        self.date_range_text = date_range_text
        self.email_handler = EmailHandler()
        self.recipients = ['876858298@qq.com']

    def _fetch_data_for_strategy(self, query_filter: Q) -> pd.DataFrame:
        """从数据库获取指定策略的回测结果"""
        base_query = MDistributionBacktestLog.objects.filter(
            backtest_run_id=self.backtest_run_id
        ).exclude(
            exit_reason=MDistributionBacktestLog.ExitReason.END_OF_PERIOD
        )
        
        logs = base_query.filter(query_filter)
        
        if not logs.exists():
            return pd.DataFrame()
        
        return pd.DataFrame.from_records(logs.values())

    def _analyze_data(self, df: pd.DataFrame) -> pd.DataFrame:
        """对单个策略的数据进行分箱和统计分析"""
        if df.empty:
            return pd.DataFrame()

        bins = np.arange(-1.0, 1.1, 0.1)
        labels = [f"{i:.1f} to {i+0.1:.1f}" for i in bins[:-1]]
        
        df['m_interval'] = pd.cut(df['m_value_at_plan'].astype(float), bins=bins, labels=labels, right=False)

        def agg_func(group):
            total_trades = len(group)
            if total_trades == 0:
                return pd.Series({
                    'total_trades': 0, 'win_rate': 0, 'expected_return': 0
                })
            
            win_trades = (group['exit_reason'] == 'TAKE_PROFIT').sum()
            win_rate = win_trades / total_trades
            
            avg_tp_rate = np.nan_to_num(group[group['exit_reason'] == 'TAKE_PROFIT']['preset_take_profit_rate'].astype(float).mean())
            avg_sl_rate = np.nan_to_num(group[group['exit_reason'] == 'STOP_LOSS']['preset_stop_loss_rate'].astype(float).mean())
            
            expected_return = (win_rate * avg_tp_rate - (1 - win_rate) * avg_sl_rate)
            
            return pd.Series({
                'total_trades': total_trades,
                'win_rate': win_rate,
                'expected_return': expected_return
            })

        analysis_df = df.groupby('m_interval', observed=True).apply(agg_func, include_groups=False).reset_index()
        return analysis_df

    def _generate_combined_plots_base64(self, all_analysis_results: dict) -> tuple[str, str]:
        """生成包含多条曲线的组合图表"""
        if not all_analysis_results:
            return "", ""

        try:
            plt.rcParams['font.sans-serif'] = ['SimHei', 'Microsoft YaHei']
            plt.rcParams['axes.unicode_minus'] = False
        except Exception:
            pass

        # 胜率组合图
        fig_win, ax_win = plt.subplots(figsize=(14, 7))
        for name, df in all_analysis_results.items():
            if not df.empty:
                ax_win.plot(df['m_interval'], df['win_rate'], marker='o', linestyle='-', label=name)
        
        ax_win.set_title('各策略胜率 vs M值', fontsize=16)
        ax_win.set_xlabel('M值区间', fontsize=12)
        ax_win.set_ylabel('胜率', fontsize=12)
        ax_win.yaxis.set_major_formatter(plt.FuncFormatter('{:.0%}'.format))
        ax_win.grid(True, linestyle='--', alpha=0.6)
        ax_win.legend()
        plt.setp(ax_win.get_xticklabels(), rotation=45, ha="right")
        plt.tight_layout()
        buf_win = io.BytesIO()
        fig_win.savefig(buf_win, format='png', dpi=120)
        win_rate_b64 = base64.b64encode(buf_win.getvalue()).decode('utf-8')
        plt.close(fig_win)

        # 期望收益组合图
        fig_exp, ax_exp = plt.subplots(figsize=(14, 7))
        for name, df in all_analysis_results.items():
            if not df.empty:
                ax_exp.plot(df['m_interval'], df['expected_return'], marker='s', linestyle='--', label=name)

        ax_exp.set_title('各策略期望收益率 vs M值', fontsize=16)
        ax_exp.set_xlabel('M值区间', fontsize=12)
        ax_exp.set_ylabel('期望收益率', fontsize=12)
        ax_exp.yaxis.set_major_formatter(plt.FuncFormatter('{:.2%}'.format))
        ax_exp.axhline(0, color='grey', linestyle=':', linewidth=1)
        ax_exp.grid(True, linestyle='--', alpha=0.6)
        ax_exp.legend()
        plt.setp(ax_exp.get_xticklabels(), rotation=45, ha="right")
        plt.tight_layout()
        buf_exp = io.BytesIO()
        fig_exp.savefig(buf_exp, format='png', dpi=120)
        exp_return_b64 = base64.b64encode(buf_exp.getvalue()).decode('utf-8')
        plt.close(fig_exp)

        return win_rate_b64, exp_return_b64

    def _format_html_content(self, all_analysis_results: dict, plot1_b64: str, plot2_b64: str) -> str:
        """将所有内容整合成HTML邮件"""
        
        # --- 生成所有表格 ---
        tables_html = ""
        for name, df in all_analysis_results.items():
            tables_html += f"<h2>{name} - 详细数据统计</h2>"
            if df.empty:
                tables_html += "<p>该策略无有效交易数据。</p>"
                continue

            df_display = df.copy()
            df_display['win_rate'] = df_display['win_rate'].apply(lambda x: f"{x:.2%}")
            df_display['expected_return'] = df_display['expected_return'].apply(lambda x: f"{x:.2%}")
            df_display.rename(columns={
                'm_interval': 'M值区间',
                'total_trades': '总交易数',
                'win_rate': '胜率',
                'expected_return': '期望收益率',
            }, inplace=True)
            
            tables_html += df_display.to_html(index=False, classes='styled-table', border=0)

        # --- 最终HTML模板 ---
        html = f"""
        <!DOCTYPE html>
        <html lang="zh-CN">
        <head>
            <meta charset="UTF-8">
            <title>M值胜率分布回测报告</title>
            <style>
                body {{ font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif; margin: 20px; background-color: #f8f9fa; }}
                h1, h2 {{ color: #0056b3; border-bottom: 2px solid #e9ecef; padding-bottom: 8px; }}
                .styled-table {{ border-collapse: collapse; margin: 25px 0; font-size: 0.9em; min-width: 600px; box-shadow: 0 0 20px rgba(0, 0, 0, 0.1); }}
                .styled-table thead tr {{ background-color: #007bff; color: #ffffff; text-align: left; }}
                .styled-table th, .styled-table td {{ padding: 12px 15px; }}
                .styled-table tbody tr {{ border-bottom: 1px solid #dddddd; }}
                .styled-table tbody tr:nth-of-type(even) {{ background-color: #f3f3f3; }}
                .plot-container {{ text-align: center; margin-top: 20px; padding: 20px; background-color: #fff; border-radius: 8px; box-shadow: 0 0 20px rgba(0, 0, 0, 0.1); }}
                img {{ max-width: 100%; height: auto; }}
            </style>
        </head>
        <body>
            <h1>M值胜率分布回测报告</h1>
            <h2>日期区间: {self.date_range_text}</h2>
            
            <h2>组合图表分析</h2>
            <div class="plot-container">
                <h3>各策略胜率 vs M值</h3>
                <img src="data:image/png;base64,{plot1_b64}" alt="Win Rate Plot">
            </div>
            <div class.plot-container">
                <h3>各策略期望收益率 vs M值</h3>
                <img src="data:image/png;base64,{plot2_b64}" alt="Expected Return Plot">
            </div>
            
            {tables_html}
        </body>
        </html>
        """
        return html

    def generate_and_send_report(self):
        """生成并发送报告邮件的主方法"""
        logger.info(f"[{self.backtest_run_id}] 开始生成M值分布回测报告 (多策略版)...")
        try:
            # 1. 获取策略分组
            strategy_groups_raw = MDistributionBacktestLog.objects.filter(
                backtest_run_id=self.backtest_run_id
            ).values_list('one_stratage_mode', flat=True).distinct()

            if not strategy_groups_raw:
                logger.warning(f"[{self.backtest_run_id}] 数据库中无任何日志，无法生成报告。")
                return

            # 2. 整理和排序分组
            groups_to_process = sorted(
                [g if g is not None else 'M_DYNAMIC' for g in strategy_groups_raw],
                key=lambda x: (x != 'M_DYNAMIC', x)
            )

            # 3. 循环获取数据并分析
            all_analysis_results = {}
            for strategy_key in groups_to_process:
                display_name = "M动态策略" if strategy_key == 'M_DYNAMIC' else f"单策略 - {strategy_key}"
                query_filter = Q(one_stratage_mode__isnull=True) if strategy_key == 'M_DYNAMIC' else Q(one_stratage_mode=strategy_key)
                
                strategy_df = self._fetch_data_for_strategy(query_filter)
                analysis_df = self._analyze_data(strategy_df)
                all_analysis_results[display_name] = analysis_df

            # 4. 生成图表和HTML
            plot1_b64, plot2_b64 = self._generate_combined_plots_base64(all_analysis_results)
            html_content = self._format_html_content(all_analysis_results, plot1_b64, plot2_b64)
            
            subject = f"M值胜率分布回测报告 (多策略版) - {datetime.now().strftime('%Y-%m-%d')}"
            
            self.email_handler.send_email(
                recipients=self.recipients,
                subject=subject,
                html_content=html_content
            )
            logger.info(f"[{self.backtest_run_id}] 多策略回测报告邮件已成功发送。")
        except Exception as e:
            logger.error(f"[{self.backtest_run_id}] 生成或发送多策略报告时失败: {e}", exc_info=True)

####文件结束####

####trade_manager\service\monitor_exit_service.py####
# trade_manager/service/monitor_exit_service.py

import logging
from datetime import date
from django.utils import timezone
from decimal import Decimal

# 导入项目内的模型和接口
from common.models import Position, TradeLog
from .trade_handler import ITradeHandler
from .position_monitor_logic import PositionMonitorLogic
persistent_logger = logging.getLogger(__name__)


class MonitorExitService:
    """
    3.5 - 盘中持仓监控与退出模块

    该服务负责在交易时段内，以固定频率轮询，监控所有非当日建仓的持仓。
    当持仓股票的实时价格触及预设的止盈或止损线时，调用交易处理器执行卖出操作。
    """
    MODULE_NAME = '盘中持仓监控与退出'

    def __init__(self, handler: ITradeHandler,execution_date: date = None):
        """
        初始化监控服务。

        :param handler: 一个实现了 ITradeHandler 接口的实例，用于与交易环境交互。
        """
        if not isinstance(handler, ITradeHandler):
            raise TypeError("传入的 handler 必须是 ITradeHandler 的一个实例。")
        
        self.handler = handler
        self.execution_date = execution_date if execution_date else timezone.now().date()
        # 使用特定的logger进行高频、非持久化的日志记录
        self.logger = persistent_logger

    def monitor_and_exit_positions(self):
        """
        执行一次完整的持仓监控与退出检查。
        此函数应由一个定时调度器在交易时段内（09:30:01 - 14:57:00）
        以设定的频率反复调用。
        """
        self.logger.debug(f"[{self.MODULE_NAME}] 任务开始...")

        # 1. 从持仓信息表读取出entry_datetime建仓成交时间不为今天的持仓信息
        today = timezone.now().date()
        positions_to_monitor = Position.objects.filter(
            status=Position.StatusChoices.OPEN
        ).exclude(
            entry_datetime__date=self.execution_date
        )

        if not positions_to_monitor.exists():
            self.logger.debug("当前无需要监控的隔夜持仓。")
            return

        # 2. 循环调用处理器判断是否达到了止盈止损状态
        for position in positions_to_monitor:
            try:
                # 获取实时价格
                current_price = self.handler.get_realtime_price(position.stock_code)

                if current_price is None or current_price <= 0:
                    self.logger.debug(f"无法获取 {position.stock_code} 的有效实时价格，跳过本次检查。")
                    continue
                
                self.logger.debug(
                    f"监控: {position.stock_code}, "
                    f"当前价: {current_price}, "
                    f"止损价: {position.current_stop_loss}, "
                    f"止盈价: {position.current_take_profit}"
                )

                # 调用中央决策逻辑
                decision = PositionMonitorLogic.check_and_decide(position, current_price, self.params)
                if decision['action'] == 'SELL':
                    msg = f"触发卖出! 股票: {position.stock_code_id}, 价格: {current_price:.2f}, 机制原因: {decision['reason']}"
                    persistent_logger.info(msg)
                    # 注意：实盘卖出时，成交价未知，所以reason是基于触发机制的
                    self.handler.sell_stock_by_market_price(position, decision['reason'])
                
                elif decision['action'] == 'UPDATE':
                    updates = decision['updates']
                    for field, value in updates.items():
                        setattr(position, field, value)
                    position.save(update_fields=list(updates.keys()))
                    persistent_logger.info(f"风控价格更新! 股票: {position.stock_code_id}, 更新内容: {updates}")

            except Exception as e:
                # 根据要求，卖出失败等异常只在控制台打印错误日志，等待下一次循环
                self.logger.error(
                    f"处理持仓 {position.position_id} ({position.stock_code}) 时发生错误: {e}",
                    exc_info=False # 在高频场景下，可以关闭traceback以保持日志简洁
                )
                continue
        
        self.logger.debug(f"[{self.MODULE_NAME}] 任务结束。")


####文件结束####

####trade_manager\service\position_monitor_logic.py####
# trade_manager/service/position_monitor_logic.py (新增或在monitor_exit_service.py中定义)
from decimal import Decimal
from common.models import Position, TradeLog

class PositionMonitorLogic:
    """
    持仓监控的核心决策逻辑。
    这是一个无状态的类，所有方法都是静态的，便于在任何地方调用。
    """
    @staticmethod
    def check_and_decide(position: Position, current_price: Decimal, params: dict) -> dict:
        """
        根据当前价格，对一个持仓做出决策。
        这是所有监控逻辑的唯一入口。

        :param position: 持仓对象
        :param current_price: 当前检查的价格
        :param params: 包含所需策略参数的字典
        :return: 一个包含决策的字典, e.g.,
                 {'action': 'SELL', 'reason': 'stop_loss', 'exit_price': Decimal('10.00')}
                 {'action': 'UPDATE', 'updates': {'current_stop_loss': ..., 'current_take_profit': ...}}
                 {'action': 'NONE'}
        """
        # 阶段一：止损退出检查 (最高优先级)
        if current_price <= position.current_stop_loss:
            final_reason = TradeLog.ReasonChoices.TAKE_PROFIT if position.current_stop_loss >= position.entry_price else TradeLog.ReasonChoices.STOP_LOSS
            return {
                'action': 'SELL',
                'reason': final_reason,
                'exit_price': position.current_stop_loss
            }

        # 阶段二：追踪止盈
        if current_price >= position.current_take_profit:
            if 1+1>0:
                return {
                    'action': 'SELL',
                    'reason': TradeLog.ReasonChoices.TAKE_PROFIT,
                    'exit_price': position.current_take_profit
                }
                
            change=(position.current_take_profit-max(position.current_stop_loss,position.entry_price))/Decimal(2)
            if position.current_stop_loss>position.entry_price*Decimal(1.3):
                new_sl=current_price-Decimal(0.01)
            else:
                new_sl=position.current_take_profit-change
            #new_tp = position.current_take_profit * (1 + params['trailing_tp_increment_pct'])
            new_tp=max(position.current_take_profit+change,current_price)
            #new_sl = position.current_take_profit * (1 - params['trailing_sl_buffer_pct'])

            if current_price>=new_tp:
                return {
                    'action': 'SELL',
                    'reason': TradeLog.ReasonChoices.TAKE_PROFIT,
                    'exit_price': current_price
                }
            else:
                return {
                    'action': 'UPDATE',
                    'updates': {
                        'current_take_profit': new_tp.quantize(Decimal('0.01')),
                        'current_stop_loss': new_sl.quantize(Decimal('0.01'))
                    }
                }

        # 阶段三：成本锁定
        middle=(position.current_take_profit+position.entry_price)/Decimal(2)
        if current_price>middle and position.current_stop_loss<position.entry_price and False:
            new_sl=position.entry_price*Decimal(1.01)
            return {
                        'action': 'UPDATE',
                        'updates': {'current_stop_loss': new_sl.quantize(Decimal('0.01'))}
                    }
        # if position.current_stop_loss < position.entry_price:
        #     base_price = max(position.entry_price, position.current_stop_loss)
        #     cost_lock_price = min(
        #         (base_price + position.current_take_profit) / 2,
        #         base_price * Decimal('1.012')
        #     )
        #     if current_price > cost_lock_price:
        #         new_sl = ((base_price + cost_lock_price) / 2)
        #         # 确保新的止损价不会高于当前价，避免立即触发
        #         if new_sl < current_price:
        #             return {
        #                 'action': 'UPDATE',
        #                 'updates': {'current_stop_loss': new_sl.quantize(Decimal('0.01'))}
        #             }

        return {'action': 'NONE'}

####文件结束####

####trade_manager\service\real_trade_handler.py####
# trade_manager/service/real_trade_handler.py

import logging
import json
from decimal import Decimal, ROUND_HALF_UP
from datetime import date, time, datetime, timedelta

import easytrader
import akshare as ak
from django.db import transaction
from django.utils import timezone

from .trade_handler import ITradeHandler
from common.models import Position, TradeLog, DailyQuotes
from trade_manager.service.decision_order_service import DecisionOrderService
from common.config_loader import config_loader # 使用统一的配置加载器

logger = logging.getLogger(__name__)

class ConnectionManager:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(ConnectionManager, cls).__new__(cls, *args, **kwargs)
        return cls._instance

    def __init__(self):
        if not hasattr(self, 'initialized'):
            self.user = None
            self.last_connected_date = None
            self.last_refreshed_time = None # 新增：上次刷新时间
            self.refresh_interval = timedelta(seconds=5) # 新增：刷新间隔
            self.initialized = True
            logger.info("ConnectionManager 已初始化。")

    def get_user(self):
        """获取或创建当天的 easytrader 连接，并按需刷新"""
        config = config_loader.get('easytrader')
        today = date.today()
        
        if not self.user or self.last_connected_date != today:
            logger.info("当天首次连接或连接已失效，正在重新建立 easytrader 连接...")
            try:
                self._connect(config)
                self.last_connected_date = today
                self.last_refreshed_time = datetime.now()
                logger.info("easytrader 连接成功。")
            except Exception as e:
                logger.error(f"连接 easytrader 失败: {e}", exc_info=True)
                self.user = None
                self.last_connected_date = None
                raise
        
        # 检查是否需要刷新
        if datetime.now() - self.last_refreshed_time > self.refresh_interval:
            logger.info("会话超过5分钟未刷新，执行 user.refresh()...")
            try:
                self.user.refresh()
                self.last_refreshed_time = datetime.now()
                logger.info("user.refresh() 执行成功。")
            except Exception as e:
                logger.error(f"执行 user.refresh() 失败: {e}，将尝试断开重连。")
                self.disconnect() # 刷新失败，可能连接已断，强制断开
                # 下次调用 get_user 时会自动重连
                raise # 抛出异常，让当前操作失败
        
        return self.user

    def _connect(self, config: dict):
        client_type = config.get('client_type', 'ht_client')
        user_config_path = config.get('user_config_path')
        
        if client_type == 'ht_client':
            self.user = easytrader.use('ht_client')
            self.user.prepare(user_config_path)
        else:
            raise NotImplementedError(f"不支持的客户端类型: {client_type}")

    def disconnect(self):
        if self.user:
            try:
                self.user.exit()
                logger.info("easytrader 连接已成功断开。")
            except Exception as e:
                logger.error(f"断开 easytrader 连接时出错: {e}", exc_info=True)
            finally:
                self.user = None
                self.last_connected_date = None
                self.last_refreshed_time = None

connection_manager = ConnectionManager()

class RealTradeHandler(ITradeHandler):
    COMMISSION_RATE = Decimal('0.00025')
    MIN_COMMISSION = Decimal('5')
    STAMP_DUTY_RATE = Decimal('0.001')

    def __init__(self):
        config = config_loader.get_config()
        self.is_simulation = (config.get('trading_mode') == 'real_simulation_observation')
        logger.info(f"RealTradeHandler 初始化。模式: {'实盘模拟观测' if self.is_simulation else '实盘交易'}")

    def _get_user(self):
        return connection_manager.get_user()

    def _api_buy(self, stock_code: str, price: Decimal, quantity: int):
        user = self._get_user()
        ak_code = stock_code.split('.')[-1]
        return user.buy(ak_code, price=float(price), amount=quantity)

    def _api_sell(self, stock_code: str, quantity: int):
        user = self._get_user()
        ak_code = stock_code.split('.')[-1]
        return user.sell(ak_code, amount=quantity)

    def _api_get_orders(self):
        user = self._get_user()
        return user.entrust

    def _api_get_balance(self):
        user = self._get_user()
        return user.balance

    def _api_get_realtime_quote(self, stock_code: str) -> dict:
        ak_code = stock_code.split('.')[-1]
        try:
            df = ak.stock_zh_a_spot_em(symbol=ak_code)
            if not df.empty:
                quote = df.iloc[0]
                return {
                    'open': Decimal(str(quote['今开'])),
                    'price': Decimal(str(quote['最新价'])),
                }
        except Exception as e:
            logger.warning(f"通过 akshare 获取 {stock_code} 实时行情失败: {e}")
        return {}

    def get_opening_price(self, stock_code: str) -> Decimal:
        quote = self._api_get_realtime_quote(stock_code)
        return quote.get('open', Decimal('0.00'))

    def get_realtime_price(self, stock_code: str) -> Decimal | None:
        quote = self._api_get_realtime_quote(stock_code)
        return quote.get('price')

    def get_available_balance(self) -> Decimal:
        if self.is_simulation:
            return Decimal('1000000.00')
        
        balance_info = self._api_get_balance()
        return Decimal(str(balance_info.get('可用金额', '0.00')))

    @transaction.atomic
    def place_buy_order(self, stock_code: str, price: Decimal, quantity: int):
        logger.info(f"准备下单买入: {stock_code}, 价格: {price}, 数量: {quantity}")
        
        entry_datetime = timezone.now()
        position = Position.objects.create(
            stock_code_id=stock_code, entry_datetime=entry_datetime,
            entry_price=price, quantity=quantity,
            current_stop_loss=Decimal('0.00'), current_take_profit=Decimal('0.00'),
            status=Position.StatusChoices.OPEN
        )
        trade_log = TradeLog.objects.create(
            position=position, stock_code_id=stock_code,
            trade_datetime=entry_datetime, trade_type=TradeLog.TradeTypeChoices.BUY,
            order_type=TradeLog.OrderTypeChoices.LIMIT, price=price,
            quantity=quantity, commission=Decimal('0.00'), stamp_duty=Decimal('0.00'),
            reason=TradeLog.ReasonChoices.ENTRY, status=TradeLog.StatusChoices.PENDING
        )

        if self.is_simulation:
            logger.info("[模拟模式] 跳过真实API调用，直接模拟成交。")
            amount = price * quantity
            commission = max(amount * self.COMMISSION_RATE, self.MIN_COMMISSION)
            trade_log.status = TradeLog.StatusChoices.FILLED
            trade_log.commission = commission.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            trade_log.save()
            
            decision_service = DecisionOrderService(self, execution_date=date.today())
            decision_service.calculate_stop_profit_loss(trade_log.trade_id)
        else:
            try:
                order_result = self._api_buy(stock_code, price, quantity)
                logger.info(f"真实买入委托已提交: {order_result}")
                # 关键：保存委托编号
                if order_result and 'entrust_no' in order_result:
                    trade_log.external_order_id = str(order_result['entrust_no'])
                    trade_log.save()
            except Exception as e:
                logger.error(f"提交买入委托失败: {e}", exc_info=True)
                trade_log.status = TradeLog.StatusChoices.FAILED
                trade_log.save()
                position.status = Position.StatusChoices.CLOSED
                position.save()

    @transaction.atomic
    def sell_stock_by_market_price(self, position: Position, reason: str):
        logger.info(f"准备市价卖出: {position.stock_code_id}, 数量: {position.quantity}, 原因: {reason}")

        trade_log = TradeLog.objects.create(
            position=position, stock_code_id=position.stock_code_id,
            trade_datetime=timezone.now(), trade_type=TradeLog.TradeTypeChoices.SELL,
            order_type=TradeLog.OrderTypeChoices.MARKET, price=Decimal('0.00'),
            quantity=position.quantity, commission=Decimal('0.00'), stamp_duty=Decimal('0.00'),
            reason=reason, status=TradeLog.StatusChoices.PENDING
        )

        if self.is_simulation:
            logger.info("[模拟模式] 跳过真实API调用，直接模拟成交。")
            try:
                last_quote = DailyQuotes.objects.filter(stock_code_id=position.stock_code_id).latest('trade_date')
                sell_price = last_quote.close
            except DailyQuotes.DoesNotExist:
                sell_price = position.entry_price

            amount = sell_price * position.quantity
            commission = max(amount * self.COMMISSION_RATE, self.MIN_COMMISSION)
            stamp_duty = amount * self.STAMP_DUTY_RATE

            trade_log.status = TradeLog.StatusChoices.FILLED
            trade_log.price = sell_price
            trade_log.commission = commission.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            trade_log.stamp_duty = stamp_duty.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            trade_log.save()

            position.status = Position.StatusChoices.CLOSED
            position.save()
        else:
            try:
                order_result = self._api_sell(position.stock_code_id, position.quantity)
                logger.info(f"真实卖出委托已提交: {order_result}")
                if order_result and 'entrust_no' in order_result:
                    trade_log.external_order_id = str(order_result['entrust_no'])
                    trade_log.save()
            except Exception as e:
                logger.error(f"提交卖出委托失败: {e}", exc_info=True)
                trade_log.status = TradeLog.StatusChoices.FAILED
                trade_log.save()

####文件结束####

####trade_manager\service\scheduler_service.py####
# trade_manager/service/scheduler_service.py

import logging
import pandas as pd # 修正：导入pandas
from datetime import date, timedelta, datetime

import akshare as ak
from apscheduler.schedulers.background import BackgroundScheduler # 使用BackgroundScheduler
from django.conf import settings
from django.db import transaction
from decimal import Decimal

from selection_manager.service.selection_service import SelectionService
from data_manager.service.corporate_action_service import CorporateActionService
from data_manager.service.stock_service import StockService
from data_manager.service.email_service import EmailNotificationService
from trade_manager.service.before_fix_service import BeforeFixService
from trade_manager.service.decision_order_service import DecisionOrderService
from trade_manager.service.monitor_exit_service import MonitorExitService
from trade_manager.service.real_trade_handler import RealTradeHandler, connection_manager
from common.models import TradeLog, Position
from common.config_loader import config_loader

logger = logging.getLogger(__name__)

class TradingCalendar:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(TradingCalendar, cls).__new__(cls, *args, **kwargs)
        return cls._instance

    def __init__(self):
        if not hasattr(self, 'initialized'):
            self.trade_dates = set()
            self.last_updated = None
            self.initialized = True
            self._update_calendar()

    def _update_calendar(self):
        logger.info("正在更新交易日历...")
        try:
            df = ak.tool_trade_date_hist_sina()
            self.trade_dates = set(pd.to_datetime(df['trade_date']).dt.date)
            self.last_updated = date.today()
            logger.info(f"交易日历更新成功，共获取 {len(self.trade_dates)} 个交易日。")
        except Exception as e:
            logger.error(f"更新交易日历失败: {e}", exc_info=True)

    def is_trading_day(self, check_date: date) -> bool:
        if date.today() != self.last_updated:
            self._update_calendar()
        return check_date in self.trade_dates

trading_calendar = TradingCalendar()

# --- Job Functions ---

def run_job_wrapper(job_func, job_name, *args, **kwargs):
    scheduler_status = config_loader.get('scheduler', {}).get('status')
    if scheduler_status == 'off': return

    logger.info(f"--- [{job_name}] 任务触发 ---")
    if scheduler_status == 'dry_run':
        logger.info(f"[{job_name}] 空转模式，任务仅打印日志，不执行。")
        return
    
    try:
        job_func(*args, **kwargs)
        logger.info(f"--- [{job_name}] 任务成功执行 ---")
    except Exception as e:
        logger.error(f"--- [{job_name}] 任务执行失败: {e} ---", exc_info=True)

def daily_check():
    today = date.today()
    if not trading_calendar.is_trading_day(today):
        logger.debug(f"{today} 不是交易日，今日主要交易流程任务将跳过。")
        return False
    return True

def selection_job():
    

    t_minus_1 = date.today() - timedelta(days=1)
    if not trading_calendar.is_trading_day(date.today()):
        logger.info(f"今日({date.today()})不是交易日，不执行选股任务。")
        return
    service = StockService()
    service.update_local_a_shares(start_date=date.today().strftime('%Y-%m-%d'),end_date=date.today().strftime('%Y-%m-%d'))
    service.update_csi300_index_data(start_date=date.today().strftime('%Y-%m-%d'), end_date=date.today().strftime('%Y-%m-%d'))
    service = SelectionService(trade_date=date.today(), mode='realtime')
    service.run_selection()

def premarket_fix_job():
    if not daily_check(): return
    service = BeforeFixService(execution_date=date.today())
    service.run()

def opening_decision_job():
    if not daily_check(): return
    handler = RealTradeHandler()
    service = DecisionOrderService(handler, execution_date=date.today())
    
    logger.info("执行交易预案二次筛选...")
    service.adjust_trading_plan_daily()
    
    logger.info("循环执行下单，尝试填满仓位...")
    max_positions = service.current_max_positions
    logger.info(f"根据M(t)计算，当日动态最大持仓数为: {max_positions}")

    
    open_positions_count = Position.objects.filter(status=Position.StatusChoices.OPEN).count()
    slots_to_fill = max_positions - open_positions_count
 
    # 3. 循环调用同一个实例的方法
    for i in range(slots_to_fill):
        logger.info(f"尝试填充第 {i+1}/{slots_to_fill} 个仓位...")
        service.execute_orders()

def monitoring_job():
    if not daily_check(): return
    handler = RealTradeHandler()
    service = MonitorExitService(handler, execution_date=date.today())
    service.monitor_and_exit_positions()

def update_order_status_job():
    if not daily_check(): return
    handler = RealTradeHandler()
    if handler.is_simulation: return

    pending_trades = TradeLog.objects.filter(status=TradeLog.StatusChoices.PENDING, external_order_id__isnull=False)
    if not pending_trades.exists(): return
    
    try:
        real_orders = handler._api_get_orders()
        if not real_orders: return
        real_orders_map = {str(o['entrust_no']): o for o in real_orders}

        for trade in pending_trades:
            real_order = real_orders_map.get(trade.external_order_id)
            if not real_order: continue
            
            if real_order['order_status'] in ['已成', '全部成交']:
                with transaction.atomic():
                    trade.status = TradeLog.StatusChoices.FILLED
                    trade.price = Decimal(str(real_order['filled_price']))
                    # 注意：easytrader返回的佣金可能不准确，这里仅为示例
                    trade.commission = Decimal(str(real_order.get('business_balance', '0.0'))) - Decimal(str(real_order.get('clear_balance', '0.0')))
                    

                    if trade.trade_type == 'buy':
                        decision_service = DecisionOrderService(handler, execution_date=date.today())
                        decision_service.calculate_stop_profit_loss(trade.trade_id)
                    else: # sell
                        if trade.price >= position.entry_price:
                            trade.reason = TradeLog.ReasonChoices.TAKE_PROFIT
                        else:
                            trade.reason = TradeLog.ReasonChoices.STOP_LOSS
                        position = trade.position
                        position.status = Position.StatusChoices.CLOSED
                        position.save()
                    trade.save()
                logger.info(f"订单 {trade.trade_id} (委托号: {trade.external_order_id}) 状态更新为已成交。")

            elif real_order['order_status'] in ['已撤', '废单', '部成已撤']:
                with transaction.atomic():
                    trade.status = TradeLog.StatusChoices.CANCELLED if '撤' in real_order['order_status'] else TradeLog.StatusChoices.FAILED
                    trade.save()
                    if trade.trade_type == 'buy':
                        position = trade.position
                        position.status = Position.StatusChoices.CLOSED
                        position.save()
                logger.info(f"订单 {trade.trade_id} (委托号: {trade.external_order_id}) 状态更新为 {trade.status}。")

    except Exception as e:
        logger.error(f"更新订单状态时出错: {e}", exc_info=True)

def update_corporate_actions_job():
    today = date.today()
    start_date = today - timedelta(days=30)
    end_date = today + timedelta(days=30)
    service = CorporateActionService()
    service.sync_corporate_actions(start_date=start_date.strftime('%Y-%m-%d'), end_date=end_date.strftime('%Y-%m-%d'))

def disconnect_job():
    logger.info("执行每日断开连接任务...")
    connection_manager.disconnect()

scheduler = BackgroundScheduler(timezone='Asia/Shanghai')


def schedule_intraday_jobs():
    """在每个交易日开盘前，添加当天的盘中监控任务。"""
    job_id_monitor = 'intraday_monitoring_job'
    job_id_order_status = 'intraday_order_status_job'
    
    # 为防止重复添加，先尝试移除旧的（如果存在）
    try:
        scheduler.remove_job(job_id_monitor)
        logger.info(f"成功移除旧的盘中监控任务 (ID: {job_id_monitor})。")
    except Exception:
        pass # JobNotFoundError, a normal case
    
    try:
        scheduler.remove_job(job_id_order_status)
        logger.info(f"成功移除旧的订单状态更新任务 (ID: {job_id_order_status})。")
    except Exception:
        pass
 
    if not daily_check(): return
 
    today_str = date.today().isoformat()
    logger.info(f"正在为 {today_str} 添加盘中任务...")
 
    scheduler.add_job(
        run_job_wrapper, 
        'interval', 
        seconds=5, 
        start_date=f'{today_str} 09:30:01', 
        end_date=f'{today_str} 14:57:00', 
        args=[monitoring_job, '盘中监控'],
        id=job_id_monitor, # **给任务一个唯一的ID**
        replace_existing=True # 如果ID已存在，则替换
    )
 
    scheduler.add_job(
        run_job_wrapper, 
        'interval', 
        seconds=10, 
        start_date=f'{today_str} 09:30:00', 
        end_date=f'{today_str} 15:00:00', 
        args=[update_order_status_job, '更新订单状态'],
        id=job_id_order_status, # **给任务一个唯一的ID**
        replace_existing=True
    )
    logger.info("当日盘中任务已成功调度。")
 
 
# 清理任务的函数，虽然 replace_existing=True也能工作，但显式清理更干净
def cleanup_intraday_jobs():
    """收盘后清理，以防万一。"""
    try:
        scheduler.remove_job('intraday_monitoring_job')
        scheduler.remove_job('intraday_order_status_job')
        logger.info("已清理当日盘中任务。")
    except Exception:
        pass

# 邮件发送任务
def email_jobs():
    """每天发送计划邮件"""
    today = date.today()
    service = EmailNotificationService(today)
    service.runEmailSend()


def start():
    """启动调度器的主函数"""
    if config_loader.get('scheduler', {}).get('status') == 'off':
        logger.info("调度器状态为 'off'，不启动。")
        return

    if scheduler.running:
        logger.warning("调度器已在运行中。")
        return

    # 添加任务
    scheduler.add_job(run_job_wrapper, 'cron', day='*', hour=19, minute=0, args=[selection_job, '日终选股'])
    scheduler.add_job(run_job_wrapper, 'cron', day='*', hour=6, minute=10, args=[premarket_fix_job, '盘前校准'])
    scheduler.add_job(run_job_wrapper, 'cron', day='*', hour=6, minute=30, args=[email_jobs, '预案推送'])
    #scheduler.add_job(run_job_wrapper, 'cron', day='*', hour=9, minute=25, second=5, args=[opening_decision_job, '开盘决策'])
    
    # --- 每日动态任务的调度器 ---
    # 在每个交易日的开盘前（例如9:00）安排好当天的盘中任务
    #scheduler.add_job(schedule_intraday_jobs, 'cron', day='*', hour=9, minute=0)
    #在收盘后清理
    #scheduler.add_job(cleanup_intraday_jobs, 'cron', day='*', hour=15, minute=5)
    
    # 数据和连接管理任务
    scheduler.add_job(run_job_wrapper, 'cron', day='*', hour=6, minute=0, args=[update_corporate_actions_job, '更新除权除息'])
    #scheduler.add_job(run_job_wrapper, 'cron', day='*', hour=15, minute=30, args=[disconnect_job, '断开连接'])
    # today_str = date.today().isoformat()
    # scheduler.add_job(
    #     run_job_wrapper, 
    #     'interval', 
    #     seconds=10, 
    #     start_date=f'{today_str} 07:30:00', 
    #     end_date=f'{today_str} 19:30:00',
    #     args=[update_order_status_job, '更新订单状态'],
    #     id='job_id_order_status', # **给任务一个唯一的ID**
    #     replace_existing=True
    # )
    logger.info("APScheduler 已配置完成，准备在后台启动...")
    scheduler.start()

####文件结束####

####trade_manager\service\simulate_trade.py####
# ==============================================================================
# 文件 4/5: trade_manager/service/simulate_trade.py (修改)
# 描述: 核心回测服务，集成日志记录和邮件发送。
# ==============================================================================
# trade_manager/service/simulate_trade.py

import logging
from datetime import date, timedelta, datetime
from decimal import Decimal
import numpy as np
import pandas as pd
from django.db import connections, transaction
from django.core.management import call_command

# 内部模块导入
from common.models import (
    DailyFactorValues, DailyTradingPlan, Position, TradeLog, SystemLog,
    StrategyParameters, DailyQuotes, CorporateAction
)
# 新增导入
from common.models.backtest_logs import BacktestDailyLog, BacktestOperationLog 
from selection_manager.service.selection_service import SelectionService, MARKET_INDICATOR_CODE
from trade_manager.service.before_fix_service import BeforeFixService
from trade_manager.service.decision_order_service import DecisionOrderService
from trade_manager.service.monitor_exit_service import MonitorExitService
from .simulate_trade_handler import SimulateTradeHandler
from .db_utils import use_backtest_schema
from .backtest_reporter import BacktestReporter 
from .position_monitor_logic import PositionMonitorLogic

logger = logging.getLogger(__name__)

class SimulateTradeService:
    """
    回测实施服务 (V3 - 集成日志与报告)。
    """
    COMMISSION_RATE = Decimal('0.0002854')
    MIN_COMMISSION = Decimal('5')
    STAMP_DUTY_RATE = Decimal('0.001')
    SELL_SLIPPAGE_RATE = Decimal('0.002')

    def __init__(self):
        self.start_date: date = None
        self.end_date: date = None
        self.current_date: date = None
        self.initial_capital = Decimal('0.0')
        self.cash_balance = Decimal('0.0')
        self.portfolio_history = []
        self.last_buy_trade_id = None
        self.backtest_run_id: str = None # 新增：回测唯一ID
        self.params: dict = {}
    def _persist_risk_prices_if_changed(self, position, new_sl, new_tp, label='盘中'):
        if new_sl != position.current_stop_loss or new_tp != position.current_take_profit:
            position.current_stop_loss = new_sl
            position.current_take_profit = new_tp
            position.save(update_fields=['current_stop_loss', 'current_take_profit'])
            logger.info(f"[回测] {position.stock_code_id} {label}更新风控价格。SL: {position.current_stop_loss:.2f}, TP: {position.current_take_profit:.2f}")
    def _load_parameters(self):
        """在回测开始前加载所有需要的策略参数。"""
        logger.info("加载回测所需策略参数...")
        # 从 StrategyParameters 表中一次性加载所有参数
        all_params = {p.param_name: p.param_value for p in StrategyParameters.objects.all()}
        
        # 定义回测逻辑中需要用到的参数及其默认值
        required_params = {
            'trailing_tp_increment_pct': '0.02',
            'trailing_sl_buffer_pct': '0.01',
            # 这里可以添加其他未来可能用到的参数
        }
        for key, default_value in required_params.items():
            # 优先使用数据库的值，否则使用默认值
            self.params[key] = all_params.get(key, Decimal(default_value))
        
        logger.info(f"策略参数加载完成: {self.params}")
    def _setup_backtest_schema(self, schema_name: str, initial_capital: Decimal):
        logger.info(f"--- 1. 在 Schema '{schema_name}' 中准备回测环境 ---")
        
        logger.info("正在新 Schema 中创建表结构 (执行 migrate)...")
        with connections['default'].cursor() as cursor:
            logger.info(f"临时隔离 search_path 到 '{schema_name}' 以便运行 migrate 命令。")
            cursor.execute(f'SET search_path TO "{schema_name}";')
            
            logger.info("正在新 Schema 中创建表结构 (执行 migrate)...")
            # 在这个隔离的环境下，migrate 看不到 public.django_migrations，因此会创建所有表。
            call_command('migrate')
            logger.info("表结构创建完成。")

        tables_to_copy = [
            'tb_stock_info', 'tb_daily_quotes', 'tb_corporate_actions',
            'tb_factor_definitions', 'tb_strategy_parameters', 
            'tb_daily_factor_values','tb_daily_trading_plan','tb_index_quotes_csi300'
        ]
        
        logger.info(f"准备从 'public' schema 复制基础数据到 '{schema_name}'...")
        with transaction.atomic(), connections['default'].cursor() as cursor:
            cursor.execute(f'SET search_path TO "{schema_name}";')
            for table_name in tables_to_copy:
                logger.info(f"  - 正在处理表: {table_name}")
                # 1. 区分并获取 "普通索引" 和 "约束"
                # =========================================================================
                # 1a. 获取普通索引 (不包括由 UNIQUE 或 PRIMARY KEY 约束创建的索引)
                logger.info(f"    - 正在获取 '{table_name}' 的普通索引...")
                cursor.execute("""
                    SELECT indexdef
                    FROM pg_indexes
                    WHERE schemaname = %s AND tablename = %s
                    AND indexname NOT IN (
                        SELECT conname FROM pg_constraint WHERE conrelid = %s::regclass
                    );
                """, [schema_name, table_name, f'"{schema_name}"."{table_name}"'])
                plain_indexes_to_recreate = [row[0] for row in cursor.fetchall()]
                # 1b. 获取约束 (外键和唯一约束)
                logger.info(f"    - 正在获取 '{table_name}' 的外键和唯一约束...")
                cursor.execute("""
                    SELECT 'ALTER TABLE ' || quote_ident(conrelid::regclass::text) || ' ADD CONSTRAINT ' || quote_ident(conname) || ' ' || pg_get_constraintdef(oid)
                    FROM pg_constraint
                    WHERE contype IN ('f', 'u') AND conrelid = %s::regclass;
                """, [f'"{schema_name}"."{table_name}"'])
                constraints_to_recreate = [row[0] for row in cursor.fetchall()]
                # 2. 删除索引和约束 (删除约束会自动删除其底层索引)
                # =========================================================================
                # 2a. 删除约束
                for const_def in constraints_to_recreate:
                    const_name = const_def.split('ADD CONSTRAINT ')[1].split(' ')[0]
                    logger.info(f"      - 删除约束: {const_name}")
                    cursor.execute(f'ALTER TABLE "{table_name}" DROP CONSTRAINT IF EXISTS {const_name};')
                
                # 2b. 删除普通索引
                for index_def in plain_indexes_to_recreate:
                    # 从 "CREATE INDEX index_name ON ..." 中提取 index_name
                    try:
                        index_name = index_def.split(' ')[2]
                        logger.info(f"      - 删除索引: {index_name}")
                        cursor.execute(f'DROP INDEX IF EXISTS "{index_name}";')
                    except IndexError:
                        logger.warning(f"无法从 '{index_def}' 解析索引名称，跳过删除。")
                # 3. 高效复制数据 (现在非常快)
                # =========================================================================
                logger.info(f"    - 正在从 public.{table_name} 复制数据...")
                sql = f'INSERT INTO "{table_name}" SELECT * FROM public."{table_name}";'
                cursor.execute(sql)
                logger.info(f"    - 数据复制完成。")
                # 4. 重建索引和约束
                # =========================================================================
                logger.info(f"    - 正在重建 '{table_name}' 的索引和约束...")
                # 4a. 重建普通索引
                for index_def in plain_indexes_to_recreate:
                    logger.info(f"      - 重建索引: {index_def}")
                    cursor.execute(index_def)
                
                # 4b. 重建约束 (这会自动重建它们的底层索引)
                for const_def in constraints_to_recreate:
                    logger.info(f"      - 重建约束: {const_def}")
                    cursor.execute(const_def)

                # =========================================================================
                # 5. 重置自增主键序列 (解决主键冲突的关键)
                # =========================================================================
                # 自动查找并更新当前表的自增序列
                find_serial_sql = """
                    SELECT 
                        a.attname, 
                        pg_get_serial_sequence(
                            quote_ident(n.nspname) || '.' || quote_ident(c.relname), 
                            a.attname
                        )
                    FROM 
                        pg_class c
                    JOIN 
                        pg_attribute a ON a.attrelid = c.oid
                    JOIN 
                        pg_namespace n ON c.relnamespace = n.oid -- 通过namespace OID关联
                    WHERE 
                        n.nspname = %s      -- 参数1: schema的名称
                        AND c.relname = %s  -- 参数2: 表的名称
                        AND a.attnum > 0 
                        AND NOT a.attisdropped
                        AND pg_get_serial_sequence(quote_ident(n.nspname) || '.' || quote_ident(c.relname), a.attname) IS NOT NULL;
                """
                cursor.execute(find_serial_sql, [schema_name, table_name])
                serial_columns = cursor.fetchall()

                for column_name, sequence_name in serial_columns:
                    logger.info(f"    - 发现自增列 '{column_name}'，正在重置其序列 '{sequence_name}'...")
                    
                    # 将序列的下一个值设置为 (表中该列的最大值 + 1)，如果表为空则设置为1
                    update_sequence_sql = f"""
                        SELECT setval(
                            '{sequence_name}', 
                            COALESCE((SELECT MAX("{column_name}") FROM "{table_name}"), 0) + 1, 
                            true
                        )
                    """
                    cursor.execute(update_sequence_sql)
                    logger.info(f"    - 序列 '{sequence_name}' 已更新。")

                
        logger.info("基础数据复制完成。")
        # with connections['default'].cursor() as cursor:
        #     for table_name in tables_to_copy:
        #         logger.info(f"  - 正在复制表: {table_name}")
        #         sql = f'INSERT INTO "{schema_name}"."{table_name}" SELECT * FROM public."{table_name}";'
        #         cursor.execute(sql)
        # logger.info("基础数据复制完成。")

        self.initial_capital = initial_capital
        self.cash_balance = self.initial_capital
        logger.info(f"初始资金已设定为: {self.initial_capital:.2f}")

    def _simulate_intraday_monitoring(self, position: Position, daily_quote: DailyQuotes):
        open_p, high_p, low_p = daily_quote.open, daily_quote.high, daily_quote.low
        
        # 临时变量，模拟盘中状态
        temp_position_state = {
            'current_stop_loss': position.current_stop_loss,
            'current_take_profit': position.current_take_profit
        }
        
        # 1. 开盘价检查
        decision = PositionMonitorLogic.check_and_decide(position, open_p, self.params)
        if decision['action'] == 'SELL':
            price=min(open_p,decision['exit_price'])
            logger.info(f"[回测] {position.stock_code_id} 开盘价 {open_p:.2f} 触发卖出，成交价 {decision['exit_price']:.2f}")
            self._persist_risk_prices_if_changed(
                position,
                temp_position_state['current_stop_loss'],
                temp_position_state['current_take_profit'],
                label='盘中'
            )
            logger.info(f"[回测] {position.stock_code_id} 开盘价 {open_p:.2f} 触发卖出，成交价 {price:.2f}")
            self.handler.sell_stock_by_market_price(position, decision['reason'], simulated_exit_price=price)
            return
        elif decision['action'] == 'UPDATE':
            temp_position_state.update(decision['updates'])
        # 2. 日内循环监控
        while True:
            action_taken_in_loop = False
            
            # 检查点1: 最低价是否触发卖出
            decision_low = PositionMonitorLogic.check_and_decide(
                Position( # 传入一个临时的、包含最新状态的Position对象
                    entry_price=position.entry_price,
                    current_stop_loss=temp_position_state['current_stop_loss'],
                    current_take_profit=temp_position_state['current_take_profit']
                ), 
                low_p, 
                self.params
            )
            if decision_low['action'] == 'SELL':
                self._persist_risk_prices_if_changed(
                    position,
                    temp_position_state['current_stop_loss'],
                    temp_position_state['current_take_profit'],
                    label='盘中'
                )
                logger.info(f"[回测] {position.stock_code_id} 最低价 {low_p:.2f} 触发卖出，成交价 {decision_low['exit_price']:.2f}")
                self.handler.sell_stock_by_market_price(position, decision_low['reason'], simulated_exit_price=decision_low['exit_price'])
                return
            # 检查点2: 最高价是否触发价格更新
            decision_high = PositionMonitorLogic.check_and_decide(
                Position(
                    entry_price=position.entry_price,
                    current_stop_loss=temp_position_state['current_stop_loss'],
                    current_take_profit=temp_position_state['current_take_profit']
                ), 
                high_p, 
                self.params
            )
            if decision_high['action'] == 'UPDATE':
                # 检查是否有实际的更新
                if temp_position_state != decision_high['updates']:
                    temp_position_state.update(decision_high['updates'])
                    action_taken_in_loop = True
            if not action_taken_in_loop:
                break
                
        # 3. 日终结算
        if temp_position_state['current_stop_loss'] != position.current_stop_loss or \
        temp_position_state['current_take_profit'] != position.current_take_profit:
            position.current_stop_loss = temp_position_state['current_stop_loss']
            position.current_take_profit = temp_position_state['current_take_profit']
            position.save(update_fields=['current_stop_loss', 'current_take_profit'])
            logger.info(f"[回测] {position.stock_code_id} 日终更新风控价格。SL: {position.current_stop_loss:.2f}, TP: {position.current_take_profit:.2f}")

    def run_backtest(self, start_date: str, end_date: str, initial_capital: Decimal) -> dict:
        self.start_date = date.fromisoformat(start_date)
        self.end_date = date.fromisoformat(end_date)
        self.backtest_run_id = f"backtest_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        logger.info(f"为本次回测创建临时 Schema: {self.backtest_run_id}")

        try:
            with connections['default'].cursor() as cursor:
                cursor.execute(f'CREATE SCHEMA IF NOT EXISTS "{self.backtest_run_id}";')

            with use_backtest_schema(self.backtest_run_id):
                self._setup_backtest_schema(self.backtest_run_id, initial_capital)
                self._load_parameters()
                handler = SimulateTradeHandler(self)
                self.handler=handler
                trading_days = self._get_trading_days()
                if not trading_days:
                    logger.error("在指定日期范围内未找到任何交易日，回测终止。")
                    return {}
                #master_panels = self._preload_data_for_backtest(trading_days)
                logger.info("--- [滚动窗口] 开始准备数据 ---")
                lookback_window_size = 250  # 因子计算所需的最大回溯期
                # 为了保证有足够的交易日，我们回溯更多的自然日
                extra_buffer_days = 20 
                
                # 1. 直接计算预加载的起始日期，不再扫描全表
                preload_start_date = trading_days[0] - timedelta(days=lookback_window_size + extra_buffer_days)
                
                logger.info(f"一次性查询数据库，时间窗口: {preload_start_date} to {self.end_date}")
                
                quotes_iterator = DailyQuotes.objects.filter(
                    trade_date__gte=preload_start_date,
                    trade_date__lte=self.end_date
                ).order_by('trade_date', 'stock_code_id').values(
                    'trade_date', 'stock_code_id', 'open', 'high', 'low', 'close', 'volume', 'turnover', 'hfq_close'
                ).iterator(chunk_size=20000)
                logger.info("将迭代器数据按日期分组到字典中...")
                quotes_by_date = {}
                for row in quotes_iterator:
                    trade_date = row['trade_date']
                    if trade_date not in quotes_by_date:
                        quotes_by_date[trade_date] = []
                    quotes_by_date[trade_date].append(row)
                
                # 2. 初始化第一个滚动窗口
                logger.info("初始化第一个滚动窗口面板...")
                # 获取所有已加载的日期，并排序
                all_loaded_dates = sorted(quotes_by_date.keys())
                
                # 找到第一个回测日
                first_backtest_day = trading_days[0]
                
                # 从已加载的日期中，筛选出用于初始化的部分
                initial_window_dates = [d for d in all_loaded_dates if d <= first_backtest_day]
                initial_rows = []
                for d in initial_window_dates:
                    initial_rows.extend(quotes_by_date.get(d, []))
                
                if not initial_rows:
                    raise ValueError("初始化滚动窗口失败，没有获取到任何数据。")
                df_window = pd.DataFrame(initial_rows)
                df_window['trade_date'] = pd.to_datetime(df_window['trade_date'])
                
                rolling_panels = {}
                for col in ['open', 'high', 'low', 'close', 'volume', 'turnover', 'hfq_close']:
                    panel = df_window.pivot(index='trade_date', columns='stock_code_id', values=col).astype(float)
                    rolling_panels[col] = panel
                
                logger.info(f"滚动窗口初始化完成，包含 {len(initial_window_dates)} 天数据。")
                logger.info(f"--- 2. 开始日度回测循环 ({len(trading_days)}天) ---")
                
                last_sent_month = None # 用于邮件触发

                for i, current_day in enumerate(trading_days):
                    self.current_date = current_day
                    logger.info(f"\n{'='*20} 模拟日: {self.current_date} ({i+1}/{len(trading_days)}) {'='*20}")
                    if i > 0:
                        # 检查新的一天是否有数据，有才滚动
                        new_day_data = quotes_by_date.get(current_day)
                        if new_day_data:
                            logger.debug(f"滚动窗口: 移除 {rolling_panels['close'].index[0].date()}, 添加 {current_day}")
                            # 移除最老的一天
                            for key in rolling_panels:
                                rolling_panels[key] = rolling_panels[key].iloc[1:]
                            
                            # 添加新的一天
                            df_new_day = pd.DataFrame(new_day_data)
                            df_new_day['trade_date'] = pd.to_datetime(df_new_day['trade_date'])
                            
                            for col in ['open', 'high', 'low', 'close', 'volume', 'turnover', 'hfq_close']:
                                new_row = df_new_day.pivot(index='trade_date', columns='stock_code_id', values=col).astype(float)
                                # 使用 pd.concat 合并，比 append 更推荐
                                rolling_panels[col] = pd.concat([rolling_panels[col], new_row])
                        else:
                            logger.warning(f"日期 {current_day} 在预加载数据中不存在，窗口未滚动。")

                    logger.info("-> [T日 盘前校准] ...")
                    before_fix_service = BeforeFixService(execution_date=self.current_date)
                    before_fix_service.run()
                    
                    self._handle_dividends()

                    logger.info("-> [T日 开盘决策与买入] ...")
                    decision_order_service = DecisionOrderService(handler=handler, execution_date=self.current_date)
                    decision_order_service.adjust_trading_plan_daily()
                    
                    while True:
                        open_positions_count = Position.objects.filter(status=Position.StatusChoices.OPEN).count()
                        max_pos = decision_order_service.current_max_positions
                        if open_positions_count >= max_pos: break
                        
                        self.last_buy_trade_id = None
                        decision_order_service.execute_orders()
                        
                        if self.last_buy_trade_id:
                            decision_order_service.calculate_stop_profit_loss(self.last_buy_trade_id)
                            # 在止盈止损计算完毕后，获取更新后的持仓对象
                            trade_log = TradeLog.objects.get(pk=self.last_buy_trade_id)
                            position = trade_log.position
                            # 现在才调用日志记录函数，此时 position 对象已包含正确的止盈止损价
                            handler._record_buy_operation(position)
                        else:
                            break

                    positions_to_monitor = Position.objects.filter(status=Position.StatusChoices.OPEN).exclude(
                        entry_datetime__date=self.current_date
                    )
                
                    for pos in positions_to_monitor:
                        # 如果持仓已在循环中被卖出，则跳过
                        if pos.status != Position.StatusChoices.OPEN:
                            continue
                        
                        try:
                            daily_quote = DailyQuotes.objects.get(stock_code_id=pos.stock_code_id, trade_date=self.current_date)
                            self._simulate_intraday_monitoring(pos, daily_quote)
                        except DailyQuotes.DoesNotExist:
                            logger.warning(f"[回测] 无法找到 {pos.stock_code_id} 在 {self.current_date} 的行情，当日无法监控。")
                            continue

                    


                    logger.info(f"-> [T日 盘后选股] 基于 {self.current_date} 的数据为下一交易日做准备...")
                    current_day_dt = pd.to_datetime(current_day)
                    selection_service = SelectionService(trade_date=self.current_date, mode='backtest',preloaded_panels=rolling_panels)
                    selection_service.run_selection()
                    
                    self._record_daily_log()

                    # --- 邮件发送逻辑 ---
                    is_last_day = (i == len(trading_days) - 1)
                    current_month = current_day.month
                    send_mail_flag = False

                    if is_last_day:
                        send_mail_flag = True
                        logger.info("回测结束，触发最终邮件报告。")
                    elif last_sent_month is not None and current_month != last_sent_month:
                        send_mail_flag = True
                        logger.info(f"月份从 {last_sent_month} 变为 {current_month}，触发月度邮件报告。")
                    
                    if send_mail_flag:
                        reporter = BacktestReporter(
                            schema_name=self.backtest_run_id,
                            start_date=self.start_date,
                            current_date=self.current_date,
                            initial_capital=self.initial_capital
                        )
                        reporter.send_report()
                    
                    last_sent_month = current_month
                    # --- 邮件发送逻辑结束 ---

                logger.info("--- 3. 回测循环结束 ---")
                return self._calculate_performance_metrics()

        except Exception as e:
            logger.critical(f"回测过程中发生严重错误: {e}", exc_info=True)
            return {"error": str(e)}

    def _get_trading_days(self) -> list[date]:
        dates = DailyQuotes.objects.filter(
            trade_date__gte=self.start_date,
            trade_date__lte=self.end_date
        ).values_list('trade_date', flat=True).distinct().order_by('trade_date')
        return list(dates)

    def _handle_dividends(self):
        dividend_events = CorporateAction.objects.filter(
            ex_dividend_date=self.current_date, event_type=CorporateAction.EventType.DIVIDEND
        )
        if not dividend_events.exists(): return

        events_by_stock = {}
        for event in dividend_events:
            events_by_stock.setdefault(event.stock_code, []).append(event)
        
        open_positions = Position.objects.filter(
            stock_code_id__in=events_by_stock.keys(), status=Position.StatusChoices.OPEN
        )
        for pos in open_positions:
            for event in events_by_stock.get(pos.stock_code_id, []):
                dividend_amount = event.dividend_per_share * pos.quantity
                self.cash_balance += dividend_amount
                logger.info(f"除息事件: 持仓ID {pos.position_id} ({pos.stock_code_id}) 获得分红 {dividend_amount:.2f}")

    def _record_daily_log(self):
        open_positions = Position.objects.filter(status=Position.StatusChoices.OPEN)
        market_value = Decimal('0.0')
        for pos in open_positions:
            try:
                quote = DailyQuotes.objects.get(stock_code_id=pos.stock_code_id, trade_date=self.current_date)
                market_value += quote.close * pos.quantity
            except DailyQuotes.DoesNotExist:
                market_value += pos.entry_price * pos.quantity
        
        total_assets = self.cash_balance + market_value

        try:
            m_value_obj = DailyFactorValues.objects.get(
                stock_code_id=MARKET_INDICATOR_CODE,
                factor_code_id='dynamic_M_VALUE',
                trade_date=self.current_date
            )
            m_value = m_value_obj.raw_value
        except DailyFactorValues.DoesNotExist:
            m_value = None

        BacktestDailyLog.objects.create(
            backtest_run_id=self.backtest_run_id,
            trade_date=self.current_date,
            total_assets=total_assets,
            cash=self.cash_balance,
            holdings_value=market_value,
            market_m_value=m_value
        )
        logger.info(f"--- 日终结算 ({self.current_date}) ---")
        logger.info(f"现金: {self.cash_balance:.2f}, 持仓市值: {market_value:.2f}, 总资产: {total_assets:.2f}, M值: {m_value}")

    def _calculate_performance_metrics(self) -> dict:
        logger.info("--- 4. 计算回测性能指标 ---")
        daily_logs = BacktestDailyLog.objects.filter(backtest_run_id=self.backtest_run_id).order_by('trade_date')
        if not daily_logs.exists():
            return {}

        df = pd.DataFrame(list(daily_logs.values('total_assets')))
        df['total_assets'] = df['total_assets'].astype(float)
        
        final_value = df['total_assets'].iloc[-1]
        total_return_rate = (final_value / float(self.initial_capital)) - 1
        
        total_days = (self.end_date - self.start_date).days
        if total_days > 0:
            annualized_return = ((final_value / float(self.initial_capital)) ** (365.0 / total_days)) - 1
        else:
            annualized_return = 0.0

        df['peak'] = df['total_assets'].cummax()
        df['drawdown'] = (df['total_assets'] - df['peak']) / df['peak']
        max_drawdown = df['drawdown'].min()

        result = {
            'total_return_rate': f"{total_return_rate:.2%}",
            'annualized_return': f"{annualized_return:.2%}",
            'max_drawdown': f"{max_drawdown:.2%}"
        }
        logger.info(f"最终回测结果: {result}")
        return result


####文件结束####

####trade_manager\service\simulate_trade_handler.py####
# ==============================================================================
# 文件 5/5: trade_manager/service/simulate_trade_handler.py (修改)
# 描述: 模拟交易处理器，集成操作日志记录。
# ==============================================================================
# trade_manager/service/simulate_trade_handler.py

import logging
from datetime import time, timedelta
from decimal import Decimal, ROUND_HALF_UP
from datetime import date, timedelta, datetime
from django.db import transaction
from django.utils import timezone

from .trade_handler import ITradeHandler
from common.models import Position, TradeLog, DailyQuotes, StockInfo, DailyFactorValues
from common.models.backtest_logs import BacktestOperationLog # 新增导入
from selection_manager.service.selection_service import MARKET_INDICATOR_CODE # 新增导入

from typing import TYPE_CHECKING, Literal
if TYPE_CHECKING:
    from .simulate_trade import SimulateTradeService

logger = logging.getLogger(__name__)

class SimulateTradeHandler(ITradeHandler):
    """
    模拟交易处理器 (SimulateTradeHandler) - 集成操作日志。
    """

    def __init__(self, service: 'SimulateTradeService'):
        self.service = service
        self.current_price_node: Literal['OPEN', 'LOW', 'HIGH', 'CLOSE'] = 'CLOSE'

    def get_opening_price(self, stock_code: str) -> Decimal:
        try:
            quote = DailyQuotes.objects.get(
                stock_code_id=stock_code,
                trade_date=self.service.current_date
            )
            return quote.open
        except DailyQuotes.DoesNotExist:
            logger.warning(f"[回测] 无法在 {self.service.current_date} 找到 {stock_code} 的行情数据，返回0。")
            return Decimal('0.00')

    def get_realtime_price(self, stock_code: str) -> Decimal | None:
        try:
            quote = DailyQuotes.objects.get(
                stock_code_id=stock_code,
                trade_date=self.service.current_date
            )
            if self.current_price_node == 'LOW':
                return quote.low
            elif self.current_price_node == 'HIGH':
                return quote.high
            else:
                return quote.close
        except DailyQuotes.DoesNotExist:
            return None

    def get_available_balance(self) -> Decimal:
        return self.service.cash_balance

    @transaction.atomic
    def place_buy_order(self, stock_code: str, price: Decimal, quantity: int) -> None:
        amount = price * quantity
        commission = max(amount * self.service.COMMISSION_RATE, self.service.MIN_COMMISSION)
        total_cost = amount + commission

        if self.service.cash_balance < total_cost:
            raise ValueError(f"资金不足！")

        self.service.cash_balance -= total_cost
        logger.info(f"[回测] 买入 {stock_code} {quantity}股 @{price:.2f}, 花费: {amount:.2f}, 现金余额: {self.service.cash_balance:.2f}")

        entry_time = time(9, 30, 1)
        entry_datetime = timezone.make_aware(timezone.datetime.combine(self.service.current_date, entry_time))

        new_position = Position.objects.create(
            stock_code_id=stock_code, entry_datetime=entry_datetime, entry_price=price,
            quantity=quantity, status=Position.StatusChoices.OPEN,
            current_stop_loss=Decimal('0.00'), current_take_profit=Decimal('0.00')
        )

        trade_log = TradeLog.objects.create(
            position=new_position, stock_code_id=stock_code, trade_datetime=entry_datetime,
            trade_type=TradeLog.TradeTypeChoices.BUY, order_type=TradeLog.OrderTypeChoices.LIMIT,
            price=price, quantity=quantity, commission=commission,
            reason=TradeLog.ReasonChoices.ENTRY, status=TradeLog.StatusChoices.FILLED
        )
        
        self.service.last_buy_trade_id = trade_log.trade_id

        

    @transaction.atomic
    def sell_stock_by_market_price(self, position: Position, reason: str, simulated_exit_price: Decimal = None) -> None:
        
        if simulated_exit_price is None:
            raise ValueError("回测模式下调用 sell_stock_by_market_price 必须提供 simulated_exit_price")

        sell_price = (simulated_exit_price * (Decimal('1.0') - self.service.SELL_SLIPPAGE_RATE))
        sell_price = sell_price.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)

        amount = sell_price * position.quantity
        commission = max(amount * self.service.COMMISSION_RATE, self.service.MIN_COMMISSION)
        stamp_duty = amount * self.service.STAMP_DUTY_RATE
        net_income = amount - commission - stamp_duty

        self.service.cash_balance += net_income
        logger.info(f"[回测] 卖出 {position.stock_code_id} {position.quantity}股 @{sell_price:.2f}, 原因: {reason}, 现金余额: {self.service.cash_balance:.2f}")

        position.status = Position.StatusChoices.CLOSED
        position.save()

        sell_time = time(14, 57, 0)
        sell_datetime = timezone.make_aware(timezone.datetime.combine(self.service.current_date, sell_time))

        TradeLog.objects.create(
            position=position, stock_code_id=position.stock_code_id, trade_datetime=sell_datetime,
            trade_type=TradeLog.TradeTypeChoices.SELL, order_type=TradeLog.OrderTypeChoices.MARKET,
            price=sell_price, quantity=position.quantity, commission=commission,
            stamp_duty=stamp_duty, reason=reason, status=TradeLog.StatusChoices.FILLED
        )
        
        # --- 新增: 记录卖出操作日志 ---
        self._record_sell_operation(position, sell_price, reason)
        
    def _get_t_minus_1_date(self) -> date:
        """安全地获取T-1交易日"""
        try:
            return DailyQuotes.objects.filter(trade_date__lt=self.service.current_date).latest('trade_date').trade_date
        except DailyQuotes.DoesNotExist:
            logger.warning(f"无法找到 {self.service.current_date} 的前一个交易日。")
            return self.service.current_date - timedelta(days=1)

    def _record_buy_operation(self, position: Position):
        t_minus_1 = self._get_t_minus_1_date()
        
        # 获取M值
        try:
            m_value_obj = DailyFactorValues.objects.get(
                stock_code_id=MARKET_INDICATOR_CODE,
                factor_code_id='dynamic_M_VALUE',
                trade_date=t_minus_1
            )
            m_value = m_value_obj.raw_value
        except DailyFactorValues.DoesNotExist:
            m_value = None
        
        # 获取因子得分
        # 步骤1: 先获取该股票当天的所有因子值
        all_factor_scores_qs = DailyFactorValues.objects.filter(
            stock_code_id=position.stock_code_id,
            trade_date=t_minus_1
        )
        
        # 步骤2: 在 Python 层面进行过滤和格式化
        scores_list = []
        for f in all_factor_scores_qs:
            scores_list.append(f"{f.factor_code_id}:{f.norm_score:.2f}")
        scores_str = "|".join(scores_list)
        
        # 获取止盈止损率 (在调用此函数时，Position应已被更新)
        profit_rate = (position.current_take_profit / position.entry_price) - 1 if position.entry_price > 0 else 0
        loss_rate = 1 - (position.current_stop_loss / position.entry_price) if position.entry_price > 0 else 0

        BacktestOperationLog.objects.create(
            backtest_run_id=self.service.backtest_run_id,
            position_id_ref=position.position_id,
            stock_code=position.stock_code_id,
            stock_name=position.stock_code.stock_name,
            trade_date=self.service.current_date,
            direction=BacktestOperationLog.Direction.BUY,
            exit_reason=None,
            profit_rate=profit_rate,
            loss_rate=loss_rate,
            buy_date_m_value=m_value,
            factor_scores=scores_str,
            price=position.entry_price,
            quantity=position.quantity,
            amount=position.entry_price * position.quantity
        )
        logger.debug(f"已记录买入操作日志 for Position ID: {position.position_id}")
        
    def _record_sell_operation(self, position: Position, sell_price: Decimal, reason: str):
        # 反查买入记录
        try:
            buy_op = BacktestOperationLog.objects.get(
                backtest_run_id=self.service.backtest_run_id,
                position_id_ref=position.position_id,
                direction=BacktestOperationLog.Direction.BUY
            )
            m_value = buy_op.buy_date_m_value
            scores_str = buy_op.factor_scores
            profit_rate = buy_op.profit_rate
            loss_rate = buy_op.loss_rate
        except BacktestOperationLog.DoesNotExist:
            logger.error(f"严重错误：无法找到 Position ID {position.position_id} 对应的买入操作日志！")
            m_value, scores_str, profit_rate, loss_rate = None, "", None, None

        exit_reason_for_log = None
        if reason == TradeLog.ReasonChoices.TAKE_PROFIT:
            exit_reason_for_log = BacktestOperationLog.ExitReason.TAKE_PROFIT
        elif reason == TradeLog.ReasonChoices.STOP_LOSS:
            exit_reason_for_log = BacktestOperationLog.ExitReason.STOP_LOSS
        final_profit_rate = (position.current_take_profit / position.entry_price - 1) if position.entry_price > 0 else None
        final_loss_rate = (1 - (position.current_stop_loss / position.entry_price)) if position.entry_price > 0 else None
        BacktestOperationLog.objects.create(
            backtest_run_id=self.service.backtest_run_id,
            position_id_ref=position.position_id,
            stock_code=position.stock_code_id,
            stock_name=position.stock_code.stock_name,
            trade_date=self.service.current_date,
            direction=BacktestOperationLog.Direction.SELL,
            exit_reason=exit_reason_for_log,
            profit_rate=final_profit_rate,
            loss_rate=final_loss_rate,
            buy_date_m_value=m_value,
            factor_scores=scores_str,
            price=sell_price,
            quantity=position.quantity,
            amount=sell_price * position.quantity
        )
        logger.debug(f"已记录卖出操作日志 for Position ID: {position.position_id}")

####文件结束####

####trade_manager\service\simulate_trade_old.py####
# trade_manager/service/simulate_trade.py

import logging
import shutil
import os
from datetime import date, timedelta
from decimal import Decimal, ROUND_HALF_UP
import numpy as np
import pandas as pd
import time
from django.conf import settings
from django.db import connections, transaction
import sqlite3
from common.models import (
    DailyFactorValues, DailyTradingPlan, Position, TradeLog, SystemLog,
    StrategyParameters, DailyQuotes, CorporateAction
)
from selection_manager.service.selection_service import SelectionService
from trade_manager.service.before_fix_service import BeforeFixService
from trade_manager.service.decision_order_service import DecisionOrderService
from trade_manager.service.monitor_exit_service import MonitorExitService
from .simulate_trade_handler import SimulateTradeHandler

logger = logging.getLogger(__name__)

class SimulateTradeService:
    """
    回测实施服务。
    """
    COMMISSION_RATE = Decimal('0.0002854')
    MIN_COMMISSION = Decimal('5')
    STAMP_DUTY_RATE = Decimal('0.001')
    SELL_SLIPPAGE_RATE = Decimal('0.002')
    ANNUAL_RISK_FREE_RATE = Decimal('0.015')
    TRADING_DAYS_PER_YEAR = 252

    def __init__(self):
        self.start_date: date = None
        self.end_date: date = None
        self.current_date: date = None
        self.initial_capital = Decimal('0.0')
        self.cash_balance = Decimal('0.0')
        self.portfolio_history = []
        self.last_buy_trade_id = None
        self.original_db_config = None
    def _load_db_to_memory(self, source_db_path: str):
        """
        【优化版】使用 SQLite Backup API 高效地将磁盘数据库加载到内存。
        """
        logger.info(f"开始将数据从 {source_db_path} 加载到内存 (使用 Backup API)...")
        start_time = time.time()
        
        # 1. 创建一个到源文件数据库的直接连接 (只读)
        try:
            source_conn = sqlite3.connect(f'file:{source_db_path}?mode=ro', uri=True)
        except sqlite3.OperationalError as e:
            logger.error(f"无法以只读模式打开源数据库 {source_db_path}: {e}")
            raise
 
        # 2. 获取到Django管理的内存数据库的底层连接
        mem_conn = connections['default'].connection
 
        try:
            # 3. 【核心优化】使用 backup 方法
            #    它会以最有效的方式（通常是按数据页）将源数据库内容复制到目标数据库
            source_conn.backup(mem_conn)
            
            duration = time.time() - start_time
            logger.info(f"数据成功加载到内存数据库，耗时: {duration:.2f} 秒。")
 
        except Exception as e:
            logger.error(f"使用 Backup API 加载数据到内存时发生错误: {e}")
            raise
        finally:
            # 4. 关闭连接
            source_conn.close()
            # mem_conn 不需要我们手动关闭，Django会管理它
 
    def _setup_environment(self):
        """
        修正版：调整了操作顺序，先加载数据，再执行ORM操作。
        """
        logger.info("--- 1. 准备回测环境 (内存模式) ---")
        
        base_dir = settings.BASE_DIR
        source_db = os.path.join(base_dir, 'mainDB.sqlite3')
        
        # 1. 关闭所有现有连接
        connections.close_all()
        
        # 2. 保存原始配置，并将 'default' 数据库重定向到内存
        self.original_db_config = settings.DATABASES['default'].copy()
        settings.DATABASES['default']['NAME'] = ':memory:'
        logger.info("已将 'default' 数据库连接重定向到 :memory:")
 
        # 3. 确保Django建立到新内存数据库的连接
        #    这一步至关重要，它会创建一个空的内存数据库实例
        connections['default'].ensure_connection()
        
        # 4. 【核心修正】立即将磁盘数据加载到内存数据库中
        #    此时，内存数据库从空变成了 mainDB.sqlite3 的一个完整克隆
        self._load_db_to_memory(source_db)
 
        # 5. 【顺序调整】现在内存数据库是完整的了，可以安全地执行任何Django ORM操作
        

        #DailyFactorValues, DailyTradingPlan,
        # 清空回测过程中会产生数据的表
        tables_to_clear = [
             Position,
            TradeLog, SystemLog
        ]
        # 使用 transaction.atomic() 来保证操作的原子性
        with transaction.atomic():
            for model in tables_to_clear:
                # 现在 model.objects.all() 可以正常工作了
                model.objects.all().delete()
                logger.info(f"已清空表: {model._meta.db_table}")
 
        # 读取策略参数
        # 现在 StrategyParameters.objects.all() 也可以正常工作了
        params = {p.param_name: p.param_value for p in StrategyParameters.objects.all()}
        max_positions = int(params.get('MAX_POSITIONS', Decimal('5')))
        max_capital_per_pos = params.get('MAX_CAPITAL_PER_POSITION', Decimal('10000'))
        self.initial_capital = Decimal(max_positions) * max_capital_per_pos
        self.initial_capital=150000
        self.cash_balance = self.initial_capital
        logger.info(f"初始资金已设定为: {self.initial_capital:.2f}")
 
    def _cleanup_environment(self):
        """在回测结束后恢复原始数据库配置"""
        if self.original_db_config:
            connections.close_all()
            settings.DATABASES['default'] = self.original_db_config
            # 内存数据库的连接关闭后，其内容会自动销毁，无需手动删除文件
            logger.info("已恢复 'default' 数据库连接到原始配置，内存数据库已释放。")
    def _get_trading_days(self) -> list[date]:
        dates = DailyQuotes.objects.filter(
            trade_date__gte=self.start_date,
            trade_date__lte=self.end_date
        ).values_list('trade_date', flat=True).distinct().order_by('trade_date')
        return list(dates)

    def _calculate_daily_portfolio_value(self):
        open_positions = Position.objects.filter(status=Position.StatusChoices.OPEN)
        market_value = Decimal('0.0')
        for pos in open_positions:
            try:
                quote = DailyQuotes.objects.get(
                    stock_code_id=pos.stock_code_id,
                    trade_date=self.current_date
                )
                market_value += quote.close * pos.quantity
            except DailyQuotes.DoesNotExist:
                market_value += pos.entry_price * pos.quantity
        
        total_value = self.cash_balance + market_value
        self.portfolio_history.append({
            'date': self.current_date,
            'total_value': total_value
        })
        logger.info(f"--- 日终结算 ({self.current_date}) ---")
        logger.info(f"现金: {self.cash_balance:.2f}, 持仓市值: {market_value:.2f}, 总资产: {total_value:.2f}")

    def _calculate_performance_metrics(self) -> dict:
        logger.info("--- 4. 计算回测性能指标 ---")
        if not self.portfolio_history:
            return {}

        df = pd.DataFrame(self.portfolio_history)
        df['total_value'] = df['total_value'].astype(float)
        df['daily_return'] = df['total_value'].pct_change().fillna(0)
        
        final_value = float(df['total_value'].iloc[-1])
        total_return_amount = final_value - float(self.initial_capital)
        total_return_rate = (final_value / float(self.initial_capital)) - 1

        mean_daily_return = df['daily_return'].mean()
        std_daily_return = df['daily_return'].std()
        
        if std_daily_return == 0 or np.isnan(std_daily_return):
            sharpe_ratio = 0.0
        else:
            daily_risk_free_rate = (1 + self.ANNUAL_RISK_FREE_RATE) ** Decimal(1/self.TRADING_DAYS_PER_YEAR) - 1
            sharpe_ratio = (mean_daily_return - float(daily_risk_free_rate)) / std_daily_return
            sharpe_ratio *= np.sqrt(self.TRADING_DAYS_PER_YEAR)

        result = {
            'total_return_amount': round(total_return_amount, 2),
            'total_return_rate': round(total_return_rate, 4),
            'sharpe_ratio': round(float(sharpe_ratio), 4)
        }
        logger.info(f"回测结果: {result}")
        return result

    def run_backtest(self, start_date: str, end_date: str) -> dict:
        try:
            self.start_date = date.fromisoformat(start_date)
            self.end_date = date.fromisoformat(end_date)

            self._setup_environment()

            handler = SimulateTradeHandler(self)
            
            trading_days = self._get_trading_days()
            if not trading_days:
                logger.error("在指定日期范围内未找到任何交易日，回测终止。")
                return {}

            baseline_date = trading_days[0] - timedelta(days=1)
            self.portfolio_history.append({'date': baseline_date, 'total_value': self.initial_capital})

            logger.info(f"--- 2. 开始日度回测循环 ({len(trading_days)}天) ---")
            for i, current_day in enumerate(trading_days):
                self.current_date = current_day
                logger.info(f"\n{'='*20} 模拟日: {self.current_date} ({i+1}/{len(trading_days)}) {'='*20}")

                prev_trading_day = trading_days[i-1] if i > 0 else None
                if prev_trading_day:
                    logger.info(f"-> [T-1 选股] 基于 {prev_trading_day} 的数据...")
                    selection_service = SelectionService(trade_date=prev_trading_day, mode='backtest')
                    selection_service.run_selection()

                logger.info("-> [T日 盘前校准] ...")
                before_fix_service = BeforeFixService(execution_date=self.current_date)
                before_fix_service.run()
                
                dividend_events = CorporateAction.objects.filter(
                    ex_dividend_date=self.current_date, event_type=CorporateAction.EventType.DIVIDEND
                )
                # 按股票代码分组，提高效率
                events_by_stock = {}
                for event in dividend_events:
                    events_by_stock.setdefault(event.stock_code, []).append(event)

                if events_by_stock:
                    # 获取所有可能受影响的持仓
                    open_positions_for_dividend = Position.objects.filter(
                        stock_code_id__in=events_by_stock.keys(),
                        status=Position.StatusChoices.OPEN
                    )
                    
                    for pos in open_positions_for_dividend:
                        # 找到该股票对应的所有分红事件（通常只有一个）
                        stock_events = events_by_stock.get(pos.stock_code_id, [])
                        for event in stock_events:
                            dividend_amount = event.dividend_per_share * pos.quantity
                            self.cash_balance += dividend_amount
                            logger.info(f"除息事件: 持仓ID {pos.position_id} ({pos.stock_code_id}) 获得分红 {dividend_amount:.2f}，现金余额更新为 {self.cash_balance:.2f}")



                logger.info("-> [T日 开盘决策与买入] ...")
                decision_order_service = DecisionOrderService(handler=handler, execution_date=self.current_date)
                decision_order_service.adjust_trading_plan_daily()
                
                while True:
                    open_positions_count = Position.objects.filter(status=Position.StatusChoices.OPEN).count()
                    max_pos = decision_order_service.current_max_positions
                    if open_positions_count >= max_pos:
                        break
                    
                    self.last_buy_trade_id = None
                    decision_order_service.execute_orders()
                    
                    if self.last_buy_trade_id:
                        decision_order_service.calculate_stop_profit_loss(self.last_buy_trade_id)
                    else:
                        break

                # 关键修复：在循环内实例化 MonitorExitService 并传入日期
                monitor_exit_service = MonitorExitService(handler=handler, execution_date=self.current_date)

                logger.info("-> [T日 盘中监控] 模拟价格跌至最低点...")
                handler.current_price_node = 'LOW'
                monitor_exit_service.monitor_and_exit_positions()

                logger.info("-> [T日 盘中监控] 模拟价格涨至最高点...")
                handler.current_price_node = 'HIGH'
                monitor_exit_service.monitor_and_exit_positions()

                self._calculate_daily_portfolio_value()

            logger.info("--- 3. 回测循环结束 ---")
            return self._calculate_performance_metrics()
        
        finally:
            # 确保无论成功还是失败，都清理环境
            self._cleanup_environment()

####文件结束####

####trade_manager\service\trade_handler.py####
# trade_manager/service/trade_handler.py

from abc import ABC, abstractmethod
from decimal import Decimal
from django.db import transaction
from django.utils import timezone
# 为了类型提示，我们可以从 common.models 导入 Position 和 TradeLog
# 注意：为了避免循环导入，通常在实现类中进行实际导入，这里仅为类型提示
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from common.models import Position, TradeLog



class ITradeHandler(ABC):
    """
    交易处理器抽象基类 (Abstract Base Class)。

    该接口定义了开盘决策与下单模块所需的所有外部交互行为。
    通过依赖此抽象接口而非具体实现，`DecisionOrderService` 可以与不同的
    交易环境（如真实交易接口、回测引擎）解耦。

    - 对于真实交易，实现类将通过API与券商服务器交互。
    - 对于回测，实现类将模拟这些交互，例如从历史数据中读取开盘价、
      模拟订单成交、并管理一个虚拟账户的余额。
    """

    @abstractmethod
    def get_opening_price(self, stock_code: str) -> Decimal:
        """
        获取指定股票在执行日的实际开盘价。

        :param stock_code: 股票代码，格式与 tb_stock_info 表一致 (如 'sh.600000')。
        :return: 当日的开盘价。如果无法获取（例如停牌），应引发异常或返回一个可识别的错误值（如Decimal('0.00')）。
        """
        pass

    @abstractmethod
    def place_buy_order(self, stock_code: str, price: Decimal, quantity: int) -> None:
        """
        提交一个买入订单。

        此方法的实现者负责处理与交易系统的所有交互。根据需求，此方法
        在执行时，需要完成以下数据库操作：
        1. 在 `tb_positions` 表中插入一条新的持仓记录，其中所有非空字段
           （如 current_stop_loss, current_take_profit）可使用哨兵值（如-1）填充，
           等待后续的止盈止损计算任务来更新。
        2. 在 `tb_trade_log` 表中插入一条对应的交易记录，初始状态应为
           'pending'。

        :param stock_code: 股票代码。
        :param price: 预期的买入限价。
        :param quantity: 计划买入的股数（必须是100的整数倍）。
        :return: 无返回值。
        """
        pass

    @abstractmethod
    def get_available_balance(self) -> Decimal:
        """
        查询当前账户的可用资金余额。

        :return: 可用于交易的现金余额。
        """
        pass

    
    @abstractmethod
    def get_realtime_price(self, stock_code: str) -> Decimal | None:
        """
        获取一只股票的实时价格。
 
        :param stock_code: 股票代码，格式如 'sh.600000'。
        :return: 该股票此时此刻的市场价 (Decimal类型)。如果获取失败（如网络问题、股票停牌），
                 应返回 None，以便调用方进行错误处理。
        """
        pass
 
    @abstractmethod
    def sell_stock_by_market_price(self, position: 'Position', reason: str) -> None:
        """
        以市价单全量卖出指定的持仓。
 
        此方法的具体实现需要完成一个原子性的操作流程：
        1. 调用交易API，以市价单卖出 `position.quantity` 数量的 `position.stock_code`。
        2. **在API调用成功返回成交回报后**，执行以下数据库操作：
           a. **更新持仓表 (tb_positions)**: 将传入的 `position` 对象的状态更新为 'closed'。
              `position.status = Position.StatusChoices.CLOSED`
              `position.save()`
           b. **插入交易记录 (tb_trade_log)**: 创建一条新的卖出记录。
              - `position`: 关联到此持仓。
              - `stock_code`: 股票代码。
              - `trade_datetime`: 交易的实际成交时间。
              - `trade_type`: 'sell'。
              - `order_type`: 'market'。
              - `quantity`: 实际成交数量。
              - `price`: 实际的成交均价。从成交回报中获取。如果无法立即获取，
                                            则使用 -1 作为占位符，等待后续任务回补。
              - `commission`, `stamp_duty`: 从成交回报中获取。如果无法立即获取，
                                            则使用 -1 作为占位符，等待后续任务回补。
              - `reason`: 使用传入的 `reason` 参数 ('take_profit' 或 'stop_loss')。
              - `status`: 'filled' (已成交)。
        3. 整个数据库更新过程应该被包裹在一个事务中 (`transaction.atomic`)，确保数据一致性。
 
        :param position: 要卖出的持仓对象 (common.models.positions.Position)。
                         该对象包含了持仓ID、股票代码、持仓数量等所有必要信息。
        :param reason: 卖出原因的字符串，如 'take_profit' 或 'stop_loss'。
                       这个值将用于填充交易记录表的 `reason` 字段。
        :return: 无返回值。如果执行失败（如API调用失败、股票跌停无法卖出），
                 应在方法内部处理异常（如记录日志），并向上层调用者（MonitorExitService）
                 抛出异常或通过其他方式通知失败，以便上层决定是否重试。
        """
        pass
####文件结束####
