======= 项目文件树 =======

📂 ./
    📄 .env
    📄 .env.example
    📄 config.json
    📄 manage.py
    📄 requirements.txt
    📄 restart.sh
    📄 trade_report.html
    📄 user.json
    📄 uwsgi.ini
    📄 交易变化.html
    📄 回测简单日志.txt
    📄 回测简单日志_v2.1.txt
    📄 回测简单日志_v2.2.txt
    📄 提取日志.py
    📄 日志分析提示词.txt
    📄 测试akshare.py
    📄 测试easytrader.py
    📄 资金变化图.png
    📂 autoTrade/
        📄 __init__.py
        📄 asgi.py
        📄 settings.py
        📄 urls.py
        📄 wsgi.py
    📂 common/
        📄 __init__.py
        📄 admin.py
        📄 apps.py
        📄 config_loader.py
        📄 tests.py
        📄 views.py
        📂 models/
            📄 __init__.py
            📄 backtest_logs.py
            📄 corporate_action.py
            📄 daily_factor_values.py
            📄 daily_quotes.py
            📄 daily_trading_plan.py
            📄 factor_definitions.py
            📄 positions.py
            📄 stock_info.py
            📄 strategy_parameters.py
            📄 system_log.py
            📄 trade_log.py
    📂 data_manager/
        📄 __init__.py
        📄 admin.py
        📄 apps.py
        📄 models.py
        📄 tests.py
        📄 urls.py
        📄 views.py
        📂 management/
            📂 commands/
                📄 full_update_stocks.py
                📄 migrate_to_pg.py
                📄 reset_sequences.py
        📂 service/
            📄 corporate_action_service.py
            📄 db_service.py
            📄 email_handler.py
            📄 email_service.py
            📄 stock_service.py
    📂 logs/
        📄 .__django.lock
        📄 django.log
    📂 selection_manager/
        📄 __init__.py
        📄 admin.py
        📄 apps.py
        📄 models.py
        📄 tests.py
        📄 urls.py
        📄 views.py
        📂 management/
            📂 commands/
                📄 prime_market_regime_cache.py
        📂 service/
            📄 selection_service.py
            📄 selection_service.py.old_v1
    📂 trade_manager/
        📄 __init__.py
        📄 admin.py
        📄 apps.py
        📄 models.py
        📄 tests.py
        📄 urls.py
        📄 views.py
        📂 management/
            📂 commands/
                📄 run_backtest.py
                📄 run_scheduler.py
        📂 service/
            📄 backtest_reporter.py
            📄 before_fix_service.py
            📄 db_utils.py
            📄 decision_order_service.py
            📄 decision_order_service_old.py
            📄 monitor_exit_service.py
            📄 real_trade_handler.py
            📄 scheduler_service.py
            📄 simulate_trade.py
            📄 simulate_trade_handler.py
            📄 simulate_trade_old.py
            📄 trade_handler.py

========================

======= Python文件内容 =======

####manage.py####
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys
import dotenv

def main():
    """Run administrative tasks."""
    dotenv.load_dotenv()
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'autoTrade.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()

####文件结束####

####提取日志.py####
import re
import html
import matplotlib.pyplot as plt
from collections import defaultdict
import os

# ==============================================================================
# 配置区域
# ==============================================================================
LOG_FILE_PATH = '回测简单日志.txt'
PLOT_OUTPUT_PATH = '资金变化图.png'
HTML_REPORT_PATH = '交易变化.html'


# ==============================================================================
# 1. 日志解析
# ==============================================================================
def parse_log_file(file_path):
    """
    解析日志文件，提取绘图和报告所需的数据。
    """
    # 用于存储每日资产
    asset_dates = []
    asset_values = []
    
    # 用于存储每日的日志块
    daily_logs = []
    
    # 用于计算每支股票的盈亏
    # 结构: {'sz.002364': {'spent': 1000, 'received': 1100, 'dividends': 10, 'name': '中恒电气'}}
    stock_profits = defaultdict(lambda: {'spent': 0, 'received': 0, 'dividends': 0, 'name': ''})

    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            current_day_block = None
            for line in f:
                line = line.strip()
                if not line:
                    continue

                # 匹配新的一天
                day_match = re.search(r"模拟日: ([\d-]+)", line)
                if day_match:
                    if current_day_block:
                        daily_logs.append(current_day_block)
                    date_str = day_match.group(1)
                    current_day_block = {'date': date_str, 'logs': [line]}
                    continue
                
                if not current_day_block:
                    continue

                current_day_block['logs'].append(line)

                # 匹配总资产
                asset_match = re.search(r"总资产: ([\d.]+)", line)
                if asset_match:
                    asset_dates.append(current_day_block['date'])
                    asset_values.append(float(asset_match.group(1)))

                # 匹配买入操作
                buy_match = re.search(r"买入 (.+?)\((.+?)\).*?花费: ([\d.]+)", line)
                if buy_match:
                    name, code, cost = buy_match.groups()
                    stock_profits[code]['spent'] += float(cost)
                    if not stock_profits[code]['name']: # 首次记录股票名称
                        stock_profits[code]['name'] = name

                # 匹配卖出操作
                sell_match = re.search(r"卖出 (.+?) .*?收入: ([\d.]+)", line)
                if sell_match:
                    code, income = sell_match.groups()
                    stock_profits[code]['received'] += float(income)

                # 匹配分红事件
                dividend_match = re.search(r"持仓ID \d+ \((.+?)\) 获得分红 ([\d.]+)", line)
                if dividend_match:
                    code, dividend = dividend_match.groups()
                    stock_profits[code]['dividends'] += float(dividend)


            if current_day_block: # 添加最后一天的数据
                daily_logs.append(current_day_block)

    except FileNotFoundError:
        print(f"错误: 日志文件 '{file_path}' 未找到。")
        return None, None, None, None
    
    return asset_dates, asset_values, daily_logs, stock_profits

# ==============================================================================
# 2. 生成资金曲线图
# ==============================================================================
def generate_asset_plot(dates, assets, output_path):
    """
    使用matplotlib生成资金曲线图并保存。
    """
    if not dates or not assets:
        print("没有足够的资产数据来生成图表。")
        return

    print("正在生成资金变化图...")
    
    # 设置中文字体，以防乱码
    plt.rcParams['font.sans-serif'] = ['SimHei', 'Microsoft YaHei']
    plt.rcParams['axes.unicode_minus'] = False

    # 创建一个较大尺寸的图形
    fig, ax = plt.subplots(figsize=(18, 9))

    ax.plot(dates, assets, marker='.', linestyle='-', color='b')

    # 设置图表标题和标签
    ax.set_title('策略回测资金曲线', fontsize=20)
    ax.set_xlabel('模拟日期', fontsize=14)
    ax.set_ylabel('总资产 (元)', fontsize=14)
    ax.grid(True, linestyle='--', alpha=0.6)

    # 自动调整x轴标签以避免重叠
    fig.autofmt_xdate(rotation=45)
    
    # 格式化y轴为货币格式
    ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: format(int(x), ',')))

    # 确保布局紧凑，所有元素都可见
    plt.tight_layout()

    # 保存图表
    plt.savefig(output_path, dpi=150)
    plt.close()
    print(f"资金变化图已成功保存到: {output_path}")

# ==============================================================================
# 3. 生成HTML报告
# ==============================================================================
def generate_html_report(daily_logs, stock_profits, output_path):
    """
    生成包含高亮日志和盈亏汇总的HTML报告。
    """
    if not daily_logs or not stock_profits:
        print("没有足够的数据来生成HTML报告。")
        return
        
    print("正在生成HTML报告...")

    # --- 计算并排序股票盈亏 ---
    profit_summary = []
    for code, data in stock_profits.items():
        total_profit = data['received'] + data['dividends'] - data['spent']
        profit_summary.append({
            'code': code,
            'name': data['name'] or '未知名称',
            'profit': total_profit
        })
    
    # 从大到小排序
    sorted_profits = sorted(profit_summary, key=lambda x: x['profit'], reverse=True)

    # --- 构建HTML内容 ---
    html_content = """
    <!DOCTYPE html>
    <html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
        <title>回测交易日志报告</title>
        <style>
            body { font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif; line-height: 1.6; margin: 20px; background-color: #f4f4f4; color: #333; }
            h1, h2 { color: #0056b3; border-bottom: 2px solid #0056b3; padding-bottom: 10px; }
            .container { max-width: 1200px; margin: auto; background: #fff; padding: 20px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
            .summary-table { width: 100%; border-collapse: collapse; margin-bottom: 30px; }
            .summary-table th, .summary-table td { border: 1px solid #ddd; padding: 12px; text-align: left; }
            .summary-table th { background-color: #007bff; color: white; }
            .summary-table tr:nth-child(even) { background-color: #f2f2f2; }
            .profit { color: #d9534f; } /* 红色 */
            .loss { color: #5cb85c; } /* 绿色 */
            .day-block { border: 1px solid #ccc; border-radius: 5px; margin-bottom: 20px; padding: 15px; background-color: #fafafa; }
            .day-block h3 { margin-top: 0; color: #555; }
            .log-entry { font-family: 'Courier New', Courier, monospace; white-space: pre-wrap; word-wrap: break-word; }
            .log-profit-sell { color: #d9534f; font-weight: bold; } /* 止盈卖出 - 红色 */
            .log-stop-loss { color: #5cb85c; font-weight: bold; } /* 止损卖出 - 绿色 */
        </style>
    </head>
    <body>
        <div class="container">
            <h1>回测交易日志报告</h1>
            
            <h2>各股盈亏汇总 (从高到低)</h2>
            <table class="summary-table">
                <thead>
                    <tr>
                        <th>排名</th>
                        <th>股票名称</th>
                        <th>股票代码</th>
                        <th>总盈亏 (元)</th>
                    </tr>
                </thead>
                <tbody>
    """

    # 填充盈亏汇总表格
    for i, item in enumerate(sorted_profits):
        profit_class = 'profit' if item['profit'] >= 0 else 'loss'
        html_content += f"""
                    <tr>
                        <td>{i + 1}</td>
                        <td>{html.escape(item['name'])}</td>
                        <td>{html.escape(item['code'])}</td>
                        <td class="{profit_class}">{item['profit']:.2f}</td>
                    </tr>
        """
    
    html_content += """
                </tbody>
            </table>

            <h2>详细日志记录</h2>
    """

    # 填充详细日志
    for day in daily_logs:
        html_content += f"""
            <div class="day-block">
                <h3>{html.escape(day['date'])}</h3>
                <div class="log-entry">
        """
        for log_line in day['logs']:
            escaped_line = html.escape(log_line)
            if '触发止盈' in log_line or '止盈卖出' in log_line:
                html_content += f'<span class="log-profit-sell">{escaped_line}</span>\n'
            elif '触发止损' in log_line or '止损卖出' in log_line:
                html_content += f'<span class="log-stop-loss">{escaped_line}</span>\n'
            else:
                html_content += f'{escaped_line}\n'
        html_content += """
                </div>
            </div>
        """

    html_content += """
        </div>
    </body>
    </html>
    """

    # 写入文件
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(html_content)
    print(f"HTML报告已成功保存到: {output_path}")

# ==============================================================================
# 主执行函数
# ==============================================================================
def main():
    """主函数，协调所有操作。"""
    print("开始处理回测日志...")
    symbol=['==================== 模拟日','触发','[回测] 卖出',' [回测] 买入','总资产: ','获得分红','风控价格','M(t)','确定唯一买入标的']
    log_prefix_pattern = re.compile(r"^[A-Z]+\s+[\d\-\s:,]+\s+\w+\s+\d+\s+\d+\s+(.*)")
 
    clean_log_content = []
    
    # 使用 'with' 语句能更好地处理文件，并且更安全
    # 注意：如果你的原始日志文件不是gbk编码，请修改这里的 encoding
    try:
        with open('logs/django.log', "r", encoding="gbk") as f:
            for line in f:
                # 检查该行是否包含我们关心的关键字
                should_keep = False
                for keyword in symbol:
                    if keyword in line:
                        should_keep = True
                        break
                
                if should_keep:
                    # 去掉行首行尾的空白字符
                    stripped_line = line.strip()
                    
                    # 尝试用正则表达式匹配并去除前缀
                    match = log_prefix_pattern.match(stripped_line)
                    if match:
                        # 如果匹配成功，只取括号里捕获的内容 (核心日志)
                        clean_line = match.group(1)
                    else:
                        # 如果不匹配 (比如 "==== 模拟日..." 这种行)，就保留原样
                        clean_line = stripped_line
                    
                    clean_log_content.append(clean_line)
    except FileNotFoundError:
        print("错误: 原始日志文件 'logs/django.log' 未找到。")
        return
    except Exception as e:
        print(f"读取原始日志时发生错误: {e}")
        return
 
    # 将处理过的、干净的日志内容写入到简单日志文件中
    with open(LOG_FILE_PATH, 'w', encoding='utf-8') as f:
        f.write('\n'.join(clean_log_content))

    # 1. 解析日志
    asset_dates, asset_values, daily_logs, stock_profits = parse_log_file(LOG_FILE_PATH)

    if asset_dates is None: # 如果解析失败
        print("日志处理终止。")
        return

    # 2. 生成图表
    generate_asset_plot(asset_dates, asset_values, PLOT_OUTPUT_PATH)

    # 3. 生成HTML报告
    generate_html_report(daily_logs, stock_profits, HTML_REPORT_PATH)
    
    print("\n所有任务完成！")
    print(f" - 图表文件: {os.path.abspath(PLOT_OUTPUT_PATH)}")
    print(f" - 报告文件: {os.path.abspath(HTML_REPORT_PATH)}")


if __name__ == '__main__':
    main()
main()
####文件结束####

####测试akshare.py####
import akshare as ak
index_zh_a_hist_df = ak.index_zh_a_hist(symbol="000300", period="daily", start_date="20180101", end_date="20250815")
print(index_zh_a_hist_df)
####文件结束####

####测试easytrader.py####
import easytrader
import json
f=open('config.json','r',encoding='utf-8')
t=""
for line in f:
    line = line.strip()
    t=t+line
    if not line:
        continue
f.close()
config=json.loads(t)
print(config)
user = easytrader.use('ht_client')
user.connect(config['easytrader']['client_path'])
user.prepare(config['easytrader']['user'])
user.refresh()
print(user.balance)
user.exit()
####文件结束####

####遍历文件.py####
import os

# --- 配置 ---
# 要扫描的根目录，'.' 表示当前目录
ROOT_DIR = '.'
# 输出文件名
OUTPUT_FILE = 'result.txt'
# 要忽略的目录（使用集合以提高查找效率）
IGNORE_DIRS = {'.git', '__pycache__', 'venv', '.vscode', 'node_modules','migrations'}
# 要忽略的文件
IGNORE_FILES = {'.DS_Store', OUTPUT_FILE,'遍历文件.py'} # 确保不把输出文件本身包含进去

def generate_file_tree(root_dir, ignore_dirs, ignore_files):
    """生成项目文件树结构"""
    tree_lines = []
    for root, dirs, files in os.walk(root_dir, topdown=True):
        # 在遍历前，从dirs列表中移除要忽略的目录
        dirs[:] = [d for d in dirs if d not in ignore_dirs]
        
        # 计算当前深度，用于生成前缀
        level = root.replace(root_dir, '').count(os.sep)
        indent = ' ' * 4 * level
        
        # 添加目录名到树
        # os.path.basename(root) 用于获取当前目录名
        tree_lines.append(f"{indent}📂 {os.path.basename(root)}/")

        # 添加文件到树
        sub_indent = ' ' * 4 * (level + 1)
        for f in sorted(files): # 对文件进行排序
            if f not in ignore_files:
                tree_lines.append(f"{sub_indent}📄 {f}")
                
    return "\n".join(tree_lines)

def get_python_file_contents(root_dir, ignore_dirs):
    """获取所有.py文件的内容并格式化"""
    py_contents = []
    for root, dirs, files in os.walk(root_dir, topdown=True):
        # 同样，忽略指定目录
        dirs[:] = [d for d in dirs if d not in ignore_dirs]
        
        for file in sorted(files):
            if file.endswith('.py'):
                file_path = os.path.join(root, file)
                # 使用相对路径，让输出更清晰
                relative_path = os.path.relpath(file_path, root_dir)
                
                header = f"####{relative_path}####"
                footer = "####文件结束####"
                
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                    py_contents.append(f"{header}\n{content}\n{footer}\n")
                except Exception as e:
                    py_contents.append(f"{header}\n无法读取文件内容: {e}\n{footer}\n")
                    
    return "\n".join(py_contents)

def main():
    """主函数，执行所有操作"""
    print("开始生成项目文件树...")
    file_tree = generate_file_tree(ROOT_DIR, IGNORE_DIRS, IGNORE_FILES)
    
    print("开始读取所有.py文件内容...")
    python_contents = get_python_file_contents(ROOT_DIR, IGNORE_DIRS)
    
    print(f"正在将结果写入 {OUTPUT_FILE}...")
    
    # 将所有内容合并写入文件
    with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
        f.write("======= 项目文件树 =======\n\n")
        f.write(file_tree)
        f.write("\n\n========================\n\n")
        f.write("======= Python文件内容 =======\n\n")
        f.write(python_contents)
        
    print(f"✅ 成功！项目结构和代码已保存到 {OUTPUT_FILE}")

if __name__ == '__main__':
    main()

####文件结束####

####autoTrade\__init__.py####

####文件结束####

####autoTrade\asgi.py####
"""
ASGI config for autoTrade project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'autoTrade.settings')

application = get_asgi_application()

####文件结束####

####autoTrade\settings.py####
"""
Django settings for autoTrade project.

Generated by 'django-admin startproject' using Django 5.2.4.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""

from pathlib import Path
import os
import dotenv
# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent
dotenv.load_dotenv(os.path.join(BASE_DIR, '.env'))


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!

# SECURITY WARNING: don't run with debug turned on in production!

SECRET_KEY = os.getenv('SECRET_KEY', 'default-secret-key-for-dev')
ENVIRONMENT = os.getenv('ENVIRONMENT', 'development')
DEBUG = (ENVIRONMENT == 'development')
if ENVIRONMENT == 'production':
    # 请将 'your_domain.com' 和服务器的公网/内网IP填入
    ALLOWED_HOSTS = ['your_domain.com', '1.15.100.196', '10.0.4.15','10.0.12.10','127.0.0.1','0.0.0.0']
else:
    ALLOWED_HOSTS = ['*']


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'data_manager',
    'selection_manager',
    'trade_manager',
    'common'
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    #'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'autoTrade.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'autoTrade.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.getenv('DB_NAME', 'maindb'),
        'USER': os.getenv('DB_USER', 'xyx'),
        'PASSWORD': os.getenv('DB_PASSWORD', 'xyx123'),
        'HOST': os.getenv('DB_HOST', 'localhost'), # 默认使用 localhost
        'PORT': os.getenv('DB_PORT', '5432'),
        'OPTIONS': {
            'keepalives': 1,
            'keepalives_idle': 60,
            'keepalives_interval': 10,
            'keepalives_count': 6,
        }
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'Asia/Shanghai'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'


LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,  # 不要禁用已存在的日志器，否则 Django 自带的日志会失效
    
    # 1. 定义日志格式
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
        'simple': {
            'format': '{levelname} {message}',
            'style': '{',
        },
    },
    
    # 2. 定义处理器 (日志去哪里)
    'handlers': {
        # 输出到控制台
        'console': {
            'level': 'DEBUG',  # 处理 DEBUG 及以上级别的日志
            'class': 'logging.StreamHandler',
            'formatter': 'verbose', # 使用 verbose 格式
        },
        # 输出到文件
        'file': {
            'level': 'DEBUG',  # 处理 INFO 及以上级别的日志
            'class': 'concurrent_log_handler.ConcurrentRotatingFileHandler',
            'filename': os.path.join(BASE_DIR, 'logs/django.log'), # 日志文件路径
            'maxBytes': 1024 * 1024 * 10,  # 5 MB
            'backupCount': 5, # 最多保留 5 个备份文件
            'formatter': 'verbose', # 使用 verbose 格式
        },
    },
    
    # 3. 定义记录器 (哪些日志需要处理)
    'loggers': {
        # Django 框架自身的日志
        'django': {
            'handlers': ['console', 'file'],
            'level': 'INFO',
            'propagate': True,
        },
        # 你自己应用的日志
        'data_manager': { # 这里使用你的 app 名称
            'handlers': ['console','file'],
            'level': 'DEBUG', # 在开发时设为 DEBUG，可以看到所有信息
            'propagate': False, # 不向上传递给 root logger
        },
        'selection_manager': { # 这里使用你的 app 名称
            'handlers': ['console','file'],
            'level': 'DEBUG', # 在开发时设为 DEBUG，可以看到所有信息
            'propagate': False, # 不向上传递给 root logger
        },
        'trade_manager': { # 这里使用你的 app 名称
            'handlers': ['console','file'],
            'level': 'DEBUG', # 在开发时设为 DEBUG，可以看到所有信息
            'propagate': False, # 不向上传递给 root logger
        },
        # 你可以为任何模块定义 logger
        'common': {
            'handlers': ['console', 'file'],
            'level': 'DEBUG',
            'propagate': False,
        },
        # --- 新增日志清理配置 ---
        'sqlalchemy.engine': {
            'handlers': ['console', 'file'],
            'level': 'WARNING',  # <-- 只显示 WARNING 及以上级别的日志，过滤掉SQL语句
            'propagate': False,
        },
        'psycopg2': {
            'handlers': ['console', 'file'],
            'level': 'WARNING',  # <-- 过滤掉 psycopg2 的低级别日志
            'propagate': False,
        },
        'apscheduler': {
            'handlers': ['console', 'file'],
            'level': 'WARNING', # <-- 过滤掉 apscheduler 的 INFO 日志
            'propagate': False,
        }

    }
}
 
# 确保 logs 目录存在
LOGS_DIR = os.path.join(BASE_DIR, 'logs')
if not os.path.exists(LOGS_DIR):
    os.makedirs(LOGS_DIR)
####文件结束####

####autoTrade\urls.py####
"""
URL configuration for autoTrade project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path,include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('dataManager/', include('data_manager.urls')),
    path('selectionManager/', include('selection_manager.urls')),
    path('tradeManager/', include('trade_manager.urls'))
]

####文件结束####

####autoTrade\wsgi.py####
"""
WSGI config for autoTrade project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'autoTrade.settings')

application = get_wsgi_application()

####文件结束####

####common\__init__.py####

####文件结束####

####common\admin.py####
# common/admin.py

from django.contrib import admin
from .models import (
    StockInfo, DailyQuotes, FactorDefinitions, DailyFactorValues,
    StrategyParameters, DailyTradingPlan, Position, TradeLog,
    SystemLog, CorporateAction
)

# -----------------------------------------------------------------------------
# 1. 基础数据管理 (股票信息、行情、股权事件)
# -----------------------------------------------------------------------------

@admin.register(StockInfo)
class StockInfoAdmin(admin.ModelAdmin):
    """股票基础信息管理"""
    list_display = ('stock_code', 'stock_name', 'listing_date', 'status', 'updated_at')
    search_fields = ('stock_code', 'stock_name')
    list_filter = ('status', 'listing_date')
    ordering = ('stock_code',)
    readonly_fields = ('created_at', 'updated_at')

@admin.register(DailyQuotes)
class DailyQuotesAdmin(admin.ModelAdmin):
    """日线行情管理"""
    list_display = ('trade_date', 'stock_code', 'open', 'close', 'volume', 'turnover', 'hfq_close')
    search_fields = ('stock_code__stock_code', 'stock_code__stock_name')
    list_filter = ('trade_date',)
    ordering = ('-trade_date', 'stock_code')
    # 关键性能优化：对于有成千上万条记录的外键，使用 raw_id_fields 替代下拉框
    raw_id_fields = ('stock_code',)
    readonly_fields = ('hfq_close',)
    list_per_page = 25 # 设置每页显示条数

class CorporateActionAdmin(admin.ModelAdmin):
    """股权事件管理"""
    list_display = ('ex_dividend_date', 'stock_code', 'event_type', 'dividend_per_share', 'shares_before', 'shares_after', 'rights_issue_price')
    # 修正：直接搜索本表的 stock_code 字段即可
    search_fields = ('stock_code',) 
    list_filter = ('event_type', 'ex_dividend_date')
    ordering = ('-ex_dividend_date', 'stock_code')
    # raw_id_fields = ('stock_code',)

# -----------------------------------------------------------------------------
# 2. 策略与因子定义管理
# -----------------------------------------------------------------------------

@admin.register(FactorDefinitions)
class FactorDefinitionsAdmin(admin.ModelAdmin):
    """因子定义管理"""
    list_display = ('factor_code', 'factor_name', 'direction', 'is_active', 'description')
    search_fields = ('factor_code', 'factor_name')
    list_filter = ('direction', 'is_active')
    ordering = ('factor_code',)

@admin.register(StrategyParameters)
class StrategyParametersAdmin(admin.ModelAdmin):
    """策略参数管理"""
    list_display = ('param_name', 'param_value', 'group_name', 'description')
    search_fields = ('param_name', 'group_name')
    list_filter = ('group_name',)
    ordering = ('group_name', 'param_name')
    # 核心功能：允许在列表页直接编辑参数值，非常方便调参
    list_editable = ('param_value',)

@admin.register(DailyFactorValues)
class DailyFactorValuesAdmin(admin.ModelAdmin):
    """每日因子值管理"""
    list_display = ('trade_date', 'stock_code', 'factor_code', 'raw_value', 'norm_score')
    search_fields = ('stock_code__stock_code', 'factor_code__factor_code')
    list_filter = ('trade_date', 'factor_code')
    ordering = ('-trade_date', 'stock_code')
    # 关键性能优化
    raw_id_fields = ('stock_code', 'factor_code')
    list_per_page = 25

# -----------------------------------------------------------------------------
# 3. 交易流程管理 (预案、持仓、记录)
# -----------------------------------------------------------------------------

@admin.register(DailyTradingPlan)
class DailyTradingPlanAdmin(admin.ModelAdmin):
    """每日交易预案管理"""
    list_display = ('plan_date', 'stock_code', 'rank', 'final_score', 'miop', 'maop', 'status')
    search_fields = ('stock_code__stock_code',)
    list_filter = ('plan_date', 'status')
    ordering = ('-plan_date', 'rank')
    raw_id_fields = ('stock_code',)
    list_per_page = 20

@admin.register(Position)
class PositionAdmin(admin.ModelAdmin):
    """持仓信息管理"""
    list_display = ('position_id', 'stock_code', 'entry_datetime', 'entry_price', 'quantity', 'current_stop_loss', 'current_take_profit', 'status')
    search_fields = ('stock_code__stock_code',)
    list_filter = ('status', 'entry_datetime')
    ordering = ('-entry_datetime',)
    raw_id_fields = ('stock_code',)

@admin.register(TradeLog)
class TradeLogAdmin(admin.ModelAdmin):
    """交易记录管理"""
    list_display = ('trade_id', 'position', 'stock_code', 'trade_datetime', 'trade_type', 'price', 'quantity', 'reason', 'status')
    search_fields = ('stock_code__stock_code', 'position__position_id')
    list_filter = ('trade_type', 'status', 'reason', 'trade_datetime')
    ordering = ('-trade_datetime',)
    raw_id_fields = ('position', 'stock_code')
    list_per_page = 25

# -----------------------------------------------------------------------------
# 4. 系统与日志管理
# -----------------------------------------------------------------------------

@admin.register(SystemLog)
class SystemLogAdmin(admin.ModelAdmin):
    """系统日志管理"""
    list_display = ('log_time', 'log_level', 'module_name', 'message_summary')
    list_filter = ('log_level', 'module_name', 'log_time')
    search_fields = ('message', 'module_name')
    ordering = ('-log_time',)
    # 日志应该是不可变的，所以设为只读
    readonly_fields = ('log_time', 'log_level', 'module_name', 'message')
    list_per_page = 30

    def message_summary(self, obj):
        """在列表页显示截断的日志信息"""
        return (obj.message[:80] + '...') if len(obj.message) > 80 else obj.message
    message_summary.short_description = '日志摘要'

    def has_add_permission(self, request):
        # 禁止在Admin后台手动添加日志
        return False

    def has_change_permission(self, request, obj=None):
        # 禁止在Admin后台修改日志
        return False

####文件结束####

####common\apps.py####
from django.apps import AppConfig


class CommonConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'common'

####文件结束####

####common\config_loader.py####
# common/config_loader.py

import json
import os
import logging
from django.conf import settings

logger = logging.getLogger(__name__)

class ConfigLoader:
    _instance = None
    _config = None

    def __new__(cls):
        if not cls._instance:
            cls._instance = super(ConfigLoader, cls).__new__(cls)
        return cls._instance

    def __init__(self):
        if self._config is None:
            self._load_config()

    def _load_config(self):
        config_path = os.path.join(settings.BASE_DIR, 'config.json')
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                self._config = json.load(f)
            logger.info("ConfigLoader: config.json 加载成功。")
        except (FileNotFoundError, json.JSONDecodeError) as e:
            logger.critical(f"ConfigLoader: 无法加载或解析 config.json: {e}。系统将无法正常运行。")
            self._config = {} # 返回一个空字典以避免后续调用出错

    def get_config(self):
        """获取完整的配置字典"""
        return self._config

    def get(self, key, default=None):
        """获取指定键的配置值"""
        return self._config.get(key, default)

# 创建一个全局实例，供项目各处调用
config_loader = ConfigLoader()

####文件结束####

####common\tests.py####
from django.test import TestCase

# Create your tests here.

####文件结束####

####common\views.py####
from django.shortcuts import render

# Create your views here.

####文件结束####

####common\models\__init__.py####
# my_strategy_app/__init__.py

from .stock_info import StockInfo
from .daily_quotes import DailyQuotes
from .factor_definitions import FactorDefinitions
from .daily_factor_values import DailyFactorValues
from .strategy_parameters import StrategyParameters
from .daily_trading_plan import DailyTradingPlan
from .positions import Position
from .trade_log import TradeLog
from .system_log import SystemLog
from .corporate_action import CorporateAction

__all__ = [
    'StockInfo',
    'DailyQuotes',
    'FactorDefinitions',
    'DailyFactorValues',
    'StrategyParameters',
    'DailyTradingPlan',
    'Position',
    'TradeLog',
    'SystemLog',
    'CorporateAction'
]

####文件结束####

####common\models\backtest_logs.py####
# ==============================================================================
# 描述: 定义回测日志相关的新模型。
# ==============================================================================
from django.db import models

class BacktestDailyLog(models.Model):
    """
    回测每日日志表
    
    说明: 记录每一次回测运行中，每个交易日结束后的资金、持仓和市场状态。
    这张表用于生成资金曲线图和关键的回撤指标。
    """
    backtest_run_id = models.CharField(
        max_length=50,
        db_index=True,
        help_text="回测运行的唯一标识符, 如 'backtest_20231027_153000'"
    )
    trade_date = models.DateField(
        help_text="交易日期"
    )
    total_assets = models.DecimalField(
        max_digits=20,
        decimal_places=4,
        help_text="当日日终总资产 (现金 + 持仓市值)"
    )
    cash = models.DecimalField(
        max_digits=20,
        decimal_places=4,
        help_text="当日日终现金余额"
    )
    holdings_value = models.DecimalField(
        max_digits=20,
        decimal_places=4,
        help_text="当日日终持仓市值"
    )
    market_m_value = models.DecimalField(
        max_digits=18,
        decimal_places=10,
        null=True,
        blank=True,
        help_text="当日的市场状态M(t)值"
    )
    created_at = models.DateTimeField(
        auto_now_add=True,
        help_text="记录创建时间"
    )

    class Meta:
        db_table = 'tb_trade_manager_backtest_daily_log'
        verbose_name = '回测每日日志'
        verbose_name_plural = verbose_name
        ordering = ['backtest_run_id', 'trade_date']
        # 为常用查询添加索引
        indexes = [
            models.Index(fields=['backtest_run_id', 'trade_date']),
        ]

class BacktestOperationLog(models.Model):
    """
    回测操作记录表
    
    说明: 增量记录回测过程中的每一次买入和卖出操作。
    这张表用于计算胜率、收益贡献等交易层面的指标。
    """
    class Direction(models.TextChoices):
        BUY = 'BUY', '买入'
        SELL = 'SELL', '卖出'

    class ExitReason(models.TextChoices):
        TAKE_PROFIT = 'TAKE_PROFIT', '止盈'
        STOP_LOSS = 'STOP_LOSS', '止损'

    backtest_run_id = models.CharField(
        max_length=50,
        db_index=True,
        help_text="回测运行的唯一标识符"
    )
    position_id_ref = models.BigIntegerField(
        db_index=True,
        help_text="关联的持仓ID (tb_positions.position_id)，用于反查"
    )
    stock_code = models.CharField(
        max_length=50,
        help_text="股票代码, 如 'sh.600000'"
    )
    stock_name = models.CharField(
        max_length=50,
        help_text="股票名称"
    )
    trade_date = models.DateField(
        help_text="交易发生的日期"
    )
    direction = models.CharField(
        max_length=10,
        choices=Direction.choices,
        help_text="买卖方向"
    )
    exit_reason = models.CharField(
        max_length=20,
        choices=ExitReason.choices,
        null=True,
        blank=True,
        help_text="止盈/止损方向 (仅卖出时有效)"
    )
    profit_rate = models.DecimalField(
        max_digits=10,
        decimal_places=4,
        null=True,
        blank=True,
        help_text="该笔交易设置的止盈率"
    )
    loss_rate = models.DecimalField(
        max_digits=10,
        decimal_places=4,
        null=True,
        blank=True,
        help_text="该笔交易设置的止损率"
    )
    buy_date_m_value = models.DecimalField(
        max_digits=18,
        decimal_places=10,
        null=True,
        blank=True,
        help_text="买入决策所依据的T-1日市场M(t)值"
    )
    factor_scores = models.TextField(
        help_text="买入时各因子得分, 格式: factor1:score1|factor2:score2"
    )
    price = models.DecimalField(
        max_digits=10,
        decimal_places=2,
        help_text="成交价格"
    )
    quantity = models.BigIntegerField(
        help_text="成交数量"
    )
    amount = models.DecimalField(
        max_digits=20,
        decimal_places=4,
        help_text="成交总金额"
    )
    created_at = models.DateTimeField(
        auto_now_add=True,
        help_text="记录创建时间"
    )

    class Meta:
        db_table = 'tb_trade_manager_backtest_operation_log'
        verbose_name = '回测操作记录'
        verbose_name_plural = verbose_name
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['backtest_run_id', 'stock_code']),
            models.Index(fields=['backtest_run_id', 'position_id_ref']),
        ]


####文件结束####

####common\models\corporate_action.py####
from django.db import models

class CorporateAction(models.Model):
    """
    股权事件表 (tb_corporate_actions)
    
    说明: 存储所有影响股价非交易性变动的股权事件，是盘前校准模块和回测引擎的核心数据源。
    
    例子:
    10送5：event_type='bonus', shares_before=10, shares_after=15
    10转3：event_type='transfer', shares_before=10, shares_after=13
    10配3，配股价8元：event_type='rights', shares_before=10, shares_after=13, rights_issue_price=8
    1拆2：event_type='split', shares_before=1, shares_after=2 (理解为在1股基础上增加1股)
    10并1：event_type='split', shares_before=10, shares_after=1 (理解为在10股基础上减少9股)
    派1元：event_type='dividend', dividend_per_share=0.1
    """

    # 使用 Django 推荐的 TextChoices 来定义事件类型的枚举
    class EventType(models.TextChoices):
        DIVIDEND = 'dividend', '分红'
        BONUS = 'bonus', '送股'
        TRANSFER = 'transfer', '转股'
        RIGHTS = 'rights', '配股'
        SPLIT = 'split', '拆股/并股'

    # 字段定义
    event_id = models.BigAutoField(
        primary_key=True,
        help_text="事件唯一ID"
    )
    stock_code = models.CharField(
        max_length=50,
        null=False,
        blank=False,
        help_text="股票代码, 格式如 'sh.600000'"
    )
    ex_dividend_date = models.DateField(
        null=False,
        db_index=True,
        help_text="除权除息日 (策略判断的基准日期)，对于配股来说，实际为股权登记日而非除权日"
    )
    record_date = models.DateField(
        null=True,
        blank=True,
        help_text="股权登记日"
    )
    notice_date = models.DateField(
        null=True,
        blank=True,
        help_text="公告日期"
    )
    event_type = models.CharField(
        max_length=20,
        choices=EventType.choices,
        null=False,
        blank=False,
        help_text="事件类型。枚举: dividend(分红), bonus(送股), transfer(转股),rights(配股), split(拆股/并股)"
    )
    dividend_per_share = models.DecimalField(
        max_digits=10,
        decimal_places=4,
        null=True,
        blank=True,
        help_text="每股派息(税前, 元，分红专用)"
    )
    shares_before = models.DecimalField(
        max_digits=10,
        decimal_places=4,
        null=True,
        blank=True,
        help_text="基准股数 (如“10送5”，此值为10，送股/转股/拆股/并股专用)"
    )
    shares_after = models.DecimalField(
        max_digits=10,
        decimal_places=4,
        null=True,
        blank=True,
        help_text="变动股数 (如“10送5”，此值为15，送股/转股/拆股/并股专用)"
    )
    rights_issue_price = models.DecimalField(
        max_digits=10,
        decimal_places=2,
        null=True,
        blank=True,
        help_text="配股价格，配股专用"
    )
    created_at = models.DateTimeField(
        auto_now_add=True,
        null=False,
        help_text="记录创建时间"
    )

    class Meta:
        # 显式指定数据库中的表名
        db_table = 'tb_corporate_actions'
        # 在 Django Admin 中显示的名称
        verbose_name = '股权事件'
        verbose_name_plural = '股权事件'
        # 默认排序规则
        ordering = ['-ex_dividend_date', 'stock_code']

    def __str__(self):
        # 提供一个易于阅读的对象表示形式
        return f"{self.stock_code} on {self.ex_dividend_date}: {self.get_event_type_display()}"


####文件结束####

####common\models\daily_factor_values.py####
from django.db import models
from .stock_info import StockInfo
from .factor_definitions import FactorDefinitions

class DailyFactorValues(models.Model):
    """
    2.2. 每日因子值表 (tb_daily_factor_values)
    说明: (核心设计) 存储每只股票在每个交易日计算出的所有因子原始值和标准化分值。
    """
    stock_code = models.ForeignKey(
        StockInfo, 
        on_delete=models.CASCADE, 
        db_column='stock_code',
        help_text="股票代码"
    )
    trade_date = models.DateField(
        help_text="交易日期"
    )
    factor_code = models.ForeignKey(
        FactorDefinitions, 
        on_delete=models.CASCADE, 
        db_column='factor_code',
        help_text="因子代码"
    )
    raw_value = models.DecimalField(
        max_digits=20, 
        decimal_places=10, 
        help_text="因子计算出的原始值"
    )
    norm_score = models.DecimalField(
        max_digits=10, 
        decimal_places=4, 
        null=True, 
        blank=True,
        help_text="经过norm()函数标准化后的分值 (-100到100)"
    )

    def __str__(self):
        return f"{self.stock_code} - {self.factor_code} on {self.trade_date}"

    class Meta:
        db_table = 'tb_daily_factor_values'
        # 使用 unique_together 实现复合主键的唯一性约束
        unique_together = (('stock_code', 'trade_date', 'factor_code'),)
        verbose_name = '每日因子值'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\daily_quotes.py####
from django.db import models
from .stock_info import StockInfo

class DailyQuotes(models.Model):
    """
    1.2. 日线行情表 (tb_daily_quotes)
    说明: 存储从数据源获取的最原始的日线行情数据，是所有计算的基石。
    """
    stock_code = models.ForeignKey(
        StockInfo, 
        on_delete=models.CASCADE, 
        db_column='stock_code',
        help_text="股票代码"
    )
    trade_date = models.DateField(
        help_text="交易日期"
    )
    open = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="不复权开盘价"
    )
    high = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="不复权最高价"
    )
    low = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="不复权最低价"
    )
    close = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="不复权收盘价"
    )
    volume = models.BigIntegerField(
        help_text="成交量 (股)"
    )
    turnover = models.DecimalField(
        max_digits=20, 
        decimal_places=2, 
        help_text="成交额 (元)"
    )
    adjust_factor = models.DecimalField(
        max_digits=20, 
        decimal_places=10, 
        help_text="截至当日的后复权因子"
    )
    # (要求1) 计算列 hfq_close
    hfq_close = models.DecimalField(
        max_digits=20, 
        decimal_places=10, 
        editable=False,
        help_text="后复权收盘价，公式: close * adjust_factor"
    )

    def save(self, *args, **kwargs):
        # 在保存模型前计算 hfq_close 的值
        self.hfq_close = self.close * self.adjust_factor
        super().save(*args, **kwargs)

    def __str__(self):
        return f"{self.stock_code} on {self.trade_date}"

    class Meta:
        db_table = 'tb_daily_quotes'
        # 使用 unique_together 实现复合主键的唯一性约束
        unique_together = (('stock_code', 'trade_date'),)
        verbose_name = '日线行情'
        verbose_name_plural = verbose_name
        indexes = [
            models.Index(fields=['trade_date'], name='dailyquotes_tradedate_idx'), # <--- 在这里添加
        ]

####文件结束####

####common\models\daily_trading_plan.py####
from django.db import models
from .stock_info import StockInfo

class DailyTradingPlan(models.Model):
    """
    3.1. 每日交易预案表 (tb_daily_trading_plan)
    说明: 存储 T-1 日终选股模块生成的“次日观察池”及相关交易预案。
    """
    class StatusChoices(models.TextChoices):
        PENDING = 'pending', '待执行'
        EXECUTED = 'executed', '已执行买入'
        CANCELLED = 'cancelled', '当日未满足条件作废'

    plan_date = models.DateField(
        help_text="预案执行日期 (T日)"
    )
    stock_code = models.ForeignKey(
        StockInfo, 
        on_delete=models.CASCADE, 
        db_column='stock_code',
        help_text="候选股票代码"
    )
    rank = models.IntegerField(
        help_text="综合得分排名 (1-10)"
    )
    final_score = models.DecimalField(
        max_digits=10, 
        decimal_places=4, 
        help_text="f(x)选股综合得分"
    )
    miop = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="最低可接受开盘价 (Minimum Acceptable Open Price)"
    )
    maop = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="最高可接受开盘价 (Maximum Acceptable Open Price)"
    )
    status = models.CharField(
        max_length=20, 
        choices=StatusChoices.choices, 
        default=StatusChoices.PENDING,
        help_text="预案状态。枚举: pending(待执行), executed(已执行买入), cancelled(当日未满足条件作废)"
    )

    def __str__(self):
        return f"Plan for {self.stock_code} on {self.plan_date} (Rank: {self.rank})"

    class Meta:
        db_table = 'tb_daily_trading_plan'
        # 使用 unique_together 实现复合主键的唯一性约束
        unique_together = (('plan_date', 'stock_code'),)
        verbose_name = '每日交易预案'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\factor_definitions.py####
from django.db import models

class FactorDefinitions(models.Model):
    """
    2.1. 因子定义表 (tb_factor_definitions)
    说明: (核心设计) 用于定义所有策略中使用的因子，实现因子的可插拔。新增因子只需在此表增加一条记录。
    """
    class DirectionChoices(models.TextChoices):
        POSITIVE = 'positive', '正向, 值越大越好'
        NEGATIVE = 'negative', '负向, 值越小越好'

    factor_code = models.CharField(
        max_length=50, 
        primary_key=True, 
        help_text="因子唯一英文代码, 如 'MA20_SLOPE'"
    )
    factor_name = models.CharField(
        max_length=100, 
        help_text="因子中文名称, 如 '20日均线斜率'"
    )
    description = models.TextField(
        blank=True, 
        null=True, 
        help_text="详细描述因子的计算逻辑和业务含义"
    )
    direction = models.CharField(
        max_length=10, 
        choices=DirectionChoices.choices,
        help_text="因子方向性。枚举: positive(正向, 值越大越好), negative(负向, 值越小越好)"
    )
    is_active = models.BooleanField(
        default=True, 
        help_text="是否启用该因子"
    )

    def __str__(self):
        return f"{self.factor_name} ({self.factor_code})"

    class Meta:
        db_table = 'tb_factor_definitions'
        verbose_name = '因子定义'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\positions.py####
from django.db import models
from .stock_info import StockInfo

class Position(models.Model):
    """
    3.2. 持仓信息表 (tb_positions)
    说明: 存储当前所有持仓的详细信息，是盘中监控模块的核心数据依据。
    """
    class StatusChoices(models.TextChoices):
        OPEN = 'open', '持仓中'
        CLOSED = 'closed', '已平仓'

    position_id = models.BigAutoField(
        primary_key=True, 
        help_text="持仓唯一ID"
    )
    stock_code = models.ForeignKey(
        StockInfo, 
        on_delete=models.PROTECT, # 保护，防止意外删除关联股票信息
        db_column='stock_code',
        help_text="股票代码"
    )
    entry_datetime = models.DateTimeField(
        help_text="建仓成交时间"
    )
    entry_price = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="实际成交均价 (AEP)"
    )
    quantity = models.BigIntegerField(
        help_text="持仓数量 (股)"
    )
    current_stop_loss = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="当前止损价"
    )
    current_take_profit = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="当前止盈价"
    )
    status = models.CharField(
        max_length=20, 
        choices=StatusChoices.choices, 
        default=StatusChoices.OPEN,
        help_text="持仓状态。枚举: open(持仓中), closed(已平仓)"
    )

    def __str__(self):
        return f"Position {self.position_id}: {self.quantity} of {self.stock_code}"

    class Meta:
        db_table = 'tb_positions'
        verbose_name = '持仓信息'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\stock_info.py####
from django.db import models
from django.utils import timezone

class StockInfo(models.Model):
    """
    1.1. 股票基础信息表 (tb_stock_info)
    说明: 存储所有A股股票的基本信息，如代码、名称、上市日期等，作为其他数据表的关联基础。
    """
    class StatusChoices(models.TextChoices):
        LISTING = 'listing', '上市'
        DELISTED = 'delisted', '退市'
        SUSPENDED = 'suspended', '停牌'

    stock_code = models.CharField(
        max_length=50, 
        primary_key=True, 
        help_text="股票代码, 格式如 'sh.600000'"
    )
    stock_name = models.CharField(
        max_length=50, 
        help_text="股票名称"
    )
    listing_date = models.DateField(
        help_text="上市日期, 用于剔除次新股"
    )
    status = models.CharField(
        max_length=20, 
        choices=StatusChoices.choices,
        help_text="股票状态。枚举: listing(上市), delisted(退市), suspended(停牌)"
    )
    created_at = models.DateTimeField(
        default=timezone.now, 
        editable=False,
        help_text="记录创建时间"
    )
    updated_at = models.DateTimeField(
        auto_now=True,
        help_text="记录更新时间"
    )

    def __str__(self):
        return f"{self.stock_name}({self.stock_code})"

    class Meta:
        db_table = 'tb_stock_info'
        verbose_name = '股票基础信息'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\strategy_parameters.py####
from django.db import models

class StrategyParameters(models.Model):
    """
    2.3. 策略参数表 (tb_strategy_parameters)
    说明: 存储所有策略中可优化的参数，如权重、系数等，方便回测与优化模块进行读取和修改。
    """
    param_name = models.CharField(
        max_length=50, 
        primary_key=True, 
        help_text="参数唯一英文名, 如 'w_trend', 'k_h1'"
    )
    param_value = models.DecimalField(
        max_digits=20, 
        decimal_places=10, 
        help_text="参数的数值"
    )
    group_name = models.CharField(
        max_length=50, 
        blank=True, 
        null=True, 
        help_text="参数所属分组, 如 'WEIGHTS', 'STOP_LOSS'"
    )
    description = models.TextField(
        blank=True, 
        null=True, 
        help_text="参数的详细说明"
    )

    def __str__(self):
        return f"{self.param_name} = {self.param_value}"

    class Meta:
        db_table = 'tb_strategy_parameters'
        verbose_name = '策略参数'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\system_log.py####
from django.db import models
from django.utils import timezone

class SystemLog(models.Model):
    """
    4.1. 系统日志表 (tb_system_log)
    说明: 记录系统运行过程中的关键信息、警告和错误，便于监控和调试。
    """
    class LogLevelChoices(models.TextChoices):
        INFO = 'INFO', 'INFO'
        WARNING = 'WARNING', 'WARNING'
        ERROR = 'ERROR', 'ERROR'
        CRITICAL = 'CRITICAL', 'CRITICAL'

    log_id = models.BigAutoField(
        primary_key=True, 
        help_text="日志唯一ID"
    )
    log_time = models.DateTimeField(
        default=timezone.now, 
        editable=False,
        help_text="日志记录时间"
    )
    log_level = models.CharField(
        max_length=10, 
        choices=LogLevelChoices.choices,
        help_text="日志级别。枚举: INFO, WARNING, ERROR, CRITICAL"
    )
    module_name = models.CharField(
        max_length=50, 
        blank=True, 
        null=True,
        help_text="产生日志的模块名, 如 '日终选股', '开盘决策'"
    )
    message = models.TextField(
        help_text="日志内容, 如 '无合适买点', '下单API请求失败'"
    )

    def __str__(self):
        return f"[{self.log_time.strftime('%Y-%m-%d %H:%M:%S')}] [{self.log_level}] {self.message[:80]}"

    class Meta:
        db_table = 'tb_system_log'
        verbose_name = '系统日志'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\trade_log.py####
from django.db import models
from .stock_info import StockInfo

class TradeLog(models.Model):
    """
    3.3. 交易记录表 (tb_trade_log)
    说明: 记录每一次买入和卖出的详细信息，用于成本核算、业绩分析和问题排查。
    """
    class TradeTypeChoices(models.TextChoices):
        BUY = 'buy', '买入'
        SELL = 'sell', '卖出'

    class OrderTypeChoices(models.TextChoices):
        LIMIT = 'limit', '限价'
        MARKET = 'market', '市价'

    class ReasonChoices(models.TextChoices):
        ENTRY = 'entry', '策略入场'
        TAKE_PROFIT = 'take_profit', '止盈'
        STOP_LOSS = 'stop_loss', '止损'
        MANUAL = 'manual', '人工干预'

    class StatusChoices(models.TextChoices):
        FILLED = 'filled', '已成交'
        FAILED = 'failed', '失败'
        CANCELLED = 'cancelled', '已撤销'
        PENDING = 'pending','待执行'

    trade_id = models.BigAutoField(
        primary_key=True, 
        help_text="交易唯一ID"
    )
    # 注意：这里使用字符串 'positions.Position' 来避免循环导入问题
    # related_name='trade_logs' 允许从 Position 对象反向访问其所有交易记录
    position = models.ForeignKey(
        'Position', 
        on_delete=models.CASCADE, # 如果持仓被删除，关联的交易记录也应删除
        related_name='trade_logs',
        help_text="关联的持仓ID (买入时生成, 卖出时引用)"
    )
    stock_code = models.ForeignKey(
        StockInfo, 
        on_delete=models.PROTECT,
        db_column='stock_code',
        help_text="股票代码"
    )
    trade_datetime = models.DateTimeField(
        help_text="交易成交时间"
    )
    trade_type = models.CharField(
        max_length=10, 
        choices=TradeTypeChoices.choices,
        help_text="交易类型。枚举: buy(买入), sell(卖出)"
    )
    order_type = models.CharField(
        max_length=10, 
        choices=OrderTypeChoices.choices,
        help_text="订单类型。枚举: limit(限价), market(市价)"
    )
    price = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="成交均价"
    )
    quantity = models.BigIntegerField(
        help_text="成交数量"
    )
    commission = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="佣金"
    )
    stamp_duty = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        default=0,
        help_text="印花税 (仅卖出时有)"
    )
    reason = models.CharField(
        max_length=50, 
        choices=ReasonChoices.choices, 
        blank=True, 
        null=True,
        help_text="交易原因。枚举: entry(策略入场), take_profit(止盈), stop_loss(止损), manual(人工干预)"
    )
    status = models.CharField(
        max_length=20, 
        choices=StatusChoices.choices,
        help_text="订单状态。枚举: filled(已成交), failed(失败), cancelled(已撤销),pending(待执行)"
    )

    external_order_id = models.CharField(
        max_length=50, 
        null=True, 
        blank=True, 
        db_index=True,
        help_text="外部交易系统的订单ID，如券商的委托编号"
    )

    def __str__(self):
        return f"Trade {self.trade_id}: {self.trade_type.upper()} {self.quantity} of {self.stock_code}"

    class Meta:
        db_table = 'tb_trade_log'
        verbose_name = '交易记录'
        verbose_name_plural = verbose_name

####文件结束####

####data_manager\__init__.py####

####文件结束####

####data_manager\admin.py####
from django.contrib import admin

# Register your models here.

####文件结束####

####data_manager\apps.py####
from django.apps import AppConfig


class DataManagerConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'data_manager'

####文件结束####

####data_manager\models.py####
from django.db import models

# Create your models here.

####文件结束####

####data_manager\tests.py####
from django.test import TestCase

# Create your tests here.

####文件结束####

####data_manager\urls.py####
"""
URL configuration for autoTrade project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path,include
from . import views
urlpatterns = [
    path('test', views.test_get),
    path('updateLocalStock', views.update_local_a_shares),
    path('syncCorporateActions', views.sync_corporate_actions),
    path('sendEmail', views.email_send)
]

####文件结束####

####data_manager\views.py####
from django.http.response import JsonResponse
from django.shortcuts import render
from common.models import StockInfo
from data_manager.service.stock_service import StockService
from data_manager.service.corporate_action_service import CorporateActionService
from data_manager.service.email_service import EmailNotificationService
from django.views.decorators.http import require_http_methods
import json
from datetime import date,datetime
# Create your views here.
def test_get(request):
    result={}
    if request.method=='GET':
        result=  {'method':'get'}
    if request.method=='POST':
        result= {'methods':'post'}
    # service=StockService()
    # service.clear_all_data()
    # service.update_local_a_shares(start_date="2025-01-01",end_date="2025-08-04")
    # service.update_local_a_shares(start_date="2024-01-01",end_date="2024-12-31")
    # service.update_local_a_shares(start_date="2023-01-01",end_date="2023-12-31")
    # service.update_local_a_shares(start_date="2022-01-01",end_date="2022-12-31")
    # service.update_local_a_shares(start_date="2021-01-01",end_date="2021-12-31")
    return JsonResponse(result)

@require_http_methods(["POST"])
def update_local_a_shares(request):
    body= json.loads(request.body)
    service=StockService()
    service.update_local_a_shares(stock_codes=body['stockCodes'],start_date=body['startDate'],end_date=body['endDate'])
    return JsonResponse({"result":"success"})

@require_http_methods(["POST"])
def sync_corporate_actions(request):
    body= json.loads(request.body)
    service=CorporateActionService()
    service.sync_corporate_actions(start_date=body['startDate'],end_date=body['endDate'])
    return JsonResponse({"result":"success"})

@require_http_methods(["POST"])
def email_send(request):
    body= json.loads(request.body)
    service=EmailNotificationService(t_day=datetime.strptime(body['date'], "%Y-%m-%d").date())
    service.runEmailSend()
    return JsonResponse({"result":"success"})
####文件结束####

####data_manager\management\commands\full_update_stocks.py####
# data_manager/management/commands/full_update_stocks.py

from django.core.management.base import BaseCommand
from data_manager.service.stock_service import StockService
from selection_manager.service.selection_service import SelectionService
import time
from datetime import date,datetime
class Command(BaseCommand):
    help = '清空并重新获取过去五年的全部A股数据'

    def handle(self, *args, **options):
        total_start_time = time.time()
        self.stdout.write(self.style.SUCCESS('===== 开始执行全量数据更新任务 ====='))
        
        service = StockService()
        
        # 1. 清空所有旧数据
        self.stdout.write('正在清空所有历史数据...')
        #service.clear_all_data()
        self.stdout.write(self.style.SUCCESS('历史数据已清空。'))
        
        # 2. 按年份顺序获取数据
        #service.clear_all_data()
        service.update_local_a_shares(start_date="2025-08-06",end_date="2025-08-08")
        service.update_local_a_shares(start_date="2018-01-01",end_date="2019-12-31")
        # service.update_local_a_shares(start_date="2023-01-01",end_date="2023-12-31")
        # service.update_local_a_shares(start_date="2022-01-01",end_date="2022-12-31")
        # service.update_local_a_shares(start_date="2021-01-01",end_date="2021-12-31")
        total_end_time = time.time()
        self.stdout.write(self.style.SUCCESS(f'\n===== 所有年份数据更新完毕！总耗时: {(total_end_time - total_start_time) / 3600:.2f} 小时 ====='))
        self.stdout.write('开始预热M值...')
        service=SelectionService(datetime.strptime('2025-08-08', "%Y-%m-%d").date())
        service.run_selection()
        total_end_time_2 = time.time()

####文件结束####

####data_manager\management\commands\migrate_to_pg.py####
# data_manager/management/commands/migrate_to_pg.py

from django.core.management.base import BaseCommand
from data_manager.service.db_service import DbMigrationService

class Command(BaseCommand):
    help = '将整个SQLite数据库的结构和数据迁移到PostgreSQL'

    def handle(self, *args, **options):
        self.stdout.write(self.style.SUCCESS('开始执行数据库迁移任务...'))
        
        try:
            service = DbMigrationService()
            service.migrate()
            self.stdout.write(self.style.SUCCESS('数据库迁移任务已成功完成。'))
        except Exception as e:
            self.stdout.write(self.style.ERROR(f'数据库迁移失败: {e}'))


####文件结束####

####data_manager\management\commands\reset_sequences.py####
# data_manager/management/commands/reset_sequences.py (V2 - 修正版)
import logging
from django.core.management.base import BaseCommand
from django.db import connection, models
from django.apps import apps

logger = logging.getLogger(__name__)

class Command(BaseCommand):
    help = 'Resets PostgreSQL sequences for integer AutoFields to the max value of their primary key columns.'

    def handle(self, *args, **options):
        self.stdout.write(self.style.SUCCESS('===== 开始智能重置数据库序列 (仅处理自增整数主键) ====='))
        
        all_models = apps.get_models()
        
        with connection.cursor() as cursor:
            for model in all_models:
                table_name = model._meta.db_table
                pk_field = model._meta.pk
                
                # --- 核心修正：增加类型检查 ---
                # 1. 检查主键是否存在且是否为自增字段
                if not pk_field or not isinstance(pk_field, models.AutoField):
                    self.stdout.write(f'正在处理表: {table_name} ... ' + self.style.WARNING('跳过 (主键非自增整数)'))
                    continue

                # 2. 如果是自增字段，其内部类型一定是整数，可以安全处理
                pk_name = pk_field.name
                sequence_name = f"{table_name}_{pk_name}_seq"
                
                self.stdout.write(f'正在处理表: {table_name} (序列: {sequence_name}) ... ', ending='')
                
                try:
                    # SQL to get the max PK value.
                    # COALESCE is still useful for empty tables.
                    # The third argument 'false' in setval means the next value will be max_id + 1
                    # No change needed here as we've already filtered for integer PKs.
                    sql = f"""
                    SELECT setval('"{sequence_name}"', (SELECT COALESCE(MAX("{pk_name}"), 1) FROM "{table_name}"), false);
                    """
                    cursor.execute(sql)
                    self.stdout.write(self.style.SUCCESS('OK'))
                except Exception as e:
                    # 捕获其他可能的错误，例如序列真的不存在
                    if "does not exist" in str(e):
                        self.stdout.write(self.style.WARNING(f'跳过 (序列不存在)'))
                    else:
                        self.stdout.write(self.style.ERROR(f'失败: {e}'))
                        logger.error(f"重置序列 {sequence_name} 失败: {e}", exc_info=True)

        self.stdout.write(self.style.SUCCESS('\n===== 数据库序列智能重置完毕 ====='))

####文件结束####

####data_manager\service\corporate_action_service.py####
import logging
import time
from datetime import datetime

import akshare
import pandas as pd
from django.db import transaction

# 导入您的 Django models
# 请根据您的项目结构调整以下导入路径
from common.models.corporate_action import CorporateAction
from common.models.stock_info import StockInfo

# 配置日志记录器
logger = logging.getLogger(__name__)
class CorporateActionService:
    def _fetch_and_save_split_events(self,stock_codes_filter: list, start_date: str, end_date: str):
        """
        预留的拆股/并股事件处理函数。
        """
        # logger.info(f"正在检查拆股/并股事件 (当前版本暂未实现)...")
        pass

    def sync_corporate_actions(self,start_date: str, end_date: str, stock_codes: list = None):
        """
        从 Akshare 高效同步指定日期范围和股票范围的股权事件数据，并存入数据库。
        """
        logger.info(f"开始同步股权事件，日期范围: {start_date} to {end_date}。")
        if stock_codes:
            logger.info(f"目标股票: {len(stock_codes)} 只。")
        else:
            logger.info("目标股票: 全部A股。")

        # 1. 任务开始前，一次性清理数据
        try:
            with transaction.atomic():
                qs = CorporateAction.objects.filter(
                    ex_dividend_date__gte=start_date,
                    ex_dividend_date__lte=end_date
                )
                if stock_codes:
                    qs = qs.filter(stock_code__in=stock_codes)
                
                deleted_count, _ = qs.delete()
                logger.info(f"数据清理完成。在 {start_date} 到 {end_date} 范围内共删除 {deleted_count} 条旧记录。")
        except Exception as e:
            logger.error(f"清理历史数据时发生严重错误，任务终止: {e}", exc_info=True)
            return

        all_stocks_map = {s.split('.')[-1]: s for s in StockInfo.objects.values_list('stock_code', flat=True)}
        ak_codes_filter = [c.split('.')[-1] for c in stock_codes] if stock_codes else None

        # 2. 处理分红、送股、转股 (stock_fhps_em)
        try:
            logger.info("开始处理分红、送股、转股事件...")
            fhps_dfs = []
            start_year = datetime.strptime(start_date, '%Y-%m-%d').year
            end_year = datetime.strptime(end_date, '%Y-%m-%d').year
            
            # ★★★★★ 优化点：使用更精确的年份范围，覆盖跨年预案 ★★★★★
            report_suffixes = ["0331", "0630", "0930", "1231"]
            for year in range(start_year - 1, end_year + 1):
                for suffix in report_suffixes:
                    report_date = f"{year}{suffix}"
                    logger.info(f"正在拉取报告期 {report_date} 的分红送配预案...")
                    try:
                        time.sleep(1)
                        fhps_df = akshare.stock_fhps_em(date=report_date)
                        if not fhps_df.empty:
                            fhps_dfs.append(fhps_df)
                    except Exception as e:
                        logger.warning(f"拉取报告期 {report_date} 数据失败或无数据: {e}")
            
            if fhps_dfs:
                # 使用 '代码' 和 '除权除息日' 作为联合主键去重，防止同一事件因在不同报告期披露而重复
                all_fhps_df = pd.concat(fhps_dfs, ignore_index=True).drop_duplicates(subset=['代码', '除权除息日'])
                
                all_fhps_df['除权除息日'] = pd.to_datetime(all_fhps_df['除权除息日'], errors='coerce')
                all_fhps_df.dropna(subset=['除权除息日'], inplace=True)
                
                mask = (all_fhps_df['除权除息日'] >= pd.to_datetime(start_date)) & (all_fhps_df['除权除息日'] <= pd.to_datetime(end_date))
                filtered_fhps_df = all_fhps_df[mask].copy()

                if ak_codes_filter:
                    filtered_fhps_df = filtered_fhps_df[filtered_fhps_df['代码'].isin(ak_codes_filter)]

                logger.info(f"共获取到 {len(filtered_fhps_df)} 条符合条件的分红送转记录，准备入库...")

                with transaction.atomic():
                    for _, row in filtered_fhps_df.iterrows():
                        ak_code = row['代码']
                        stock_code_prefixed = all_stocks_map.get(ak_code)
                        if not stock_code_prefixed:
                            continue

                        # 分红
                        if pd.notna(row['现金分红-现金分红比例']) and row['现金分红-现金分红比例'] > 0:
                            CorporateAction.objects.create(
                                stock_code=stock_code_prefixed,
                                ex_dividend_date=row['除权除息日'].date(),
                                record_date=pd.to_datetime(row['股权登记日'], errors='coerce').date() if pd.notna(row['股权登记日']) else None,
                                notice_date=pd.to_datetime(row['最新公告日期'], errors='coerce').date() if pd.notna(row['最新公告日期']) else None,
                                event_type=CorporateAction.EventType.DIVIDEND,
                                dividend_per_share=row['现金分红-现金分红比例'] / 10
                            )

                        # 送股
                        if pd.notna(row['送转股份-送转比例']) and row['送转股份-送转比例'] > 0:
                            CorporateAction.objects.create(
                                stock_code=stock_code_prefixed,
                                ex_dividend_date=row['除权除息日'].date(),
                                record_date=pd.to_datetime(row['股权登记日'], errors='coerce').date() if pd.notna(row['股权登记日']) else None,
                                notice_date=pd.to_datetime(row['最新公告日期'], errors='coerce').date() if pd.notna(row['最新公告日期']) else None,
                                event_type=CorporateAction.EventType.BONUS,
                                shares_before=10,
                                shares_after=10 + row['送转股份-送转比例']
                            )

                        # 转股
                        if pd.notna(row['送转股份-转股比例']) and row['送转股份-转股比例'] > 0:
                            CorporateAction.objects.create(
                                stock_code=stock_code_prefixed,
                                ex_dividend_date=row['除权除息日'].date(),
                                record_date=pd.to_datetime(row['股权登记日'], errors='coerce').date() if pd.notna(row['股权登记日']) else None,
                                notice_date=pd.to_datetime(row['最新公告日期'], errors='coerce').date() if pd.notna(row['最新公告日期']) else None,
                                event_type=CorporateAction.EventType.TRANSFER,
                                shares_before=10,
                                shares_after=10 + row['送转股份-转股比例']
                            )
            logger.info("分红、送股、转股事件处理完成。")
        except Exception as e:
            logger.error(f"处理分红送转数据时发生严重错误: {e}", exc_info=True)

        # 3. 处理配股 (stock_pg_em)
        try:
            logger.info("开始处理配股事件...")
            time.sleep(1)
            all_pg_df = akshare.stock_pg_em()
            
            # Akshare 返回的 '股权登记日' 可能包含无效日期，需要处理
            all_pg_df['股权登记日'] = pd.to_datetime(all_pg_df['股权登记日'], errors='coerce')
            all_pg_df.dropna(subset=['股权登记日'], inplace=True)
 
            mask = (all_pg_df['股权登记日'] >= pd.to_datetime(start_date)) & (all_pg_df['股权登记日'] <= pd.to_datetime(end_date))
            filtered_pg_df = all_pg_df[mask].copy()
 
            if ak_codes_filter:
                filtered_pg_df = filtered_pg_df[filtered_pg_df['股票代码'].isin(ak_codes_filter)]
            
            logger.info(f"共获取到 {len(filtered_pg_df)} 条符合条件的配股记录，准备入库...")
 
            with transaction.atomic():
                for _, row in filtered_pg_df.iterrows():
                    ak_code = row['股票代码']
                    stock_code_prefixed = all_stocks_map.get(ak_code)
                    if not stock_code_prefixed:
                        continue
 
                    # --- 修改开始 ---
                    # 从 '10配3.0' 这样的字符串中解析出配股比例数值
                    rights_ratio_val = 0
                    rights_ratio_str = row['配股比例']
                    
                    # 确保 '配股比例' 是一个有效的、可解析的字符串
                    if pd.notna(rights_ratio_str) and isinstance(rights_ratio_str, str) and '配' in rights_ratio_str:
                        try:
                            # 按 '配' 分割，取后面的部分，并转换为浮点数
                            ratio_str_part = rights_ratio_str.split('配')[1]
                            rights_ratio_val = float(ratio_str_part)
                        except (IndexError, ValueError) as e:
                            logger.warning(f"无法解析股票 {ak_code} 的配股比例 '{rights_ratio_str}'，已跳过。错误: {e}")
                            continue # 跳过此条记录
 
                    if rights_ratio_val > 0:
                        CorporateAction.objects.create(
                            stock_code=stock_code_prefixed,
                            # 注意：配股通常使用 '股权登记日' 作为关键日期，'除权日' 在此接口中可能不提供
                            ex_dividend_date=row['股权登记日'].date(), 
                            record_date=row['股权登记日'].date(),
                            notice_date=None, # akshare.stock_pg_em() 未提供公告日期
                            event_type=CorporateAction.EventType.RIGHTS,
                            shares_before=10, # 配股基准通常是10股
                            shares_after=10 + rights_ratio_val, # 使用解析后的数值
                            rights_issue_price=row['配股价']
                        )
                    # --- 修改结束 ---
 
            logger.info("配股事件处理完成。")
        except KeyError as e:
            # 捕获 '配股比例' 等字段不存在的错误
            logger.error(f"处理配股数据时发生字段缺失错误: {e}。请检查 Akshare 返回的数据列名是否已变更。", exc_info=True)
        except Exception as e:
            logger.error(f"处理配股数据时发生严重错误: {e}", exc_info=True)

        # 4. 调用预留的拆股/并股处理函数
        self._fetch_and_save_split_events(stock_codes, start_date, end_date)

        logger.info("所有股权事件同步任务已全部完成。")

####文件结束####

####data_manager\service\db_service.py####
# data_manager/service/db_service.py

import logging
import time
import pandas as pd
from sqlalchemy import create_engine, text
from django.apps import apps
from django.db import connections
from django.conf import settings
from collections import deque

logger = logging.getLogger(__name__)

class DbMigrationService:
    """
    一个健壮的服务，用于将数据从源数据库（SQLite）迁移到目标数据库（PostgreSQL）。
    它能自动处理表依赖关系，并使用分块读写来处理大数据表。
    """
    def __init__(self):
        # 从 Django settings 获取目标数据库配置
        pg_config = settings.DATABASES['default']
        self.pg_uri = f"postgresql+psycopg2://{pg_config['USER']}:{pg_config['PASSWORD']}@{pg_config['HOST']}:{pg_config['PORT']}/{pg_config['NAME']}"
        
        # 源数据库路径
        sqlite_path = settings.BASE_DIR / 'mainDB.sqlite3'
        self.sqlite_uri = f"sqlite:///{sqlite_path}"
        
        self.chunk_size = 50000  # 每次处理5万行，防止内存溢出

    def _get_migration_order(self) -> list:
        """
        通过拓扑排序分析 Django 模型之间的依赖关系，生成正确的迁移顺序。
        父表（被外键引用的表）会排在子表（有外键的表）前面。
        """
        all_models = apps.get_models()
        model_map = {model: model._meta.db_table for model in all_models}
        
        # 构建依赖图和入度计数
        dependencies = {model: set() for model in all_models}
        in_degree = {model: 0 for model in all_models}

        for model in all_models:
            for field in model._meta.get_fields():
                if field.is_relation and field.many_to_one and field.related_model in model_map:
                    # 如果 model 依赖于 related_model
                    related_model = field.related_model
                    if model in dependencies[related_model]:
                        continue
                    dependencies[related_model].add(model)
                    in_degree[model] += 1
        
        # 拓扑排序
        queue = deque([model for model in all_models if in_degree[model] == 0])
        sorted_models = []
        
        while queue:
            model = queue.popleft()
            sorted_models.append(model)
            
            for dependent_model in dependencies[model]:
                in_degree[dependent_model] -= 1
                if in_degree[dependent_model] == 0:
                    queue.append(dependent_model)

        if len(sorted_models) != len(all_models):
            raise Exception("数据库模型存在循环依赖，无法进行拓扑排序！")
            
        logger.info(f"计算出模型迁移顺序: {[model._meta.db_table for model in sorted_models]}")
        return sorted_models

    def migrate(self):
        """
        执行完整的数据库迁移流程。
        """
        logger.info("===== 开始数据库迁移：SQLite -> PostgreSQL =====")
        start_total_time = time.time()

        try:
            migration_order = self._get_migration_order()
            
            source_engine = create_engine(self.sqlite_uri)
            target_engine = create_engine(self.pg_uri)

            with target_engine.connect() as pg_conn:
                for model in migration_order:
                    if not(model._meta.db_table =='tb_daily_factor_values' or model._meta.db_table =='tb_daily_trading_plan' or model._meta.db_table =='tb_trade_log'):
                        logger.info(f"跳过表 {model}")
                        continue
                    else:
                        logger.info(f"执行表 {model}")
                    table_name = model._meta.db_table
                    logger.info(f"--- 正在迁移表: {table_name} ---")
                    start_table_time = time.time()

                    try:
                        # 1. 清空目标表并重置自增ID，保证幂等性
                        logger.info(f"清空目标表 {table_name}...")
                        # 使用 text() 来确保SQL语句被正确处理
                        truncate_sql = text(f'TRUNCATE TABLE public."{table_name}" RESTART IDENTITY CASCADE;')
                        pg_conn.execute(truncate_sql)
                        pg_conn.commit() # TRUNCATE 需要显式提交

                        # 2. 分块读取源数据并写入目标库
                        query = f'SELECT * FROM "{table_name}";'
                        total_rows = 0
                        for chunk_df in pd.read_sql_query(query, source_engine, chunksize=self.chunk_size):
                            
                            # 修正数据类型问题：Pandas有时会将bool转为int，需要转回来
                            for col in chunk_df.columns:
                                model_field = model._meta.get_field(col)
                                if model_field.get_internal_type() == 'BooleanField':
                                    chunk_df[col] = chunk_df[col].astype(bool)

                            chunk_df.to_sql(
                                name=table_name,
                                con=target_engine,
                                if_exists='append',
                                index=False,
                                method='multi',
                                schema='public' # 显式指定 schema
                            )
                            total_rows += len(chunk_df)
                            logger.info(f"已迁移 {total_rows} 行...")
                        
                        table_duration = time.time() - start_table_time
                        logger.info(f"表 {table_name} 迁移完成，共 {total_rows} 行，耗时 {table_duration:.2f} 秒。")

                    except Exception as e:
                        logger.error(f"迁移表 {table_name} 时发生错误: {e}", exc_info=True)
                        pg_conn.rollback() # 如果出错则回滚
                        raise  # 重新抛出异常，中断整个迁移过程

        except Exception as e:
            logger.critical(f"数据库迁移过程中发生严重错误，任务终止: {e}", exc_info=True)
            return

        total_duration = time.time() - start_total_time
        logger.info(f"===== 数据库迁移成功完成！总耗时: {total_duration:.2f} 秒 =====")


####文件结束####

####data_manager\service\email_handler.py####
# data_manager/service/email_handler.py

import smtplib
import logging
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.header import Header

logger = logging.getLogger(__name__)

class EmailHandler:
    """
    一个通用的邮件发送处理器。
    它封装了SMTP协议的细节，只向上层提供一个简单的send_email接口。
    所有配置项都在类的起始区域定义，方便统一管理。
    """

    # ==========================================================================
    # SMTP 配置区域 - 请根据您的邮箱服务商填充以下信息
    # 强烈建议在生产环境中使用环境变量或安全的配置管理方式，而非硬编码
    # 对于多数邮箱，您可能需要使用“应用专用密码”而非您的登录密码
    # ==========================================================================
    SMTP_SERVER = 'smtp.qq.com'  # 例如: 'smtp.qq.com' 或 'smtp.gmail.com'
    SMTP_PORT = 465                   # SSL加密端口通常为 465
    SMTP_USER = '876858298@qq.com' # 您的邮箱登录账号
    SMTP_PASSWORD = 'eoyktuuifrmxbdba'  # 您的邮箱授权码或密码
    SENDER_EMAIL = '876858298@qq.com' # 发件人邮箱地址
    SENDER_NAME = '量化交易预案推送'          # 发件人显示名称
    # ==========================================================================

    def send_email(self, recipients: list[str], subject: str, html_content: str) -> bool:
        """
        发送一封HTML格式的邮件给一个或多个收件人。

        :param recipients: 目标邮箱地址的列表, e.g., ['user1@example.com', 'user2@example.com']
        :param subject: 邮件主题
        :param html_content: 邮件正文 (HTML格式)
        :return: True 如果发送成功, False 如果失败
        """
        if not all([self.SMTP_SERVER, self.SMTP_PORT, self.SMTP_USER, self.SMTP_PASSWORD, self.SENDER_EMAIL]):
            logger.critical("SMTP配置不完整，无法发送邮件。请检查 EmailHandler 中的配置项。")
            return False

        if not recipients:
            logger.warning("收件人列表为空，邮件未发送。")
            return False

        # 创建一个带附件的实例
        message = MIMEMultipart('alternative')
        message['From'] = f'"{Header(self.SENDER_NAME, "utf-8").encode()}" <{self.SENDER_EMAIL}>'
        message['To'] = ", ".join(recipients)
        message['Subject'] = Header(subject, 'utf-8')

        # 邮件正文内容
        html_part = MIMEText(html_content, 'html', 'utf-8')
        message.attach(html_part)
        server = None  # 初始化server变量
        try:
            logger.info(f"准备通过 {self.SMTP_SERVER}:{self.SMTP_PORT} 发送邮件至 {recipients}...")
            
            # 1. 手动建立连接
            server = smtplib.SMTP_SSL(self.SMTP_SERVER, self.SMTP_PORT)
            server.login(self.SMTP_USER, self.SMTP_PASSWORD)
            server.sendmail(self.SENDER_EMAIL, recipients, message.as_string())
            
            logger.info(f"邮件发送成功！主题: '{subject}'")
            return True
            
        except smtplib.SMTPException as e:
            logger.error(f"发送邮件时发生SMTP错误: {e}", exc_info=True)
            return False
        except Exception as e:
            logger.error(f"发送邮件时发生未知错误: {e}", exc_info=True)
            return False
        finally:
            # 2. 在finally块中确保关闭连接
            if server:
                try:
                    # 3. 对quit()命令进行独立的异常处理
                    server.quit()
                except smtplib.SMTPResponseException as e:
                    # 优雅地处理服务器提前关闭连接的情况
                    logger.warning(f"关闭SMTP连接时发生响应异常 (通常无害): {e}")
                except Exception as e:
                    logger.error(f"关闭SMTP连接时发生未知错误: {e}", exc_info=True)


####文件结束####

####data_manager\service\email_service.py####
# data_manager/service/email_service.py

import logging
from datetime import date, timedelta
from decimal import Decimal

from django.utils import timezone
from django.db import transaction

# 内部模块导入
from .email_handler import EmailHandler

# Django模型导入
from common.models import (
    DailyFactorValues, DailyTradingPlan, DailyQuotes, StockInfo,
    Position, TradeLog
)
from selection_manager.service.selection_service import MARKET_INDICATOR_CODE
from trade_manager.service.decision_order_service import DecisionOrderService
from trade_manager.service.simulate_trade_handler import SimulateTradeHandler
from trade_manager.service.simulate_trade import SimulateTradeService


logger = logging.getLogger(__name__)

class EmailNotificationService:
    """
    封装了在T日盘前（如9:10）向指定邮箱推送T-1日预案的业务逻辑。
    """

    def __init__(self, t_day: date):
        """
        初始化邮件通知服务。
        :param t_day: T日，即预案执行日。
        """
        self.t_day = t_day
        try:
            # 获取T日之前的最后一个交易日作为T-1日
            self.t_minus_1_day = DailyQuotes.objects.filter(
                trade_date__lt=self.t_day
            ).latest('trade_date').trade_date
        except DailyQuotes.DoesNotExist:
            raise ValueError(f"无法找到 {self.t_day} 的前一个交易日(T-1)，服务无法初始化。")

        self.email_handler = EmailHandler()
        # 从EmailHandler的配置中直接读取收件人列表
        self.recipients = self.email_handler.recipients if hasattr(self.email_handler, 'recipients') else ['876858298@qq.com','850696281@qq.com','285173686@qq.com']


    def runEmailSend(self):
        """
        一键执行邮件发送的主方法。
        """
        logger.info(f"开始为T日({self.t_day})生成预案推送邮件...")
        # 【核心修改】先找到真正需要处理的预案日期
        plan_date_to_process = self._find_latest_pending_plan_date()
        if not plan_date_to_process:
            logger.warning(f"从T日({self.t_day})回溯，未找到任何待处理的交易预案，邮件发送任务终止。")
            return
        # 1. 获取所有需要的数据
        market_data = self._get_market_regime_data()
        # 【核心修改】将找到的日期传递给下一步
        plan_details = self._get_trading_plan_details(plan_date_to_process)
        if not plan_details:
            logger.warning(f"预案日({plan_date_to_process})的预案详情为空，邮件发送任务终止。")
            return
        # 2. 生成HTML内容
        html_content = self._format_html_content(market_data, plan_details)
        # 3. 发送邮件
        subject = f"【交易预案】{self.t_day.strftime('%Y-%m-%d')} 盘前确认 (数据源: {plan_date_to_process.strftime('%Y-%m-%d')})"
        self.email_handler.send_email(self.recipients, subject, html_content)

    def _get_market_regime_data(self) -> dict:
        """获取昨日M值及近10日M值历史"""
        try:
            # 获取T-1日及之前的10个交易日
            trade_dates = list(DailyQuotes.objects.filter(trade_date__lte=self.t_minus_1_day)
                               .values_list('trade_date', flat=True)
                               .distinct().order_by('-trade_date')[:10])
            trade_dates.reverse()

            m_values_qs = DailyFactorValues.objects.filter(
                stock_code_id=MARKET_INDICATOR_CODE,
                factor_code_id='dynamic_M_VALUE',
                trade_date__in=trade_dates
            ).order_by('-trade_date')

            m_values_map = {fv.trade_date: fv.raw_value for fv in m_values_qs}

            yesterday_m = m_values_map.get(self.t_minus_1_day, Decimal('NaN'))
            history_m = [{'date': d, 'value': m_values_map.get(d, Decimal('NaN'))} for d in trade_dates]

            return {'yesterday_m': yesterday_m, 'history_m': history_m}

        except Exception as e:
            logger.error(f"获取M值数据时出错: {e}", exc_info=True)
            return {'yesterday_m': Decimal('NaN'), 'history_m': []}

    def _get_trading_plan_details(self, plan_date: date) -> list[dict]:
        """获取T日交易预案及相关的所有详细信息"""
        plans = DailyTradingPlan.objects.filter(plan_date=plan_date, status=DailyTradingPlan.StatusChoices.PENDING).order_by('rank')
        if not plans.exists():
            return []

        detailed_plans = []
        for plan in plans:
            stock_code = plan.stock_code_id
            logger.debug(f"正在处理预案股票: {stock_code}")
            try:
                # 获取止盈止损率
                rates = self._calculate_profit_loss_rates(stock_code)
                # 获取历史行情
                history = self._get_stock_historical_data(stock_code)

                detailed_plans.append({
                    'plan': plan,
                    'stock_info': plan.stock_code, # StockInfo object
                    'rates': rates,
                    'history': history
                })
            except Exception as e:
                logger.error(f"处理股票 {stock_code} 的预案详情时失败: {e}", exc_info=True)
                continue # 跳过这个出错的股票

        return detailed_plans

    def _calculate_profit_loss_rates(self, stock_code: str) -> dict:
        """
        通过创建临时数据库记录来复用现有止盈止损计算逻辑。
        整个过程在单个数据库事务中完成，确保安全。
        """
        tp_rate, sl_rate = Decimal('NaN'), Decimal('NaN')
        try:
            # 【新增步骤1】: 获取T-1日收盘价作为基准
            try:
                t_minus_1_quote = DailyQuotes.objects.get(stock_code_id=stock_code, trade_date=self.t_minus_1_day)
                base_price = t_minus_1_quote.close
                if base_price <= 0:
                    raise ValueError("T-1日收盘价无效")
            except DailyQuotes.DoesNotExist:
                logger.error(f"无法找到 {stock_code} 在 {self.t_minus_1_day} 的行情数据，无法计算止盈止损率。")
                return {'tp_rate': tp_rate, 'sl_rate': sl_rate}
            except ValueError as e:
                logger.error(f"股票 {stock_code} 在 {self.t_minus_1_day} 的收盘价不合法: {e}")
                return {'tp_rate': tp_rate, 'sl_rate': sl_rate}
            with transaction.atomic():
                # 【修改步骤2】: 使用获取到的base_price创建临时记录
                temp_position = Position.objects.create(
                    stock_code_id=stock_code,
                    entry_price=base_price, # 使用T-1收盘价
                    quantity=100,
                    entry_datetime=timezone.now(),
                    status=Position.StatusChoices.OPEN,
                    current_stop_loss=Decimal('0.00'),
                    current_take_profit=Decimal('0.00')
                )
                temp_trade_log = TradeLog.objects.create(
                    position=temp_position,
                    stock_code_id=stock_code,
                    trade_datetime=timezone.now(),
                    trade_type=TradeLog.TradeTypeChoices.BUY,
                    status=TradeLog.StatusChoices.FILLED,
                    price=base_price, # 使用T-1收盘价
                    quantity=100,
                    commission=0,
                    stamp_duty=0
                )
                # 调用服务进行计算 (这部分不变)
                dummy_sim_service = SimulateTradeService()
                dummy_handler = SimulateTradeHandler(dummy_sim_service)
                decision_service = DecisionOrderService(handler=dummy_handler, execution_date=self.t_day)
                decision_service.calculate_stop_profit_loss(trade_id=temp_trade_log.trade_id)
                temp_position.refresh_from_db()
                # 【修改步骤3】: 使用base_price作为分母计算比率
                take_profit_price = temp_position.current_take_profit
                stop_loss_price = temp_position.current_stop_loss
                if take_profit_price > 0:
                    tp_rate = (take_profit_price / base_price) - 1
                if stop_loss_price > 0:
                    sl_rate = 1 - (stop_loss_price / base_price)
                # 回滚事务，清除临时数据 (这部分不变)
                transaction.set_rollback(True)
        except Exception as e:
            logger.error(f"为 {stock_code} 计算止盈止损率时发生严重错误: {e}", exc_info=True)
            transaction.set_rollback(True)
        logger.debug(f"{stock_code} (基准价: {base_price:.2f}) -> TP Rate: {tp_rate:.4%}, SL Rate: {sl_rate:.4%}")
        return {'tp_rate': tp_rate, 'sl_rate': sl_rate}


    def _get_stock_historical_data(self, stock_code: str) -> list[dict]:
        """获取指定股票近10个交易日的历史行情"""
        trade_dates = list(DailyQuotes.objects.filter(trade_date__lte=self.t_minus_1_day)
                           .values_list('trade_date', flat=True)
                           .distinct().order_by('-trade_date')[:10])
        trade_dates.reverse()

        quotes = DailyQuotes.objects.filter(
            stock_code_id=stock_code,
            trade_date__in=trade_dates
        ).order_by('trade_date')

        history = []
        prev_close = None
        for quote in quotes:
            change_pct = Decimal('0.0')
            if prev_close and prev_close > 0:
                change_pct = (quote.close / prev_close) - 1
            
            history.append({
                'date': quote.trade_date,
                'open': quote.open,
                'high': quote.high,
                'low': quote.low,
                'close': quote.close,
                'hfq_close': quote.hfq_close,
                'change_pct': change_pct
            })
            prev_close = quote.close
        return history

    def _format_html_content(self, market_data: dict, plan_details: list[dict]) -> str:
        """将所有数据格式化为美观的HTML字符串"""
        
        # --- CSS样式 ---
        style = """
        <style>
            body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; line-height: 1.6; color: #333; background-color: #f8f9fa; margin: 0; padding: 20px; }
            .container { max-width: 800px; margin: auto; background: #fff; padding: 25px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
            h2 { color: #0056b3; border-bottom: 2px solid #0056b3; padding-bottom: 10px; margin-top: 30px; }
            h3 { color: #17a2b8; margin-top: 25px; }
            table { width: 100%; border-collapse: collapse; margin-top: 15px; font-size: 14px; }
            th, td { border: 1px solid #dee2e6; padding: 10px; text-align: left; }
            th { background-color: #e9ecef; font-weight: 600; }
            tr:nth-child(even) { background-color: #f8f9fa; }
            .summary { font-size: 16px; font-weight: bold; margin-bottom: 20px; }
            .red { color: #dc3545; }
            .green { color: #28a745; }
            .footer { margin-top: 30px; font-size: 12px; color: #6c757d; text-align: center; }
        </style>
        """

        # --- HTML头部 ---
        html = f"""
        <!DOCTYPE html>
        <html lang="zh-CN">
        <head>
            <meta charset="UTF-8">
            <title>交易预案确认</title>
            {style}
        </head>
        <body>
            <div class="container">
                <h2>T日 ({self.t_day.strftime('%Y-%m-%d')}) 交易预案盘前确认</h2>
        """

        # --- 大盘情况 ---
        yesterday_m_str = f"{market_data['yesterday_m']:.4f}" if not market_data['yesterday_m'].is_nan() else "N/A"
        html += f"""
        <h3>[大盘情况]</h3>
        <p class="summary">昨日M值: <span class="{'red' if market_data.get('yesterday_m', 0) > 0 else 'green'}">{yesterday_m_str}</span></p>
        <table>
            <thead><tr><th>日期</th><th>M值</th></tr></thead>
            <tbody>
        """
        for item in reversed(market_data['history_m']):
            m_val_str = f"{item['value']:.4f}" if not item['value'].is_nan() else "N/A"
            html += f"<tr><td>{item['date'].strftime('%Y-%m-%d')}</td><td>{m_val_str}</td></tr>"
        html += "</tbody></table>"

        # --- 选股预案 ---
        html += "<h3>[选股预案]</h3>"
        html += """
        <table>
            <thead>
                <tr>
                    <th>排名</th>
                    <th>股票代码</th>
                    <th>股票名称</th>
                    <th>可接受开盘区间</th>
                    <th>预期止盈率</th>
                    <th>预期止损率</th>
                </tr>
            </thead>
            <tbody>
        """
        for detail in plan_details:
            plan = detail['plan']
            stock_info = detail['stock_info']
            rates = detail['rates']
            tp_rate_str = f"{rates['tp_rate']:.2%}" if not rates['tp_rate'].is_nan() else "N/A"
            sl_rate_str = f"{rates['sl_rate']:.2%}" if not rates['sl_rate'].is_nan() else "N/A"
            html += f"""
            <tr>
                <td>{plan.rank}</td>
                <td>{stock_info.stock_code}</td>
                <td>{stock_info.stock_name}</td>
                <td>{plan.miop:.2f} - {plan.maop:.2f}</td>
                <td class="red">{tp_rate_str}</td>
                <td class="green">{sl_rate_str}</td>
            </tr>
            """
        html += "</tbody></table>"

        # --- 各股票历史行情 ---
        for detail in plan_details:
            stock_info = detail['stock_info']
            history = detail['history']
            html += f"<h4>{stock_info.stock_name} ({stock_info.stock_code}) - 近10日行情</h4>"
            html += """
            <table>
                <thead>
                    <tr>
                        <th>日期</th>
                        <th>开盘价</th>
                        <th>最高价</th>
                        <th>最低价</th>
                        <th>收盘价</th>
                        <th>后复权收盘</th>
                        <th>涨幅</th>
                    </tr>
                </thead>
                <tbody>
            """
            for item in reversed(history):
                color_class = 'red' if item['change_pct'] > 0 else ('green' if item['change_pct'] < 0 else '')
                html += f"""
                <tr>
                    <td>{item['date'].strftime('%Y-%m-%d')}</td>
                    <td>{item['open']:.2f}</td>
                    <td>{item['high']:.2f}</td>
                    <td>{item['low']:.2f}</td>
                    <td>{item['close']:.2f}</td>
                    <td>{item['hfq_close']:.4f}</td>
                    <td class="{color_class}">{item['change_pct']:.2%}</td>
                </tr>
                """
            html += "</tbody></table>"

        # --- HTML尾部 ---
        html += """
                <p class="footer">本邮件由策略交易系统自动生成，仅供参考，请在交易前最终确认。</p>
            </div>
        </body>
        </html>
        """
        return html
    def _find_latest_pending_plan_date(self) -> date | None:
        """从T日开始向前回溯，查找最新的一个包含待执行预案的日期"""
        # 设置一个合理的回溯上限，例如14天
        for i in range(14):
            check_date = self.t_day - timedelta(days=i)
            if DailyTradingPlan.objects.filter(
                plan_date=check_date,
                status=DailyTradingPlan.StatusChoices.PENDING
            ).exists():
                logger.info(f"找到待执行的交易预案，预案生成日为: {check_date}")
                return check_date
        logger.warning(f"在过去14天内未找到任何待执行的交易预案。")
        return None

####文件结束####

####data_manager\service\stock_service.py####
import logging
import datetime
from decimal import Decimal, ROUND_HALF_UP,InvalidOperation
import akshare as ak
import pandas as pd
from django.utils import timezone
from django.db import connection,transaction, DatabaseError

# 导入您的Django模型
from common.models.stock_info import StockInfo
from common.models.daily_quotes import DailyQuotes
from common.models.factor_definitions import FactorDefinitions
from common.models.daily_factor_values import DailyFactorValues
from common.models.strategy_parameters import StrategyParameters
from common.models.daily_trading_plan import DailyTradingPlan
from common.models.positions import Position
from common.models.trade_log import TradeLog
from common.models.system_log import SystemLog
from concurrent.futures import ThreadPoolExecutor, as_completed
import time

# 获取logger实例
logger = logging.getLogger(__name__)

# 定义模块常量，便于维护
MODULE_NAME = 'data_manager'

class StockService:
    """
    封装了与股票数据相关的服务，包括从akshare更新数据和从本地数据库查询数据。
  
    使用示例 (在Django views.py 或 management command中):
  
    from .services.stock_service import StockService
  
    def my_view(request):
        service = StockService()
      
        # 示例1: 更新所有A股今天的行情
        service.update_local_a_shares()
      
        # 示例2: 更新指定几只股票某时间段的行情
        codes = ['sh.600519', 'sz.000001']
        service.update_local_a_shares(stock_codes=codes, start_date='2023-01-01', end_date='2023-01-31')
      
        # 示例3: 查询指定股票的基础信息
        stock_infos = service.query_stock_info(stock_codes=codes)
      
        # 示例4: 查询所有股票今天的日线行情
        daily_quotes = service.query_daily_quotes()
    """

    def _log_and_save(self, message: str, level: str = SystemLog.LogLevelChoices.INFO):
        """
        一个辅助方法，用于同时向标准logger和数据库系统日志表写入日志。
        """
        log_map = {
            SystemLog.LogLevelChoices.INFO: logger.info,
            SystemLog.LogLevelChoices.WARNING: logger.warning,
            SystemLog.LogLevelChoices.ERROR: logger.error,
            SystemLog.LogLevelChoices.CRITICAL: logger.critical,
        }
      
        # 打印到标准日志
        log_function = log_map.get(level, logger.info)
        log_function(message)
      
        # 保存到数据库
        # try:
        #     SystemLog.objects.create(
        #         log_level=level,
        #         module_name=MODULE_NAME,
        #         message=message
        #     )
        # except Exception as e:
        #     logger.error(f"无法将日志写入数据库: {e}")

    def _save_quotes_df_to_db(self, quotes_df: pd.DataFrame):
        """
        辅助方法：将一个DataFrame的行情数据通过 update_or_create 批量存入数据库。
        此方法具有幂等性，适用于所有数据，无需区分历史和当日。
        """
        if quotes_df.empty:
            return
 
        # 数据清洗和预处理
        quotes_df.fillna(0, inplace=True)
        quotes_df = quotes_df[(quotes_df['开盘'] > 0) & (quotes_df['收盘'] > 0) & (quotes_df['最高'] > 0) & (quotes_df['最低'] > 0) & (quotes_df['成交量'] >= 0)]
        if quotes_df.empty:
            self._log_and_save("数据清洗后，当前批次无有效数据可存储。", level=SystemLog.LogLevelChoices.INFO)
            return
            
        quotes_df['日期'] = pd.to_datetime(quotes_df['日期']).dt.date
        
        hfq_precision = Decimal('0.0000000001')
        records_to_process = len(quotes_df)
    
        try:
            # 将整个批次的 update_or_create 操作放在一个事务中，以提高性能
            with transaction.atomic():
                for _, row in quotes_df.iterrows():
                    try:
                        close_dec = Decimal(str(row['收盘']))
                        factor_dec = Decimal(str(row['复权因子']))
                        hfq_close_dec = (close_dec * factor_dec).quantize(hfq_precision, rounding=ROUND_HALF_UP)
                        
                        # 对每一行数据都执行 update_or_create
                        DailyQuotes.objects.update_or_create(
                            stock_code_id=row['stock_code'], 
                            trade_date=row['日期'],
                            defaults={
                                'open': Decimal(str(row['开盘'])), 
                                'high': Decimal(str(row['最高'])),
                                'low': Decimal(str(row['最低'])), 
                                'close': close_dec,
                                'volume': int(row['成交量']), 
                                'turnover': Decimal(str(row['成交额'])),
                                'adjust_factor': factor_dec, 
                                'hfq_close': hfq_close_dec
                            }
                        )
                    except (InvalidOperation, TypeError) as conversion_error:
                        self._log_and_save(f"跳过一条数据转换失败的记录: {row['stock_code']} on {row['日期']}. Error: {conversion_error}", level=SystemLog.LogLevelChoices.WARNING)
                        continue
            
            self._log_and_save(f"通过 update_or_create 成功处理了 {records_to_process} 条日线数据。")
    
        except (DatabaseError, Exception) as e:
            self._log_and_save(f"数据批量入库阶段(update_or_create)发生严重错误: {e}", level=SystemLog.LogLevelChoices.ERROR)

    def update_local_a_shares(
        self, 
        stock_codes: list[str] = None, 
        start_date: str = None, 
        end_date: str = None
    ):

        """
        1. 更新本地A股信息 (最终版：高效、健壮)
        """
        self._log_and_save(f"开始执行A股数据更新任务...")
        target_codes=[]
        # --- Part 1: 更新股票基础信息 (tb_stock_info) ---
        try:
            self._log_and_save("正在从交易所官方数据源获取全量A股列表...")
            
            # 1. 通过高效、可靠的接口一次性获取所有A股信息
            # 上海主板A股
            sh_main_df = ak.stock_info_sh_name_code(symbol="主板A股").copy()
            # 上海科创板
            sh_star_df = ak.stock_info_sh_name_code(symbol="科创板").copy()
            # 深圳A股
            sz_a_df = ak.stock_info_sz_name_code(symbol="A股列表").copy()
 
            # 2. 数据预处理和合并
            # 统一列名
            sh_main_df.rename(columns={'证券简称': 'stock_name', '上市日期': 'listing_date', '证券代码': 'code'}, inplace=True)
            sh_star_df.rename(columns={'证券简称': 'stock_name', '上市日期': 'listing_date', '证券代码': 'code'}, inplace=True)
            sz_a_df.rename(columns={'A股简称': 'stock_name', 'A股上市日期': 'listing_date', 'A股代码': 'code'}, inplace=True)
 
            # 添加市场前缀
            sh_main_df['code'] = 'sh.' + sh_main_df['code']
            sh_star_df['code'] = 'sh.' + sh_star_df['code']
            sz_a_df['code'] = 'sz.' + sz_a_df['code']
 
            # 合并为一个DataFrame
            all_stocks_df = pd.concat([
                sh_main_df[['code', 'stock_name', 'listing_date']],
                sh_star_df[['code', 'stock_name', 'listing_date']],
                sz_a_df[['code', 'stock_name', 'listing_date']]
            ], ignore_index=True)
 
            # 转换日期格式
            all_stocks_df['listing_date'] = pd.to_datetime(all_stocks_df['listing_date']).dt.date
            
            self._log_and_save(f"成功获取 {len(all_stocks_df)} 条A股基础信息。")
 
            # 3. 高效的批量入库操作
            with transaction.atomic():
                existing_stocks = StockInfo.objects.in_bulk(field_name='stock_code')
                
                to_create = []
                to_update = []
 
                for _, row in all_stocks_df.iterrows():
                    code = row['code']
                    stock_obj = existing_stocks.get(code)
                    
                    if not stock_obj:
                        # 如果股票不存在，则准备新建
                        to_create.append(
                            StockInfo(
                                stock_code=code,
                                stock_name=row['stock_name'],
                                listing_date=row['listing_date'],
                                status=StockInfo.StatusChoices.LISTING
                            )
                        )
                    elif stock_obj.stock_name != row['stock_name']:
                        # 如果股票存在但名称有变，则准备更新
                        stock_obj.stock_name = row['stock_name']
                        to_update.append(stock_obj)
 
                # 批量创建
                if to_create:
                    StockInfo.objects.bulk_create(to_create, batch_size=500)
                    self._log_and_save(f"批量新增 {len(to_create)} 条股票基础信息。")
                
                # 批量更新
                if to_update:
                    StockInfo.objects.bulk_update(to_update, ['stock_name'], batch_size=500)
                    self._log_and_save(f"批量更新 {len(to_update)} 条股票基础信息。")
 
            # 如果未指定 stock_codes，则使用获取到的所有代码进行下一步
            if not stock_codes or len(stock_codes)==0:
                stock_codes = all_stocks_df['code'].tolist()
            else:
                # 如果指定了，则只处理指定的代码
                stock_codes = [code for code in stock_codes if code in all_stocks_df['code'].values]
            target_codes = stock_codes if stock_codes else all_stocks_df['code'].tolist()
        except Exception as e:
            self._log_and_save(f"更新股票基础信息时发生严重错误: {e}", level=SystemLog.LogLevelChoices.ERROR)
            return

        # --- Part 2: 更新日线行情 (串行获取、内存汇总、批量入库) ---
        self._log_and_save(f"开始为 {len(target_codes)} 只股票串行获取日线行情...")
        today_str = datetime.date.today().strftime('%Y%m%d')
        start_date_str = datetime.datetime.strptime(start_date, '%Y-%m-%d').strftime('%Y%m%d') if start_date else today_str
        end_date_str = datetime.datetime.strptime(end_date, '%Y-%m-%d').strftime('%Y%m%d') if end_date else today_str
        # 定义批处理参数
        batch_size = 50  # 每批处理50只股票，可以根据你的机器内存调整
        batch_quotes_list = []
        # 改为串行循环
        for i, code in enumerate(target_codes):
            ak_code = code.split('.')[1]
            logger.info(f"进度: [{i+1}/{len(target_codes)}] 正在获取 {code}...")
            try:
                df_normal = ak.stock_zh_a_hist(symbol=ak_code, period="daily", start_date=start_date_str, end_date=end_date_str, adjust="")
                time.sleep(1.6) # 增加礼貌性延时，降低被封风险
                df_hfq = ak.stock_zh_a_hist(symbol=ak_code, period="daily", start_date=start_date_str, end_date=end_date_str, adjust="hfq")
                
                if df_normal.empty or df_hfq.empty:
                    continue
 
                df = pd.merge(df_normal, df_hfq[['日期', '收盘']], on='日期', suffixes=('', '_hfq'))
                df['复权因子'] = df.apply(lambda row: row['收盘_hfq'] / row['收盘'] if row['收盘'] and row['收盘'] != 0 else 0, axis=1)
                df['stock_code'] = code
                batch_quotes_list.append(df)
                
                time.sleep(1.4) # 增加礼貌性延时，降低被封风险
 
            except Exception as e:
                self._log_and_save(f"获取 {code} 日线行情失败: {e}", level=SystemLog.LogLevelChoices.WARNING)
                continue
 
        # 检查是否达到批处理大小，或者已经是最后一只股票
            if (i + 1) % batch_size == 0 or (i + 1) == len(target_codes):
                if not batch_quotes_list:
                    continue # 如果这个批次是空的，就跳过

                self._log_and_save(f"处理批次 {i//batch_size + 1}，包含 {len(batch_quotes_list)} 只股票...")
                
                # 1. 合并当前批次的数据
                batch_master_df = pd.concat(batch_quotes_list, ignore_index=True)
                
                # 2. 将这个批次的数据存入数据库
                self._save_quotes_df_to_db(batch_master_df)
                
                # 3. 清空批次列表，释放内存，为下一批做准备
                batch_quotes_list = []
                self._log_and_save(f"批次 {i//batch_size + 1} 处理完毕，内存已释放。")
 
        self._log_and_save("A股数据更新任务全部执行完毕。")

    def query_stock_info(self, stock_codes: list[str] = None) -> dict[str, StockInfo]:
        """
        2. 查询本地A股基础信息
        直接查询 tb_stock_info。
        """
        queryset = StockInfo.objects.all()
        if stock_codes:
            queryset = queryset.filter(stock_code__in=stock_codes)
      
        return {stock.stock_code: stock for stock in queryset}

    def query_daily_quotes(
        self, 
        stock_codes: list[str] = None, 
        start_date: str = None, 
        end_date: str = None
    ) -> dict[str, list[DailyQuotes]]:
        """
        3. 查询本地A股交易信息
        直接查询 tb_daily_quotes。
        """
        # 设置默认日期为今天
        today = datetime.date.today()
        start_date = start_date or today.strftime('%Y-%m-%d')
        end_date = end_date or today.strftime('%Y-%m-%d')

        # 使用 select_related 优化查询，一次性获取关联的 StockInfo 对象
        # 使用 order_by 确保数据按股票和日期排序，便于后续分组
        queryset = DailyQuotes.objects.select_related('stock_code').filter(
            trade_date__gte=start_date,
            trade_date__lte=end_date
        ).order_by('stock_code', 'trade_date')

        if stock_codes:
            queryset = queryset.filter(stock_code__in=stock_codes)
      
        # 构建输出字典
        result = {}
        for quote in queryset:
            # 使用 stock_code_id 避免再次访问数据库
            # setdefault 是构建这种分组字典的优雅方式
            result.setdefault(quote.stock_code_id, []).append(quote)
          
        return result

    #清空所有数据
    def clear_all_data(self):
        with connection.cursor() as cursor:
            cursor.execute(f"DELETE FROM tb_daily_factor_values;")
            cursor.execute(f"DELETE FROM tb_daily_quotes;")
            cursor.execute(f"DELETE FROM tb_daily_trading_plan;")
            cursor.execute(f"DELETE FROM tb_factor_definitions;")
            cursor.execute(f"DELETE FROM tb_positions;")
            cursor.execute(f"DELETE FROM tb_stock_info;")
            cursor.execute(f"DELETE FROM tb_strategy_parameters;")
            cursor.execute(f"DELETE FROM tb_system_log;")
            cursor.execute(f"DELETE FROM tb_trade_log;")
####文件结束####

####selection_manager\__init__.py####

####文件结束####

####selection_manager\admin.py####
from django.contrib import admin

# Register your models here.

####文件结束####

####selection_manager\apps.py####
from django.apps import AppConfig


class SelectionManagerConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'selection_manager'

####文件结束####

####selection_manager\models.py####
from django.db import models

# Create your models here.

####文件结束####

####selection_manager\tests.py####
from django.test import TestCase

# Create your tests here.

####文件结束####

####selection_manager\urls.py####
"""
URL configuration for autoTrade project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path,include
from . import views
urlpatterns = [
    path('initSelectionStratage', views.init_strategy),
    path('runSelection',views.run_selection)
]

####文件结束####

####selection_manager\views.py####
from datetime import date,datetime
from django.shortcuts import render
from django.http.response import JsonResponse
from selection_manager.service.selection_service import SelectionService
import json
from django.views.decorators.http import require_http_methods
# Create your views here.
@require_http_methods(["GET"])
def init_strategy(request):
    SelectionService.initialize_strategy()
    result={}
    return JsonResponse(result)
@require_http_methods(["POST"])
def run_selection(request):
    if request.method=='POST':
        body= json.loads(request.body)
        selection_date=datetime.strptime(body['date'], "%Y-%m-%d").date()
        service=SelectionService(selection_date,mode=body['mode'])
        service.run_selection()
        return JsonResponse({
            'type':selection_date,
            'data':json.loads(request.body)
        })
    

####文件结束####

####selection_manager\management\commands\prime_market_regime_cache.py####
# selection_manager/management/commands/prime_market_regime_cache.py

import logging
import time
from datetime import date, timedelta

import pandas as pd
from django.core.management.base import BaseCommand
from django.db import transaction
from decimal import Decimal

from common.models import DailyQuotes, StockInfo, DailyFactorValues, StrategyParameters
from selection_manager.service.selection_service import MARKET_INDICATOR_CODE

# 配置日志
logger = logging.getLogger('prime_market_regime_cache')

# 尝试导入GPU库
try:
    import cudf
    import cupy as cp
    GPU_AVAILABLE = True
    logger.info("cuDF 和 cuPy 库已找到，将使用 GPU 进行计算。")
except ImportError:
    GPU_AVAILABLE = False
    logger.warning("未找到 cuDF 或 cuPy 库。此命令需要GPU环境。请安装相关依赖后重试。")
    logger.warning("参考安装: conda install -c rapidsai -c nvidia -c conda-forge cudf cupy")


class Command(BaseCommand):
    help = '使用GPU预热市场状态M(t)的历史数据缓存，用于首次运行或数据回补。'

    def add_arguments(self, parser):
        parser.add_argument(
            '--days',
            type=int,
            default=750,
            help='要预热的交易日天数，默认为750 (约3年)。'
        )
        parser.add_argument(
            '--end_date',
            type=str,
            # default=date.today().isoformat(),
            default="2023-04-30",
            help='预热的结束日期，默认为今天。格式: YYYY-MM-DD'
        )

    def handle(self, *args, **options):
        if not GPU_AVAILABLE:
            self.stdout.write(self.style.ERROR("GPU环境不可用，命令终止。"))
            return

        days_to_prime = options['days']
        end_date = date.fromisoformat(options['end_date'])
        
        self.stdout.write(self.style.SUCCESS(f"===== 开始M(t)缓存预热任务 (GPU模式) ====="))
        self.stdout.write(f"预热周期: {days_to_prime} 个交易日, 截止日期: {end_date}")
        
        total_start_time = time.time()

        # 1. 获取所需参数和交易日历
        params = {p.param_name: float(p.param_value) for p in StrategyParameters.objects.filter(param_name__startswith='dynamic_')}
        min_liquidity = params.get('dynamic_min_liquidity', 100000000)
        lookback_new_stock = int(params.get('dynamic_lookback_new_stock', 60))

        trade_dates = list(DailyQuotes.objects.filter(trade_date__lte=end_date)
                           .values_list('trade_date', flat=True).distinct().order_by('-trade_date')[:days_to_prime + 60])
        trade_dates.reverse()

        if not trade_dates:
            self.stdout.write(self.style.ERROR("数据库中无交易日数据，无法预热。"))
            return

        # 2. 加载全周期数据到Pandas
        self.stdout.write("正在从数据库加载全周期行情数据到内存...")
        start_load_time = time.time()
        all_quotes_qs = DailyQuotes.objects.filter(trade_date__in=trade_dates).values(
            'trade_date', 'stock_code_id', 'close', 'turnover', 'hfq_close'
        )
        all_stocks_qs = StockInfo.objects.values('stock_code', 'listing_date', 'stock_name')
        
        df_quotes = pd.DataFrame.from_records(all_quotes_qs)
        df_stocks = pd.DataFrame.from_records(all_stocks_qs)
        
        df_quotes['trade_date'] = pd.to_datetime(df_quotes['trade_date'])
        df_stocks['listing_date'] = pd.to_datetime(df_stocks['listing_date'])
        
        df = pd.merge(df_quotes, df_stocks, left_on='stock_code_id', right_on='stock_code')
        load_duration = time.time() - start_load_time
        self.stdout.write(f"数据加载完成，共 {len(df)} 条记录，耗时: {load_duration:.2f} 秒。")

        # 3. 数据传输到GPU
        self.stdout.write("正在将数据传输到GPU显存...")
        start_gpu_transfer_time = time.time()
        gdf = cudf.from_pandas(df)
        gpu_transfer_duration = time.time() - start_gpu_transfer_time
        self.stdout.write(f"数据成功传输到GPU，耗时: {gpu_transfer_duration:.2f} 秒。")

        # 4. 在GPU上进行计算
        self.stdout.write("正在GPU上并行计算所有日期的M(t)基础指标...")
        start_gpu_calc_time = time.time()
        
        # GPU计算逻辑
        results = []
        # 我们只对最近 `days_to_prime` 天进行计算和保存
        for calc_date in pd.to_datetime(trade_dates[-days_to_prime:]):
            # a. 当日筛选
            gdf_today = gdf[gdf['trade_date'] == calc_date]
            
            # 剔除ST
            gdf_today = gdf_today[~gdf_today['stock_name'].str.contains('ST')]
            
            # 剔除次新股
            min_listing_date = calc_date - timedelta(days=lookback_new_stock)
            gdf_today = gdf_today[gdf_today['listing_date'] < min_listing_date]
            
            # 剔除低流动性
            start_liquidity_date = calc_date - timedelta(days=40) # 多取一些数据
            gdf_liquidity_period = gdf[(gdf['trade_date'] >= start_liquidity_date) & (gdf['trade_date'] <= calc_date)]
            
            # 获取最近20个交易日
            recent_20_days = gdf_liquidity_period['trade_date'].unique().nlargest(20)
            gdf_liquidity_period = gdf_liquidity_period[gdf_liquidity_period['trade_date'].isin(recent_20_days)]
            
            avg_turnover = gdf_liquidity_period.groupby('stock_code_id')['turnover'].mean()
            liquid_stocks = avg_turnover[avg_turnover >= min_liquidity].index
            
            gdf_today = gdf_today[gdf_today['stock_code_id'].isin(liquid_stocks)]
            
            if gdf_today.empty:
                continue

            # b. 获取用于计算指标的历史窗口数据
            start_hist_date = calc_date - timedelta(days=120) # 넉넉하게 120일
            gdf_hist = gdf[(gdf['trade_date'] >= start_hist_date) & (gdf['trade_date'] <= calc_date)]
            gdf_hist = gdf_hist[gdf_hist['stock_code_id'].isin(gdf_today['stock_code_id'])]

            # c. 计算指标
            # M1: 创60日新高占比
            gdf_hist_60d = gdf_hist[gdf_hist['trade_date'].isin(gdf_hist['trade_date'].unique().nlargest(60))]
            high60 = gdf_hist_60d.groupby('stock_code_id')['close'].max()
            merged_m1 = gdf_today.merge(high60.rename('high60'), on='stock_code_id')
            m1 = (merged_m1['close'] >= merged_m1['high60']).sum() / len(merged_m1) if len(merged_m1) > 0 else 0

            # M2: MA60之上占比
            ma60 = gdf_hist_60d.groupby('stock_code_id')['close'].mean()
            merged_m2 = gdf_today.merge(ma60.rename('ma60'), on='stock_code_id')
            m2 = (merged_m2['close'] > merged_m2['ma60']).sum() / len(merged_m2) if len(merged_m2) > 0 else 0
            
            # M3: 60日回报率中位数
            date_t_minus_60 = gdf_hist_60d['trade_date'].unique().nsmallest(1).iloc[0]
            close_t = gdf_today[['stock_code_id', 'hfq_close']].set_index('stock_code_id')
            close_t_minus_60 = gdf_hist_60d[gdf_hist_60d['trade_date'] == date_t_minus_60][['stock_code_id', 'hfq_close']].set_index('stock_code_id')
            ret60 = (close_t / close_t_minus_60 - 1).dropna()
            m3 = ret60['hfq_close'].median() if not ret60.empty else 0

            # M4: 20日平均波动率
            gdf_hist_20d = gdf_hist[gdf_hist['trade_date'].isin(gdf_hist['trade_date'].unique().nlargest(20))]
            gdf_hist_20d = gdf_hist_20d.sort_values(by=['stock_code_id', 'trade_date'])
            returns = gdf_hist_20d.groupby('stock_code_id')['hfq_close'].pct_change().dropna()
            vol20 = gdf_hist_20d.merge(returns.rename('returns'), left_index=True, right_index=True).groupby('stock_code_id')['returns'].std()
            m4 = vol20.mean() if not vol20.empty else 0

            results.append({
                'trade_date': calc_date.date(),
                'dynamic_M1_RAW': float(m1),
                'dynamic_M2_RAW': float(m2),
                'dynamic_M3_RAW': float(m3) if m3 is not None else 0.0,
                'dynamic_M4_RAW': float(m4) if m4 is not None else 0.0,
            })
            self.stdout.write(f"  - 完成日期 {calc_date.date()} 的计算。")

        gpu_calc_duration = time.time() - start_gpu_calc_time
        self.stdout.write(f"GPU计算完成，耗时: {gpu_calc_duration:.2f} 秒。")

        # 5. 结果批量存入数据库
        self.stdout.write("正在将计算结果批量写入数据库缓存...")
        start_db_write_time = time.time()
        
        records_to_create = []
        for res in results:
            trade_date_res = res['trade_date']
            for factor_code_suffix, value in res.items():
                if factor_code_suffix == 'trade_date': continue
                if pd.notna(value):
                    records_to_create.append(DailyFactorValues(
                        stock_code_id=MARKET_INDICATOR_CODE,
                        trade_date=trade_date_res,
                        factor_code_id=factor_code_suffix,
                        raw_value=Decimal(str(value))
                    ))
        
        with transaction.atomic():
            # 先删除，再插入，保证幂等性
            dates_in_results = [r['trade_date'] for r in results]
            DailyFactorValues.objects.filter(
                stock_code_id=MARKET_INDICATOR_CODE,
                trade_date__in=dates_in_results
            ).delete()
            DailyFactorValues.objects.bulk_create(records_to_create, batch_size=500)

        db_write_duration = time.time() - start_db_write_time
        self.stdout.write(f"数据库写入完成，共 {len(records_to_create)} 条记录，耗时: {db_write_duration:.2f} 秒。")

        total_duration = time.time() - total_start_time
        self.stdout.write(self.style.SUCCESS(f"===== M(t)缓存预热任务成功完成！总耗时: {total_duration:.2f} 秒 ====="))


####文件结束####

####selection_manager\service\selection_service.py####
# selection_manager/service/selection_service.py

import logging
from datetime import date, timedelta
from decimal import Decimal

import numpy as np
import pandas as pd
import pandas_ta as ta
from scipy.stats import linregress

from django.db import transaction
from django.utils import timezone

from common.models import (
    StockInfo, DailyQuotes, SystemLog, FactorDefinitions, DailyFactorValues,
    StrategyParameters, DailyTradingPlan
)

# region: 全局配置
MODULE_NAME = '日终选股与预案模块(动态版)'
logger = logging.getLogger(__name__)
MARKET_INDICATOR_CODE = '_MARKET_REGIME_INDICATOR_'
# endregion


class SelectionService:
    """
    T-1日收盘后运行的动态自适应选股与预案生成服务。
    
    该服务实现了 f_dynamic(x, t) 选股评分函数，能够根据市场状态 M(t)
    动态调整选股策略的维度权重，以适应不同的市场环境。
    """

    def __init__(self, trade_date: date, mode: str = 'realtime'):
        """
        初始化选股服务。

        :param trade_date: T-1日，即执行计算的当天日期。
        :param mode: 运行模式, 'realtime' 或 'backtest'。
        """
        if mode not in ['realtime', 'backtest']:
            raise ValueError("模式(mode)必须是 'realtime' 或 'backtest'")

        # --- 日期对齐逻辑 ---
        try:
            # 查询小于等于输入日期的、最新的一个交易日
            latest_trade_date_obj = DailyQuotes.objects.filter(trade_date__lte=trade_date).latest('trade_date')
            validated_trade_date = latest_trade_date_obj.trade_date
            
            if validated_trade_date != trade_date:
                logger.debug(f"输入日期 {trade_date} 不是交易日，已自动校准为最近的交易日: {validated_trade_date}")
            
            self.trade_date = validated_trade_date
        except ObjectDoesNotExist:
            # 如果数据库中没有任何早于或等于 trade_date 的数据
            error_msg = f"无法在数据库中找到日期 {trade_date} 或之前的任何交易日数据，服务无法初始化。"
            logger.error(error_msg)
            raise ValueError(error_msg)
        self.mode = mode
        self.dynamic_params = {}
        self.dynamic_factor_defs = {}
        
        # 市场状态与动态权重
        self.market_regime_M = 0.0
        self.dynamic_weights = {}

        # 面板数据
        self.panel_open = None
        self.panel_high = None
        self.panel_low = None
        self.panel_close = None
        self.panel_volume = None
        self.panel_turnover = None
        self.panel_hfq_close = None

        logger.debug(f"--- SelectionService(动态版) 初始化 ---")
        logger.debug(f"交易日期 (T-1): {self.trade_date}")
        logger.debug(f"运行模式: {self.mode}")

    # region: --- 1. 主流程与入口方法 ---

    @staticmethod
    def initialize_strategy():
        """
        初始化动态策略所需的因子定义和参数到数据库。
        这是一个幂等操作，可以重复运行。
        """
        logger.debug("开始初始化动态策略：铺底因子定义和策略参数...")

        # 1. 确保市场指标的特殊股票代码存在
        try:
            StockInfo.objects.get_or_create(
                stock_code=MARKET_INDICATOR_CODE,
                defaults={
                    'stock_name': '市场状态指标',
                    'listing_date': date(1990, 1, 1),
                    'status': StockInfo.StatusChoices.LISTING
                }
            )
            logger.debug(f"特殊股票代码 '{MARKET_INDICATOR_CODE}' 已确认存在。")
        except Exception as e:
            logger.error(f"创建特殊股票代码 '{MARKET_INDICATOR_CODE}' 失败: {e}")
            # 这是一个关键步骤，如果失败则不应继续
            return

        # 2. 定义所有因子 (包括M(t)缓存因子和个股因子)
        factors_to_define = [
            # M(t) 缓存因子
            {'factor_code': 'dynamic_M_VALUE', 'factor_name': '动态-市场状态M(t)最终值', 'direction': 'positive'},
            {'factor_code': 'dynamic_M1_RAW', 'factor_name': '动态-M1原始值(新高占比)', 'direction': 'positive'},
            {'factor_code': 'dynamic_M2_RAW', 'factor_name': '动态-M2原始值(MA60之上占比)', 'direction': 'positive'},
            {'factor_code': 'dynamic_M3_RAW', 'factor_name': '动态-M3原始值(60日回报中位数)', 'direction': 'positive'},
            {'factor_code': 'dynamic_M4_RAW', 'factor_name': '动态-M4原始值(20日平均波动率)', 'direction': 'negative'},
            
            # 趋势动能 (MT) 维度因子
            {'factor_code': 'dynamic_MA20_SLOPE', 'factor_name': '动态-20日均线斜率', 'direction': 'positive'},
            {'factor_code': 'dynamic_MA_SCORE', 'factor_name': '动态-均线排列评分', 'direction': 'positive'},
            {'factor_code': 'dynamic_ADX_CONFIRM', 'factor_name': '动态-ADX趋势确认', 'direction': 'positive'},
            
            # 强势突破 (BO) 维度因子
            {'factor_code': 'dynamic_BREAKOUT_PWR', 'factor_name': '动态-突破强度', 'direction': 'positive'},
            {'factor_code': 'dynamic_VOLUME_SURGE', 'factor_name': '动态-成交量激增', 'direction': 'positive'},
            {'factor_code': 'dynamic_MOM_ACCEL', 'factor_name': '动态-动能加速度', 'direction': 'positive'},

            # 均值回归 (MR) 维度因子
            {'factor_code': 'dynamic_RSI_OS', 'factor_name': '动态-短期超卖(RSI14)', 'direction': 'negative'},
            {'factor_code': 'dynamic_NEG_DEV', 'factor_name': '动态-负向偏离度(vs MA60)', 'direction': 'negative'},
            {'factor_code': 'dynamic_BOLL_LB', 'factor_name': '动态-布林下轨支撑', 'direction': 'negative'},

            # 质量防御 (QD) 维度因子
            {'factor_code': 'dynamic_LOW_VOL', 'factor_name': '动态-低波动率(20日)', 'direction': 'negative'},
            {'factor_code': 'dynamic_MAX_DD', 'factor_name': '动态-最大回撤控制(60日)', 'direction': 'negative'},
            {'factor_code': 'dynamic_DOWNSIDE_RISK', 'factor_name': '动态-下行风险(60日)', 'direction': 'negative'},
        ]
        with transaction.atomic():
            for factor_data in factors_to_define:
                FactorDefinitions.objects.update_or_create(
                    factor_code=factor_data['factor_code'],
                    defaults={'factor_name': factor_data['factor_name'], 'direction': factor_data['direction'], 'is_active': True}
                )
        logger.debug(f"成功初始化/更新 {len(factors_to_define)} 个动态因子定义。")

        # 3. 定义所有参数 (使用 'dynamic_' 前缀)
        parameters_to_define = {
            # M(t) 参数
            'dynamic_w_m1': {'value': '0.2', 'group': 'M_WEIGHTS', 'desc': 'M(t)指标权重: M1-创60日新高占比'},
            'dynamic_w_m2': {'value': '0.35', 'group': 'M_WEIGHTS', 'desc': 'M(t)指标权重: M2-MA60之上占比'},
            'dynamic_w_m3': {'value': '0.25', 'group': 'M_WEIGHTS', 'desc': 'M(t)指标权重: M3-60日回报率中位数'},
            'dynamic_w_m4': {'value': '0.2', 'group': 'M_WEIGHTS', 'desc': 'M(t)指标权重: M4-20日平均波动率'},
            'dynamic_m_lookback': {'value': '750', 'group': 'M_PARAMS', 'desc': 'M(t)历史回看周期(约3年)'},

            # 动态权重 N_i(M(t)) 参数
            'dynamic_c_MT': {'value': '1.2', 'group': 'N_ATTRACTION', 'desc': '吸引力函数强度系数: 趋势动能'},
            'dynamic_c_BO': {'value': '0.9', 'group': 'N_ATTRACTION', 'desc': '吸引力函数强度系数: 强势突破'},
            'dynamic_c_QD': {'value': '1.1', 'group': 'N_ATTRACTION', 'desc': '吸引力函数强度系数: 质量防御'},
            'dynamic_c_MR': {'value': '0.8', 'group': 'N_ATTRACTION', 'desc': '吸引力函数强度系数: 均值回归'},
            'dynamic_sigma_MR': {'value': '0.25', 'group': 'N_PARAMS', 'desc': '均值回归策略适用范围宽度'},
            'dynamic_tau': {'value': '0.2', 'group': 'N_PARAMS', 'desc': 'Softmax温度系数(控制切换灵敏度)'},

            # 维度内部因子权重 (k_ij)
            'dynamic_k_MT1': {'value': '0.5', 'group': 'K_WEIGHTS_MT', 'desc': '趋势动能-MA20斜率权重'},
            'dynamic_k_MT2': {'value': '0.3', 'group': 'K_WEIGHTS_MT', 'desc': '趋势动能-均线排列权重'},
            'dynamic_k_MT3': {'value': '0.2', 'group': 'K_WEIGHTS_MT', 'desc': '趋势动能-ADX确认权重'},
            'dynamic_k_BO1': {'value': '0.45', 'group': 'K_WEIGHTS_BO', 'desc': '强势突破-突破强度权重'},
            'dynamic_k_BO2': {'value': '0.35', 'group': 'K_WEIGHTS_BO', 'desc': '强势突破-成交量激增权重'},
            'dynamic_k_BO3': {'value': '0.2', 'group': 'K_WEIGHTS_BO', 'desc': '强势突破-动能加速度权重'},
            'dynamic_k_MR1': {'value': '0.3', 'group': 'K_WEIGHTS_MR', 'desc': '均值回归-RSI超卖权重'},
            'dynamic_k_MR2': {'value': '0.5', 'group': 'K_WEIGHTS_MR', 'desc': '均值回归-负向偏离度权重'},
            'dynamic_k_MR3': {'value': '0.2', 'group': 'K_WEIGHTS_MR', 'desc': '均值回归-布林下轨支撑权重'},
            'dynamic_k_QD1': {'value': '0.45', 'group': 'K_WEIGHTS_QD', 'desc': '质量防御-低波动率权重'},
            'dynamic_k_QD2': {'value': '0.35', 'group': 'K_WEIGHTS_QD', 'desc': '质量防御-最大回撤权重'},
            'dynamic_k_QD3': {'value': '0.2', 'group': 'K_WEIGHTS_QD', 'desc': '质量防御-下行风险权重'},
            
            # 交易预案参数
            # 'dynamic_k_drop': {'value': '0.3', 'group': 'PLAN_PARAMS', 'desc': 'MIOP低开容忍系数'},
            # 'dynamic_k_gap': {'value': '0.5', 'group': 'PLAN_PARAMS', 'desc': 'MAOP高开容忍系数'},
            'dynamic_miopmaop_k_gap_base_mt': {'value': '0.6', 'group': 'MIOPMAOP_BASE', 'desc': '动态开盘区间-趋势动能-高开容忍度'},
            'dynamic_miopmaop_k_drop_base_mt': {'value': '0.2', 'group': 'MIOPMAOP_BASE', 'desc': '动态开盘区间-趋势动能-低开容忍度'},
            'dynamic_miopmaop_k_gap_base_bo': {'value': '1.5', 'group': 'MIOPMAOP_BASE', 'desc': '动态开盘区间-强势突破-高开容忍度'},
            'dynamic_miopmaop_k_drop_base_bo': {'value': '0.1', 'group': 'MIOPMAOP_BASE', 'desc': '动态开盘区间-强势突破-低开容忍度'},
            'dynamic_miopmaop_k_gap_base_mr': {'value': '0.05', 'group': 'MIOPMAOP_BASE', 'desc': '动态开盘区间-均值回归-高开容忍度'},
            'dynamic_miopmaop_k_drop_base_mr': {'value': '1.8', 'group': 'MIOPMAOP_BASE', 'desc': '动态开盘区间-均值回归-低开容忍度'},
            'dynamic_miopmaop_k_gap_base_qd': {'value': '0.15', 'group': 'MIOPMAOP_BASE', 'desc': '动态开盘区间-质量防御-高开容忍度'},
            'dynamic_miopmaop_k_drop_base_qd': {'value': '0.15', 'group': 'MIOPMAOP_BASE', 'desc': '动态开盘区间-质量防御-低开容忍度'},
            
            # 筛选与计算参数
            'dynamic_lookback_new_stock': {'value': '60', 'group': 'FILTERS', 'desc': '次新股定义天数(自然日)'},
            'dynamic_min_liquidity': {'value': '100000000', 'group': 'FILTERS', 'desc': '最低日均成交额(元)'},
            'dynamic_top_n': {'value': '10', 'group': 'SELECTION', 'desc': '最终选取股票数量'},
        }
        with transaction.atomic():
            for name, data in parameters_to_define.items():
                StrategyParameters.objects.update_or_create(
                    param_name=name,
                    defaults={
                        'param_value': Decimal(data['value']),
                        'group_name': data['group'],
                        'description': data['desc']
                    }
                )
        logger.debug(f"成功初始化/更新 {len(parameters_to_define)} 个动态策略参数。")
        logger.debug("动态策略初始化完成。")

    def run_selection(self):
        """
        一键启动全流程的入口方法。
        """
        ta.Imports["verbose"] = False
        self._log_to_db('INFO', f"动态选股流程启动。模式: {self.mode}, 日期: {self.trade_date}")
        try:
            self._load_dynamic_parameters_and_defs()
            initial_stock_pool = self._initial_screening()
            if not initial_stock_pool:
                self._log_to_db('WARNING', "初步筛选后无符合条件的股票，流程终止。")
                return

            # 核心动态逻辑
            self.market_regime_M = self._calculate_market_regime_M(initial_stock_pool)
            self.dynamic_weights = self._calculate_dynamic_weights(self.market_regime_M)
            
            self._load_market_data(initial_stock_pool)
            raw_factors_df = self._calculate_all_dynamic_factors()
            norm_scores_df = self._standardize_factors(raw_factors_df)
            
            dimension_scores_df = self._calculate_dimension_scores(norm_scores_df)
            final_scores = self._calculate_final_dynamic_score(dimension_scores_df, self.dynamic_weights)
            
            trading_plan = self._generate_trading_plan(final_scores,dimension_scores_df)
            if trading_plan.empty:
                self._log_to_db('WARNING', "最终未生成任何交易预案。")
                return

            self._save_results(raw_factors_df, norm_scores_df, trading_plan)

            success_msg = f"动态选股流程成功完成。M(t)={self.market_regime_M:.4f}, 生成 {len(trading_plan)} 条交易预案。"
            logger.debug(success_msg)
            self._log_to_db('INFO', success_msg)

        except Exception as e:
            error_msg = f"动态选股流程发生严重错误: {e}"
            logger.critical(error_msg, exc_info=True)
            self._log_to_db('CRITICAL', error_msg)
            raise

    # endregion

    # region: --- 2. 核心动态逻辑实现 ---

    def _calculate_market_regime_M(self, stock_pool: list[str]) -> float:
        """
        计算市场状态函数 M(t)，使用数据库缓存机制进行增量计算。
        """
        logger.debug("开始计算市场状态 M(t)...")
        
        # 1. 检查当日缓存
        try:
            cached_m = DailyFactorValues.objects.get(
                stock_code_id=MARKET_INDICATOR_CODE,
                trade_date=self.trade_date,
                factor_code_id='dynamic_M_VALUE'
            )
            m_value = float(cached_m.raw_value)
            logger.debug(f"成功从缓存中读取当日 M(t) = {m_value:.4f}")
            return m_value
        except DailyFactorValues.DoesNotExist:
            logger.debug("当日 M(t) 缓存未命中，开始增量计算...")

        # 2. 缓存未命中，进行计算
        lookback_days = int(self.dynamic_params['dynamic_m_lookback'])
        all_trade_dates = self._get_market_trade_dates(lookback_days)
        if not all_trade_dates:
            raise ValueError("无法获取历史交易日历，无法计算M(t)")

        # 3. 获取历史缓存的原始指标值
        m_factor_codes = ['dynamic_M1_RAW', 'dynamic_M2_RAW', 'dynamic_M3_RAW', 'dynamic_M4_RAW']
        cached_raw_values_qs = DailyFactorValues.objects.filter(
            stock_code_id=MARKET_INDICATOR_CODE,
            trade_date__in=all_trade_dates,
            factor_code_id__in=m_factor_codes
        ).values('trade_date', 'factor_code_id', 'raw_value')

        cached_df = pd.DataFrame.from_records(cached_raw_values_qs)
        if not cached_df.empty:
            cached_pivot = cached_df.pivot(index='trade_date', columns='factor_code_id', values='raw_value').astype(float)
        else:
            cached_pivot = pd.DataFrame(columns=m_factor_codes)

        # 4. 找出需要重新计算的日期
        dates_to_calculate = sorted(list(set(all_trade_dates) - set(cached_pivot.index)))
        logger.debug(f"需要重新计算 {len(dates_to_calculate)} 天的 M(t) 基础指标。")

        # 5. 对缺失日期进行计算
        newly_calculated_data = []
        if dates_to_calculate:
            # 只加载计算 M(t) 所需的数据
            self._load_market_data(stock_pool, for_m_calc=True)
            for calc_date in dates_to_calculate:
                m1, m2, m3, m4 = self._calculate_m_indicators_for_date(calc_date)
                newly_calculated_data.append({
                    'trade_date': calc_date,
                    'dynamic_M1_RAW': m1, 'dynamic_M2_RAW': m2,
                    'dynamic_M3_RAW': m3, 'dynamic_M4_RAW': m4
                })
                logger.debug(f"已完成计算{len(newly_calculated_data)}/ {len(dates_to_calculate)} 天")
        
        # 6. 合并新旧数据并存入缓存
        if newly_calculated_data:
            new_df = pd.DataFrame(newly_calculated_data).set_index('trade_date')
            self._save_m_raw_values_to_cache(new_df)
            # 合并到总的DataFrame
            if cached_pivot.empty:
                history_raw_df = new_df.sort_index()
            else:
                history_raw_df = pd.concat([cached_pivot, new_df]).sort_index()
        else:
            history_raw_df = cached_pivot.sort_index()

        # 7. 标准化并合成最终 M(t)
        current_raw = history_raw_df.loc[self.trade_date]
        
        m1_norm = self._norm_timeseries(current_raw['dynamic_M1_RAW'], history_raw_df['dynamic_M1_RAW'], 'positive')
        m2_norm = self._norm_timeseries(current_raw['dynamic_M2_RAW'], history_raw_df['dynamic_M2_RAW'], 'positive')
        m3_norm = self._norm_timeseries(current_raw['dynamic_M3_RAW'], history_raw_df['dynamic_M3_RAW'], 'positive')
        m4_norm = self._norm_timeseries(current_raw['dynamic_M4_RAW'], history_raw_df['dynamic_M4_RAW'], 'negative')

        m_t = (
            m1_norm * self.dynamic_params['dynamic_w_m1'] +
            m2_norm * self.dynamic_params['dynamic_w_m2'] +
            m3_norm * self.dynamic_params['dynamic_w_m3'] +
            m4_norm * self.dynamic_params['dynamic_w_m4']
        )
        
        # 8. 缓存最终的 M(t) 值
        DailyFactorValues.objects.update_or_create(
            stock_code_id=MARKET_INDICATOR_CODE,
            trade_date=self.trade_date,
            factor_code_id='dynamic_M_VALUE',
            defaults={'raw_value': Decimal(str(m_t)), 'norm_score': Decimal(str(m_t))}
        )
        logger.info(f"M(t) 计算完成，值为: {m_t:.4f}，并已存入缓存。")
        return m_t

    def _calculate_m_indicators_for_date(self, calc_date: date) -> tuple:
        """为特定一天计算M(t)的四个基础指标原始值"""
        # 获取当天的面板数据切片
        close_slice = self.panel_close.loc[:calc_date]
        hfq_close_slice = self.panel_hfq_close.loc[:calc_date]
        
        if close_slice.empty: return np.nan, np.nan, np.nan, np.nan

        # M1: 创60日新高占比
        high60 = hfq_close_slice.rolling(60, min_periods=1).max()
        is_new_high = hfq_close_slice.iloc[-1] == high60.iloc[-1]
        m1 = is_new_high.sum() / is_new_high.count() if is_new_high.count() > 0 else 0

        # M2: MA60之上占比
        ma60 = hfq_close_slice.rolling(60, min_periods=1).mean()
        above_ma60 = hfq_close_slice.iloc[-1] > ma60.iloc[-1]
        m2 = above_ma60.sum() / above_ma60.count() if above_ma60.count() > 0 else 0

        # M3: 60日回报率中位数
        if len(hfq_close_slice) >= 60:
            ret60 = hfq_close_slice.iloc[-1] / hfq_close_slice.iloc[-60] - 1
            m3 = ret60.median()
        else:
            m3 = np.nan

        # M4: 20日平均波动率
        if len(hfq_close_slice) >= 20:
            daily_ret = hfq_close_slice.pct_change(fill_method=None)
            vol20 = daily_ret.rolling(20, min_periods=1).std()
            m4 = vol20.iloc[-1].mean()
        else:
            m4 = np.nan
            
        return m1, m2, m3, m4

    def _norm_timeseries(self, value, history_series, direction):
        """对时间序列数据进行标准化"""
        # 使用T及之前的数据来计算分位数，作为T日的评价标准
        # history_series 是按时间升序排列的
        historical_benchmark = history_series
        
        if historical_benchmark.count() < 2: return 0.0 # 如果历史数据太少，也无法定标
        p1 = historical_benchmark.quantile(0.01)
        p99 = historical_benchmark.quantile(0.99)
        
        if (p99 - p1) < 1e-9: return 0.0
        
        value_prime = np.clip(value, p1, p99)
        
        if direction == 'positive':
            return ((value_prime - p1) / (p99 - p1)) * 2 - 1
        else: # negative
            return ((p99 - value_prime) / (p99 - p1)) * 2 - 1

    def _save_m_raw_values_to_cache(self, df: pd.DataFrame):
        """将新计算的M指标原始值批量存入数据库"""
        records = []
        for trade_date, row in df.iterrows():
            for factor_code, raw_value in row.items():
                if pd.notna(raw_value):
                    records.append(DailyFactorValues(
                        stock_code_id=MARKET_INDICATOR_CODE,
                        trade_date=trade_date,
                        factor_code_id=factor_code,
                        raw_value=Decimal(str(raw_value)),
                        norm_score=Decimal(str(raw_value)) # 原始值缓存，norm_score字段可复用
                    ))
        if records:
            DailyFactorValues.objects.bulk_create(records, ignore_conflicts=True)
            logger.debug(f"成功将 {len(records)} 条M(t)基础指标原始值存入缓存。")

    def _calculate_dynamic_weights(self, M_t: float) -> dict:
        """根据M(t)计算四个策略维度的动态权重"""
        logger.debug(f"根据 M(t)={M_t:.4f} 计算动态权重...")
        p = self.dynamic_params
        
        # a. 计算各维度吸引力 A_i
        A_MT = p['dynamic_c_MT'] * M_t
        A_BO = p['dynamic_c_BO'] * M_t
        A_QD = p['dynamic_c_QD'] * (-M_t)
        A_MR = p['dynamic_c_MR'] * np.exp(- (M_t / p['dynamic_sigma_MR'])**2)
        
        # b. 通过Softmax计算最终权重 N_i
        tau = p['dynamic_tau']
        exp_A_MT = np.exp(A_MT / tau)
        exp_A_BO = np.exp(A_BO / tau)
        exp_A_QD = np.exp(A_QD / tau)
        exp_A_MR = np.exp(A_MR / tau)
        
        sum_exp_A = exp_A_MT + exp_A_BO + exp_A_QD + exp_A_MR
        
        weights = {
            'MT': exp_A_MT / sum_exp_A,
            'BO': exp_A_BO / sum_exp_A,
            'QD': exp_A_QD / sum_exp_A,
            'MR': exp_A_MR / sum_exp_A,
        }
        logger.debug(f"动态权重计算完成: MT={weights['MT']:.2%}, BO={weights['BO']:.2%}, MR={weights['MR']:.2%}, QD={weights['QD']:.2%}")
        return weights

    def _calculate_dimension_scores(self, norm_scores_df: pd.DataFrame) -> pd.DataFrame:
        """计算四个策略维度的得分"""
        logger.debug("计算各策略维度得分...")
        p = self.dynamic_params
        scores = pd.DataFrame(index=norm_scores_df.index)

        scores['Score_MT'] = (
            norm_scores_df['dynamic_MA20_SLOPE'] * p['dynamic_k_MT1'] +
            norm_scores_df['dynamic_MA_SCORE'] * p['dynamic_k_MT2'] +
            norm_scores_df['dynamic_ADX_CONFIRM'] * p['dynamic_k_MT3']
        )
        scores['Score_BO'] = (
            norm_scores_df['dynamic_BREAKOUT_PWR'] * p['dynamic_k_BO1'] +
            norm_scores_df['dynamic_VOLUME_SURGE'] * p['dynamic_k_BO2'] +
            norm_scores_df['dynamic_MOM_ACCEL'] * p['dynamic_k_BO3']
        )
        scores['Score_MR'] = (
            norm_scores_df['dynamic_RSI_OS'] * p['dynamic_k_MR1'] +
            norm_scores_df['dynamic_NEG_DEV'] * p['dynamic_k_MR2'] +
            norm_scores_df['dynamic_BOLL_LB'] * p['dynamic_k_MR3']
        )
        scores['Score_QD'] = (
            norm_scores_df['dynamic_LOW_VOL'] * p['dynamic_k_QD1'] +
            norm_scores_df['dynamic_MAX_DD'] * p['dynamic_k_QD2'] +
            norm_scores_df['dynamic_DOWNSIDE_RISK'] * p['dynamic_k_QD3']
        )
        return scores

    def _calculate_final_dynamic_score(self, dimension_scores_df: pd.DataFrame, weights: dict) -> pd.Series:
        """计算最终的 f_dynamic 得分"""
        logger.debug("计算最终综合得分 f_dynamic(x, t)...")
        final_score = (
            dimension_scores_df['Score_MT'] * weights['MT'] +
            dimension_scores_df['Score_BO'] * weights['BO'] +
            dimension_scores_df['Score_MR'] * weights['MR'] +
            dimension_scores_df['Score_QD'] * weights['QD']
        )
        return final_score.sort_values(ascending=False)

    # endregion

    # region: --- 3. 因子计算 (模块化) ---

    def _calculate_all_dynamic_factors(self) -> pd.DataFrame:
        """调度所有12个因子计算方法"""
        logger.debug("开始计算所有动态因子...")
        
        factor_calculators = {
            'dynamic_MA20_SLOPE': self._calc_factor_ma20_slope,
            'dynamic_MA_SCORE': self._calc_factor_ma_score,
            'dynamic_ADX_CONFIRM': self._calc_factor_adx_confirm,
            'dynamic_BREAKOUT_PWR': self._calc_factor_breakout_pwr,
            'dynamic_VOLUME_SURGE': self._calc_factor_volume_surge,
            'dynamic_MOM_ACCEL': self._calc_factor_mom_accel,
            'dynamic_RSI_OS': self._calc_factor_rsi_os,
            'dynamic_NEG_DEV': self._calc_factor_neg_dev,
            'dynamic_BOLL_LB': self._calc_factor_boll_lb,
            'dynamic_LOW_VOL': self._calc_factor_low_vol,
            'dynamic_MAX_DD': self._calc_factor_max_dd,
            'dynamic_DOWNSIDE_RISK': self._calc_factor_downside_risk,
        }
        
        all_factors = {}
        for code, func in factor_calculators.items():
            if code in self.dynamic_factor_defs:
                logger.debug(f"  - 计算因子: {code}")
                all_factors[code] = func()
        
        raw_factors_df = pd.DataFrame(all_factors)
        original_count = len(raw_factors_df)

        inf_count = np.isinf(raw_factors_df).sum().sum()
        if inf_count > 0:
            logger.debug(f"发现 {inf_count} 个无穷大(inf)值，将替换为NaN进行剔除。")
            raw_factors_df.replace([np.inf, -np.inf], np.nan, inplace=True)
        # --- 核心调试代码 ---
        if original_count > 0:
            logger.debug("--- NaN 值分析开始 ---")
            nan_counts = raw_factors_df.isna().sum()
            logger.debug(f"因子计算后，各因子的 NaN 值数量 (总计 {original_count} 只股票):")
            logger.debug("\n" + nan_counts.to_string())
            
            # 找出NaN数量最多的因子
            problematic_factors = nan_counts[nan_counts > 0].sort_values(ascending=False)
            if not problematic_factors.empty:
                logger.debug(f"问题可能出在以下因子中，它们的NaN数量较多: \n{problematic_factors}")
            else:
                logger.debug("太棒了！没有任何因子产生NaN。")
            # 检查是否存在某一行全是NaN
            all_nan_rows = raw_factors_df.isna().all(axis=1).sum()
            if all_nan_rows > 0:
                logger.debug(f"警告：有 {all_nan_rows} 只股票的所有因子值都为 NaN！")
            logger.debug("--- NaN 值分析结束 ---")
        raw_factors_df.dropna(inplace=True)
        final_count = len(raw_factors_df)
        logger.debug(f"因子计算完成。因数据不足(NaN)剔除了 {original_count - final_count} 只股票。剩余 {final_count} 只。")
        
        return raw_factors_df

    # --- MT 因子 ---
    def _calc_factor_ma20_slope(self) -> pd.Series:
        """
        计算20日均线的20日线性回归斜率。
        使用numpy.linalg.lstsq进行向量化计算，避免了低效的rolling.apply()。
        """
        ma20 = self.panel_hfq_close.rolling(20).mean()
        
        # 我们只需要最后20个MA20值来计算当前斜率
        last_20_ma20 = ma20.tail(20)
        
        # 如果数据不足20天，则无法计算
        if len(last_20_ma20) < 20:
            # 返回一个全为NaN的Series，保持与原输出结构一致
            return pd.Series(np.nan, index=self.panel_hfq_close.columns)
        # 准备最小二乘法求解
        # x是时间自变量 [0, 1, 2, ..., 19]
        x = np.arange(20)
        # 我们需要一个常数项，所以构建一个 (20, 2) 的矩阵A
        A = np.vstack([x, np.ones(20)]).T
        
        # y是因变量，即每个股票的最后20个MA20值
        y = last_20_ma20.values
        
        # np.linalg.lstsq 会为y的每一列（每个股票）解出 Ax = y 中的 x
        # 返回结果的第一个元素是解的矩阵，其中第一行是斜率(m)，第二行是截距(c)
        slopes, _ = np.linalg.lstsq(A, y, rcond=None)[0]
        
        # 将结果转换回pandas Series
        return pd.Series(slopes, index=last_20_ma20.columns)

    def _calc_factor_ma_score(self) -> pd.Series:
        close, ma5, ma10, ma20 = (
            self.panel_hfq_close.iloc[-1],
            self.panel_hfq_close.rolling(5).mean().iloc[-1],
            self.panel_hfq_close.rolling(10).mean().iloc[-1],
            self.panel_hfq_close.rolling(20).mean().iloc[-1]
        )
        return (close > ma5).astype(int) + (ma5 > ma10).astype(int) + (ma10 > ma20).astype(int)

    def _calc_factor_adx_confirm(self) -> pd.Series:
        adx_df = self.panel_hfq_close.apply(lambda s: ta.adx(self.panel_high[s.name], self.panel_low[s.name], s, length=14).iloc[-1])
        adx_df = adx_df.T
        condition = (adx_df['ADX_14'] > 20) & (adx_df['DMP_14'] > adx_df['DMN_14'])
        return adx_df['ADX_14'].where(condition, 0)
        

    # --- BO 因子 ---
    def _calc_factor_breakout_pwr(self) -> pd.Series:
        close = self.panel_hfq_close
        atr14 = self.panel_hfq_close.apply(lambda s: ta.atr(self.panel_high[s.name], self.panel_low[s.name], s, length=14).iloc[-1])
        breakout_level = close.iloc[-60:-1].max()
        return (close.iloc[-1] - breakout_level) / (atr14+ 1e-9)
        

    def _calc_factor_volume_surge(self) -> pd.Series:
        vol = self.panel_volume
        return vol.iloc[-1] / (vol.iloc[-20:-1].mean()+ 1e-9)

    def _calc_factor_mom_accel(self) -> pd.Series:
        """计算动能加速度：(今日ROC5 / 11日前ROC5) - 1"""
        # 1. 计算整个面板的5日变化率 (动能)
        roc5 = self.panel_hfq_close.pct_change(5, fill_method=None)
        # 2. 使用 shift() 获取11个周期前的动能值。这才是正确的向量化操作。
        # shift() 会在每个股票代码（列）内部独立进行数据下移。
        roc5_shifted = roc5.shift(11)
        # 3. 计算动能加速度
        # 这个计算现在是正确的元素对元素操作：每个格子的值除以它上面11个格子的值
        acceleration = roc5 / (roc5_shifted + 1e-9) - 1
        # 4. 如果数据长度不足，acceleration的开头几行会是NaN，但最后一行应该是有效的。
        # 我们返回最后一行的Series即可。
        if acceleration.empty:
            return pd.Series(np.nan, index=self.panel_hfq_close.columns)
        
        return acceleration.iloc[-1]

    # --- MR 因子 ---
    def _calc_factor_rsi_os(self) -> pd.Series:
        return self.panel_hfq_close.apply(lambda s: ta.rsi(s, length=14).iloc[-1])

    def _calc_factor_neg_dev(self) -> pd.Series:
        ma60 = self.panel_hfq_close.rolling(60).mean().iloc[-1]
        return (self.panel_hfq_close.iloc[-1] - ma60) / (ma60+ 1e-9)

    def _calc_factor_boll_lb(self) -> pd.Series:
        boll_df = self.panel_hfq_close.apply(lambda s: ta.bbands(s, length=20).iloc[-1])
        boll_df = boll_df.T
        return (self.panel_hfq_close.iloc[-1] - boll_df['BBL_20_2.0']) / (boll_df['BBU_20_2.0'] - boll_df['BBL_20_2.0']+ 1e-9)
        
        

    # --- QD 因子 ---
    def _calc_factor_low_vol(self) -> pd.Series:
        return self.panel_hfq_close.pct_change(fill_method=None).rolling(20, min_periods=2).std().iloc[-1]

    def _calc_factor_max_dd(self) -> pd.Series:
        roll_max = self.panel_hfq_close.rolling(60, min_periods=1).max()
        daily_dd = self.panel_hfq_close / roll_max - 1.0
        return daily_dd.rolling(60, min_periods=1).min().iloc[-1]

    def _calc_factor_downside_risk(self) -> pd.Series:
        returns = self.panel_hfq_close.pct_change(fill_method=None)
        downside_returns = returns.copy()
        downside_returns[downside_returns > 0] = 0
        # 添加 min_periods=2
        downside_risk = downside_returns.rolling(60, min_periods=2).std() 
        return downside_risk.iloc[-1]

    # endregion
    
    # region: --- 4. 辅助方法 (基本与旧版兼容) ---

    def _log_to_db(self, level, message):
        return
        #SystemLog.objects.create(log_level=level, module_name=MODULE_NAME, message=message)

    def _load_dynamic_parameters_and_defs(self):
        logger.debug("加载动态策略参数和因子定义...")
        params_qs = StrategyParameters.objects.filter(param_name__startswith='dynamic_')
        self.dynamic_params = {p.param_name: float(p.param_value) for p in params_qs}
        
        defs_qs = FactorDefinitions.objects.filter(is_active=True, factor_code__startswith='dynamic_')
        self.dynamic_factor_defs = {f.factor_code: {'direction': f.direction} for f in defs_qs}
        logger.debug(f"加载了 {len(self.dynamic_params)} 个动态参数和 {len(self.dynamic_factor_defs)} 个启用的动态因子定义。")

    def _get_market_trade_dates(self, lookback_period: int) -> list[date]:
        trade_dates = list(
            DailyQuotes.objects
            .filter(trade_date__lte=self.trade_date)
            .values_list('trade_date', flat=True)
            .distinct()
            .order_by('-trade_date')[:lookback_period]
        )
        trade_dates.reverse()
        return trade_dates

    def _initial_screening(self) -> list[str]:
        logger.debug("开始执行初步筛选...")
        all_stocks = StockInfo.objects.filter(status=StockInfo.StatusChoices.LISTING)
        #过滤科创版、ST、*ST
        non_st_stocks = all_stocks.exclude(stock_code__contains='.688').exclude(stock_name__startswith='ST').exclude(stock_name__startswith='*ST')
        
        min_listing_date = self.trade_date - timedelta(days=int(self.dynamic_params['dynamic_lookback_new_stock']))
        
        non_new_stocks = non_st_stocks.filter(listing_date__lt=min_listing_date)
        
        stock_pool_codes = list(non_new_stocks.values_list('stock_code', flat=True))
        logger.debug(f"剔除科创版和ST和次新股后，剩余 {len(stock_pool_codes)} 只股票。")

        lookback_days = 20
        start_date = self.trade_date - timedelta(days=lookback_days * 2)
        
        quotes = DailyQuotes.objects.filter(
            stock_code_id__in=stock_pool_codes,
            trade_date__lte=self.trade_date,
            trade_date__gte=start_date
        ).values('stock_code_id', 'trade_date', 'turnover')

        if not quotes:
            logger.warning("在流动性筛选期间未找到任何行情数据。")
            return []

        quotes_df = pd.DataFrame.from_records(quotes)
        recent_trade_dates = sorted(quotes_df['trade_date'].unique())[-lookback_days:]
        quotes_df = quotes_df[quotes_df['trade_date'].isin(recent_trade_dates)]

        avg_turnover = quotes_df.groupby('stock_code_id')['turnover'].mean()
        liquid_stocks = avg_turnover[avg_turnover >= self.dynamic_params['dynamic_min_liquidity']]
        
        final_stock_pool = list(liquid_stocks.index)
        final_stock_pool=stock_pool_codes
        logger.debug(f"剔除低流动性股后，最终剩余 {len(final_stock_pool)} 只股票进入精选池。")
        
        return final_stock_pool

    def _load_market_data(self, stock_pool: list[str], for_m_calc: bool = False):
        max_lookback=1000
        if for_m_calc:
            # M(t)本身要看750天历史，其计算又需要60天窗口，所以总共需要约810天
            # 从数据库动态获取参数，避免硬编码
            m_lookback_param = int(self.dynamic_params.get('dynamic_m_lookback', 750))
            # 额外增加90天作为计算Buffer (覆盖60个交易日)
            max_lookback = m_lookback_param + 90 
        else:
            # 个股因子最长回溯60天，给足buffer到250天是合理的
            max_lookback = 250
        logger.debug(f"确定最大数据回溯期为 {max_lookback} 个交易日。")

        trade_dates = self._get_market_trade_dates(max_lookback)
        if not trade_dates: raise ValueError("无法获取市场交易日历。")
        
        logger.debug(f"正在加载 {len(stock_pool)} 只股票在 {len(trade_dates)} 个交易日内的行情数据...")
        
        quotes_qs = DailyQuotes.objects.filter(
            stock_code_id__in=stock_pool,
            trade_date__in=trade_dates
        ).values('trade_date', 'stock_code_id', 'open', 'high', 'low', 'close', 'volume', 'turnover', 'hfq_close')
        
        if not quotes_qs: raise ValueError("在指定日期范围内未找到任何股票的行情数据。")

        df = pd.DataFrame.from_records(quotes_qs)
        df['trade_date'] = pd.to_datetime(df['trade_date'])
        
        logger.debug("正在构建面板数据(Panel Data)...")
        for col in ['open', 'high', 'low', 'close', 'volume', 'turnover', 'hfq_close']:
            panel = df.pivot(index='trade_date', columns='stock_code_id', values=col).astype(float)
            setattr(self, f'panel_{col}', panel)
        logger.debug("面板数据构建完成。")

    def _standardize_factors(self, raw_factors_df: pd.DataFrame) -> pd.DataFrame:
        logger.debug("开始对因子值进行标准化...")
        norm_scores_df = pd.DataFrame(index=raw_factors_df.index)
        
        for factor_code, series in raw_factors_df.items():
            direction = self.dynamic_factor_defs[factor_code]['direction']
            p1, p99 = series.quantile(0.01), series.quantile(0.99)
            
            if (p99 - p1) < 1e-9:
                norm_scores_df[factor_code] = 0
                continue
            
            x_prime = series.clip(p1, p99)
            
            if direction == 'positive':
                score = ((x_prime - p1) / (p99 - p1)) * 200 - 100
            else:
                score = ((p99 - x_prime) / (p99 - p1)) * 200 - 100
            
            norm_scores_df[factor_code] = score
            
        logger.debug("因子标准化完成。")
        return norm_scores_df

    def _generate_trading_plan(self, final_scores: pd.Series, dimension_scores: pd.DataFrame) -> pd.DataFrame:
        """
        [V2.1 - Patched] 为Top N股票生成动态的、基于策略DNA的交易预案。
        - 修复了ATR计算中混合使用复权与不复权价格的严重BUG。
        - 优化了代码可读性。
        """
        logger.debug("开始生成动态交易预案 (V2.1 - Patched)...")
        top_n = int(self.dynamic_params.get('dynamic_top_n', 10))
        top_stocks_scores = final_scores.head(top_n)
        
        if top_stocks_scores.empty:
            return pd.DataFrame()
 
        top_stock_codes = top_stocks_scores.index.tolist()
        
        # 提取Top N股票的维度得分
        top_dimension_scores = dimension_scores.reindex(top_stock_codes)
 
        # === 核心修正点在这里 ===
        # 使用不复权的 self.panel_close 作为 apply 的主体，确保 lambda 中的 's' 是不复权收盘价序列
        logger.debug("正在基于不复权价格计算ATR...")
        atr14 = self.panel_close.apply(
            lambda s: ta.atr(
                high=self.panel_high[s.name].astype(float), 
                low=self.panel_low[s.name].astype(float), 
                close=s.astype(float),  # 这里的 's' 现在是正确的不复权收盘价序列
                length=14
            ).iloc[-1]
        )
        # === 修正结束 ===
 
        # 准备后续计算所需的数据
        last_close_series = self.panel_close.iloc[-1].reindex(top_stock_codes)
        last_atr_series = atr14.reindex(top_stock_codes)
        p = self.dynamic_params
        
        plans = []
        for stock_code in top_stock_codes:
            # --- 核心动态逻辑开始 (这部分逻辑是正确的，无需修改) ---
            
            # 步骤1: 计算各维度的贡献值 (DCV)
            # ... (此部分逻辑保持不变)
            dcv = {
                'MT': self.dynamic_weights['MT'] * top_dimension_scores.loc[stock_code, 'Score_MT'],
                'BO': self.dynamic_weights['BO'] * top_dimension_scores.loc[stock_code, 'Score_BO'],
                'MR': self.dynamic_weights['MR'] * top_dimension_scores.loc[stock_code, 'Score_MR'],
                'QD': self.dynamic_weights['QD'] * top_dimension_scores.loc[stock_code, 'Score_QD'],
            }
            
            # 步骤2: 提取正向贡献值 (PDCV) 并计算策略DNA权重 (SSW)
            # ... (此部分逻辑保持不变)
            pdcv = {k: max(0, v) for k, v in dcv.items()}
            total_pdcv = sum(pdcv.values())
            
            if total_pdcv <= 1e-9:
                logger.warning(f"股票 {stock_code} 信号混乱 (Total_PDCV <= 0)，采用保守的QD策略作为其开盘区间。")
                ssw = {'MT': 0, 'BO': 0, 'MR': 0, 'QD': 1.0}
            else:
                ssw = {k: v / total_pdcv for k, v in pdcv.items()}
 
            # 步骤3: 加权合成动态k值
            # ... (此部分逻辑保持不变)
            k_gap_dynamic = (
                ssw['MT'] * p['dynamic_miopmaop_k_gap_base_mt'] +
                ssw['BO'] * p['dynamic_miopmaop_k_gap_base_bo'] +
                ssw['MR'] * p['dynamic_miopmaop_k_gap_base_mr'] +
                ssw['QD'] * p['dynamic_miopmaop_k_gap_base_qd']
            )
            k_drop_dynamic = (
                ssw['MT'] * p['dynamic_miopmaop_k_drop_base_mt'] +
                ssw['BO'] * p['dynamic_miopmaop_k_drop_base_bo'] +
                ssw['MR'] * p['dynamic_miopmaop_k_drop_base_mr'] +
                ssw['QD'] * p['dynamic_miopmaop_k_drop_base_qd']
            )
            # --- 核心动态逻辑结束 ---
 
            # 获取该股票的不复权收盘价和正确的ATR值
            close = last_close_series.get(stock_code)
            atr = last_atr_series.get(stock_code)
 
            if pd.isna(close) or pd.isna(atr) or close <= 0:
                logger.warning(f"股票 {stock_code} 的收盘价或ATR无效(可能数据不足)，无法生成预案。")
                continue
 
            # 使用简化的公式，更清晰且能避免浮点精度问题
            miop = close - k_drop_dynamic * atr
            maop = close + k_gap_dynamic * atr
 
            plans.append({
                'stock_code': stock_code,
                'rank': len(plans) + 1,
                'final_score': top_stocks_scores.get(stock_code),
                'miop': miop,
                'maop': maop
            })
            
            # 更新日志，现在ATR值会是正常的
            logger.debug(f"预案: {stock_code}, Rank: {len(plans)}, ATR:{atr:.2f}, "
                        f"SSW(MT/BO/MR/QD):({ssw['MT']:.2f}/{ssw['BO']:.2f}/{ssw['MR']:.2f}/{ssw['QD']:.2f}), "
                        f"k_gap_dyn:{k_gap_dynamic:.2f}, k_drop_dyn:{k_drop_dynamic:.2f}, MIOP:{miop:.2f}, MAOP:{maop:.2f}")
 
        if not plans:
            return pd.DataFrame()
 
        plan_df = pd.DataFrame(plans).dropna(subset=['miop', 'maop'])
        logger.debug("动态交易预案生成完成。")
        return plan_df

    @transaction.atomic
    def _save_results(self, raw_factors_df, norm_scores_df, trading_plan_df):
        logger.debug("开始将结果保存到数据库...")
        
        # 1. 保存每日因子值
        factor_values_to_create = []
        for stock_code, row in raw_factors_df.iterrows():
            for factor_code, raw_value in row.items():
                norm_score = norm_scores_df.loc[stock_code, factor_code]
                factor_values_to_create.append(
                    DailyFactorValues(
                        stock_code_id=stock_code, trade_date=self.trade_date,
                        factor_code_id=factor_code, raw_value=Decimal(str(raw_value)),
                        norm_score=Decimal(str(norm_score))
                    )
                )
        DailyFactorValues.objects.bulk_create(factor_values_to_create, ignore_conflicts=True)

        # 2. 保存每日交易预案
        plan_date = self.trade_date + timedelta(days=1)
        DailyTradingPlan.objects.filter(plan_date=plan_date).delete()
        
        plans_to_create = []
        for _, row in trading_plan_df.iterrows():
            plans_to_create.append(
                DailyTradingPlan(
                    plan_date=plan_date, stock_code_id=row['stock_code'],
                    rank=row['rank'], final_score=Decimal(str(row['final_score'])),
                    miop=Decimal(str(row['miop'])).quantize(Decimal('0.01')),
                    maop=Decimal(str(row['maop'])).quantize(Decimal('0.01')),
                    status=DailyTradingPlan.StatusChoices.PENDING
                )
            )
        DailyTradingPlan.objects.bulk_create(plans_to_create)
        
        log_message = f"T-1日({self.trade_date})动态选股完成, T日({plan_date})预案如下:\n"
        log_message += trading_plan_df.to_string(index=False)
        self._log_to_db('INFO', log_message)
        logger.debug("所有结果已成功保存到数据库。")

    # endregion

####文件结束####

####trade_manager\__init__.py####

####文件结束####

####trade_manager\admin.py####
from django.contrib import admin

# Register your models here.

####文件结束####

####trade_manager\apps.py####
# trade_manager/apps.py

import os
import sys
from django.apps import AppConfig
import logging

logger = logging.getLogger(__name__)

class TradeManagerConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'trade_manager'

    def ready(self):
        # # 关键修正：通过检查环境变量 RUN_MAIN 来防止调度器在重载主进程中启动两次
        # # 这个环境变量是 Django 的 autoreloader 在启动子进程时设置的。
        # # 我们只想在运行实际应用的子进程中启动调度器。
        # if os.environ.get('RUN_MAIN'):
        #     logger.info("检测到 Django 应用工作进程，准备初始化调度器...")
        #     from .service import scheduler_service
        #     # 确保调度器只启动一次
        #     if not scheduler_service.scheduler.running:
        #          scheduler_service.start()
        #     else:
        #          logger.warning("调度器已在运行，跳过重复启动。")
        # else:
        #     logger.info("检测到 Django 管理或重载主进程，跳过调度器初始化。")
        return


####文件结束####

####trade_manager\models.py####
from django.db import models

# Create your models here.

####文件结束####

####trade_manager\tests.py####
from django.test import TestCase

# Create your tests here.

####文件结束####

####trade_manager\urls.py####
"""
URL configuration for autoTrade project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path,include
from . import views
urlpatterns = [
    path('beforeFixRun', views.before_fix_run),
    path('initParam',views.initialize_strategy_parameters),
    path('simulateTrade', views.simulate_trade)
]

####文件结束####

####trade_manager\views.py####
from datetime import date,datetime
from django.shortcuts import render
from django.http.response import JsonResponse
from trade_manager.service.before_fix_service import BeforeFixService
from trade_manager.service.decision_order_service import DecisionOrderService
from trade_manager.service.simulate_trade import SimulateTradeService
import json
from django.views.decorators.http import require_http_methods
# Create your views here.
@require_http_methods(["POST"])
def before_fix_run(request):
    if request.method=='POST':
        body= json.loads(request.body)
        selection_date=datetime.strptime(body['date'], "%Y-%m-%d").date()
        service=BeforeFixService(selection_date)
        service.run()
        return JsonResponse({
            'result':'成功'
        })
@require_http_methods(["GET"])
def initialize_strategy_parameters(request):
    if request.method=='GET':
        DecisionOrderService.initialize_strategy_parameters()
        return JsonResponse({
            'result':'成功'
        })

@require_http_methods(["POST"])
def simulate_trade(request):
    if request.method=='POST':
        body= json.loads(request.body)
        start_date=body['startDate']
        end_date=body['endDate']
        service=SimulateTradeService()
        result=service.run_backtest(start_date=start_date,end_date=end_date)
        return JsonResponse(result)
####文件结束####

####trade_manager\management\commands\run_backtest.py####
# ==============================================================================
# 文件 2/5: trade_manager/management/commands/run_backtest.py (新增)
# 描述: 用于从命令行启动回测的 Command 文件。
# ==============================================================================
from django.core.management.base import BaseCommand, CommandParser
from trade_manager.service.simulate_trade import SimulateTradeService
from decimal import Decimal

class Command(BaseCommand):
    help = '运行一个完整的交易策略回测'

    def add_arguments(self, parser: CommandParser):
        parser.add_argument(
            '--start',
            type=str,
            required=True,
            help='回测起始日期 (格式: YYYY-MM-DD)'
        )
        parser.add_argument(
            '--end',
            type=str,
            required=True,
            help='回测结束日期 (格式: YYYY-MM-DD)'
        )
        parser.add_argument(
            '--capital',
            type=Decimal,
            required=True,
            help='初始资金'
        )

    def handle(self, *args, **options):
        start_date = options['start']
        end_date = options['end']
        initial_capital = options['capital']

        self.stdout.write(self.style.SUCCESS(f'===== 开始执行回测任务 ====='))
        self.stdout.write(f'  - 起始日期: {start_date}')
        self.stdout.write(f'  - 结束日期: {end_date}')
        self.stdout.write(f'  - 初始资金: {initial_capital:.2f}')

        try:
            service = SimulateTradeService()
            # 注意：我们将所有参数都传递给 run_backtest 方法
            result = service.run_backtest(
                start_date=start_date,
                end_date=end_date,
                initial_capital=initial_capital
            )
            
            self.stdout.write(self.style.SUCCESS('\n===== 回测执行完毕 ====='))
            self.stdout.write(f'最终性能指标: {result}')

        except Exception as e:
            self.stdout.write(self.style.ERROR(f'回测过程中发生严重错误: {e}'))
            # 在生产环境中，可能需要更详细的错误处理和日志记录
            raise e


####文件结束####

####trade_manager\management\commands\run_scheduler.py####
# trade_manager/management/commands/run_scheduler.py

from django.core.management.base import BaseCommand
from trade_manager.service import scheduler_service
import logging
import time
logger = logging.getLogger(__name__)
class Command(BaseCommand):
    help = '启动自动化交易的 APScheduler 调度器'

    def handle(self, *args, **options):
        self.stdout.write(self.style.SUCCESS('正在启动调度器服务...'))
        scheduler_service.start()
        try:
            # 这是关键：让主进程进入一个无限循环，以防止脚本退出
            # 这样后台的调度器线程才能一直存活
            while True:
                time.sleep(1)  # 每秒检查一次，降低CPU占用
        except (KeyboardInterrupt, SystemExit):
            # 当接收到退出信号时（如Ctrl+C或uWSGI的停止命令）
            # 优雅地关闭调度器
            logger.info("接收到退出信号，正在关闭调度器...")
            scheduler_service.scheduler.shutdown()
            logger.info("调度器已成功关闭。")
            self.stdout.write(self.style.SUCCESS('调度器服务已优雅地停止。'))
        self.stdout.write(self.style.SUCCESS('调度器服务已停止。'))


####文件结束####

####trade_manager\service\backtest_reporter.py####
# ==============================================================================
# 文件 3/5: trade_manager/service/backtest_reporter.py (新增)
# 描述: 负责生成和发送回测邮件报告的模块。
# ==============================================================================
import base64
import io
import logging
from datetime import date
from decimal import Decimal
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import matplotlib.dates as mdates

import pandas as pd
from django.db import connections

from common.models.backtest_logs import BacktestDailyLog, BacktestOperationLog
from common.models.positions import Position
from data_manager.service.email_handler import EmailHandler

logger = logging.getLogger(__name__)

class BacktestReporter:
    """
    回测报告生成与发送器。
    """
    def __init__(self, schema_name: str, start_date: date, current_date: date, initial_capital: Decimal):
        self.schema_name = schema_name
        self.start_date = start_date
        self.current_date = current_date
        self.initial_capital = initial_capital
        self.email_handler = EmailHandler()
        self.recipients = ['876858298@qq.com']#'850696281@qq.com','285173686@qq.com'
    def _execute_query(self, query: str, params: list = None) -> list[dict]:
        """在指定 schema 中执行原生 SQL 查询并返回结果"""
        with connections['default'].cursor() as cursor:
            cursor.execute(f'SET search_path TO "{self.schema_name}", public;')
            cursor.execute(query, params or [])
            columns = [col[0] for col in cursor.description]
            return [dict(zip(columns, row)) for row in cursor.fetchall()]

    def _generate_report_data(self) -> dict:
        """准备邮件报告所需的所有数据"""
        data = {}

        # 1. 关键指标
        daily_logs = self._execute_query(
            f"SELECT trade_date, total_assets FROM {BacktestDailyLog._meta.db_table} ORDER BY trade_date"
        )
        df_daily = pd.DataFrame(daily_logs)
        df_daily['total_assets'] = df_daily['total_assets'].astype(float)
        
        # 胜率
        sell_ops = self._execute_query(
            f"SELECT exit_reason FROM {BacktestOperationLog._meta.db_table} WHERE direction = 'SELL'"
        )
        if sell_ops:
            total_sells = len(sell_ops)
            profit_sells = sum(1 for op in sell_ops if op['exit_reason'] == 'TAKE_PROFIT')
            data['win_rate'] = profit_sells / total_sells if total_sells > 0 else 0.0
        else:
            data['win_rate'] = 0.0
        
        # 最大回撤
        df_daily['peak'] = df_daily['total_assets'].cummax()
        df_daily['drawdown'] = (df_daily['total_assets'] - df_daily['peak']) / df_daily['peak']
        data['max_drawdown'] = df_daily['drawdown'].min() if not df_daily.empty else 0.0

        # 年化收益率
        final_assets = float(df_daily['total_assets'].iloc[-1]) if not df_daily.empty else float(self.initial_capital)
        days_passed = (self.current_date - self.start_date).days
        if days_passed > 0:
            data['annualized_return'] = ((final_assets / float(self.initial_capital)) ** (365.0 / days_passed)) - 1
        else:
            data['annualized_return'] = 0.0

        # 2. 资金曲线图数据
        data['plot_data'] = self._execute_query(
            f"SELECT trade_date, total_assets, market_m_value FROM {BacktestDailyLog._meta.db_table} ORDER BY trade_date"
        )

        # 3. 当前持仓
        data['current_holdings'] = self._execute_query(
            f"""
            SELECT p.stock_code, si.stock_name, p.entry_price, p.quantity, 
                   p.current_take_profit, p.current_stop_loss, dq.close as current_price
            FROM {Position._meta.db_table} p
            JOIN public.tb_stock_info si ON p.stock_code = si.stock_code
            LEFT JOIN public.tb_daily_quotes dq ON p.stock_code = dq.stock_code AND dq.trade_date = %s
            WHERE p.status = 'open'
            """, [self.current_date]
        )
        for h in data['current_holdings']:
            h['profit_rate'] = (h['current_take_profit'] / h['entry_price']) - 1 if h['entry_price'] > 0 else 0
            h['loss_rate'] = 1 - (h['current_stop_loss'] / h['entry_price']) if h['entry_price'] > 0 else 0

        # 4. 收益排名
        all_ops = self._execute_query(f"SELECT stock_code, stock_name, direction, amount FROM {BacktestOperationLog._meta.db_table}")
        profits = {}
        for op in all_ops:
            key = (op['stock_code'], op['stock_name'])
            if op['direction'] == 'BUY':
                profits[key] = profits.get(key, 0) - op['amount']
            else: # SELL
                profits[key] = profits.get(key, 0) + op['amount']
        # 总收益 = 已实现盈亏 + 未实现盈亏
        #        = (卖出总额 - 买入总额) + (当前市值 - 持仓成本)
        #        = (卖出总额) - (已平仓部分的买入成本) + (当前市值)
        # 之前的循环已经计算了 (卖出总额 - 全部买入成本)，所以我们只需加上当前市值即可。
        for holding in data['current_holdings']:
            key = (holding['stock_code'], holding['stock_name'])
            
            # 处理当天可能没有行情数据的情况，若无当前价则按入场价计算，浮动盈亏为0
            current_price = holding['current_price'] or holding['entry_price']
            
            # 计算当前持仓的总市值
            current_market_value = holding['quantity'] * current_price
            
            # 将当前市值加到该股票的累计收益中
            profits[key] = profits.get(key, 0) + current_market_value
        profit_list = [{'stock_code': k[0], 'stock_name': k[1], 'profit': v} for k, v in profits.items()]
        data['profit_ranking'] = sorted(profit_list, key=lambda x: x['profit'], reverse=True)

        return data

    def _generate_plot_base64(self, plot_data: list[dict]) -> str:
        if not plot_data:
            return ""
        
        try:
            plt.rcParams['font.sans-serif'] = ['SimHei', 'Microsoft YaHei']
            plt.rcParams['axes.unicode_minus'] = False
        except Exception as e:
            pass
        
        try:
            df = pd.DataFrame(plot_data)
            # 确保数据类型正确
            df['trade_date'] = pd.to_datetime(df['trade_date'])
            df['total_assets'] = pd.to_numeric(df['total_assets'])
            df['market_m_value'] = pd.to_numeric(df['market_m_value'])

            if df.empty:
                return ""

            plt.style.use('seaborn-v0_8-whitegrid')
            fig, ax1 = plt.subplots(figsize=(14, 7))

            # 绘制主曲线
            ax1.plot(df['trade_date'], df['total_assets'], color='dodgerblue', label='money', linewidth=2)
            ax1.set_xlabel('date', fontsize=12)
            ax1.set_ylabel('money', color='dodgerblue', fontsize=12)
            ax1.tick_params(axis='y', labelcolor='dodgerblue')
            ax1.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: format(int(x), ',')))

            # 绘制副坐标轴曲线
            ax2 = ax1.twinx()
            ax2.plot(df['trade_date'], df['market_m_value'], color='coral', linestyle='--', label='M', alpha=0.7)
            ax2.set_ylabel('M', color='coral', fontsize=12)
            ax2.tick_params(axis='y', labelcolor='coral')
            ax2.axhline(0, color='grey', linestyle=':', linewidth=1)

            # ======================= 主要修改点 =======================
            # 1. 更健壮和简化的X轴刻度逻辑
            num_days = (df['trade_date'].max() - df['trade_date'].min()).days
            
            if num_days <= 60:  # 2个月以内，按周显示
                locator = mdates.WeekdayLocator(byweekday=mdates.MO)
                formatter = mdates.DateFormatter('%m-%d')
            elif num_days <= 365 * 2: # 2年以内，按季度显示
                locator = mdates.MonthLocator(interval=3)
                formatter = mdates.DateFormatter('%Y-%m')
            elif num_days <= 365 * 5: # 5年以内，按半年显示
                locator = mdates.MonthLocator(interval=6)
                formatter = mdates.DateFormatter('%Y-%m')
            else:  # 超过5年，按年显示
                locator = mdates.YearLocator()
                formatter = mdates.DateFormatter('%Y')
            
            ax1.xaxis.set_major_locator(locator)
            ax1.xaxis.set_major_formatter(formatter)

            # 2. 移除 fig.autofmt_xdate()，并手动设置标签旋转，避免冲突
            plt.setp(ax1.get_xticklabels(), rotation=30, ha='right')
            # ========================================================

            fig.suptitle('Money-M(t)', fontsize=16, weight='bold')
            fig.legend(loc='upper left', bbox_to_anchor=(0.1, 0.9))
            
            # 使用 tight_layout 替代
            plt.tight_layout(rect=[0, 0, 1, 0.96])

            # 保存图像到内存
            buf = io.BytesIO()
            plt.savefig(buf, format='png', dpi=100)
            plt.close(fig)
            buf.seek(0)
            return base64.b64encode(buf.getvalue()).decode('utf-8')
        finally:
            pass



    def _format_html_content(self, data: dict, plot_base64: str) -> str:
        
        # ======================= 修复颜色逻辑 =======================
        # 修复：盈利 (value > 0) 为绿色，亏损 (value < 0) 为红色
        def get_row_style(value):
            if value > 0:
                return 'style="background-color: #e9f5e9; color: #1e7e34;"'  # 绿色背景，深绿色文字
            elif value < 0:
                return 'style="background-color: #fdeaea; color: #c82333;"'  # 红色背景，深红色文字
            else:
                return '' # 中性
        # ==========================================================
        # Part 1: Key Metrics
        html = f"""
        <h2>关键指标 (截至 {self.current_date.strftime('%Y-%m-%d')})</h2>
        <table class="summary-table">
            <tr>
                <th>胜率</th><td>{data['win_rate']:.2%}</td>
                <th>最大回撤</th><td style="color: #c82333;">{data['max_drawdown']:.2%}</td>
                <th>年化收益率</th><td>{data['annualized_return']:.2%}</td>
            </tr>
        </table>
        """
        # Part 2: Plot
        html += f"""
        <h2>资金与M值变化趋势</h2>
        <div style="text-align: center;">
            <img src="data:image/png;base64,{plot_base64}" alt="Performance Chart" style="max-width: 100%;">
        </div>
        """
        # Part 3: Current Holdings
        html += "<h2>当前持仓情况</h2>"
        if data['current_holdings']:
            html += """
            <table class="data-table">
                <thead><tr><th>股票代码</th><th>股票名称</th><th>入场价</th><th>当前价</th><th>浮动盈亏</th><th>止盈价格</th><th>止损价格</th><th>预设止盈率</th><th>预设止损率</th></tr></thead>
                <tbody>
            """
            for h in data['current_holdings']:
                current_price = h['current_price'] or h['entry_price']
                profit_loss = current_price - h['entry_price']
                profit_loss_rate = (current_price / h['entry_price'] - 1) if h['entry_price'] else 0
                style = get_row_style(profit_loss)
                html += f"""
                <tr {style}>
                    <td>{h['stock_code']}</td>
                    <td>{h['stock_name']}</td>
                    <td>{h['entry_price']:.2f}</td>
                    <td>{current_price:.2f}</td>
                    <td>{profit_loss_rate:.2%}</td>
                    <td>{h['current_take_profit']:.2f}</td>
                    <td>{h['current_stop_loss']:.2f}</td>
                    <td>{h['profit_rate']:.2%}</td>
                    <td>{h['loss_rate']:.2%}</td>
                </tr>
                """
            html += "</tbody></table>"
        else:
            html += "<p>当前无持仓。</p>"
        # Part 4: Profit Ranking
        html += "<h2>各股累计收益排名</h2>"
        if data['profit_ranking']:
            html += """
            <table class="data-table">
                <thead><tr><th>排名</th><th>股票代码</th><th>股票名称</th><th>累计收益(元)</th></tr></thead>
                <tbody>
            """
            for i, p in enumerate(data['profit_ranking'], 1):
                # 这里复用上面修改好的颜色逻辑
                style = get_row_style(p['profit'])
                html += f"""
                <tr {style}>
                    <td>{i}</td>
                    <td>{p['stock_code']}</td>
                    <td>{p['stock_name']}</td>
                    <td>{p['profit']:,.2f}</td>
                </tr>
                """
            html += "</tbody></table>"
        else:
            html += "<p>暂无已平仓的交易。</p>"
        # Final HTML structure (保持不变)
        final_html = f"""
        <!DOCTYPE html>
        <html lang="zh-CN">
        <head>
            <meta charset="UTF-8">
            <title>回测报告</title>
            <style>
                body {{ font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; margin: 20px; background-color: #f4f7f6; color: #333; }}
                h2 {{ color: #0056b3; border-bottom: 2px solid #e0e0e0; padding-bottom: 8px; margin-top: 30px; }}
                table {{ width: 100%; border-collapse: collapse; margin-top: 15px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }}
                th, td {{ padding: 12px 15px; text-align: left; border-bottom: 1px solid #ddd; }}
                th {{ background-color: #f8f9fa; }}
                .summary-table th {{ width: 15%; background-color: #e9ecef; }}
                .summary-table td {{ font-weight: bold; font-size: 1.1em; }}
                .data-table tbody tr:hover {{ background-color: #f1f1f1; }}
            </style>
        </head>
        <body>
            <h1>回测进度报告: {self.start_date}~{self.current_date}回测</h1>
            {html}
        </body>
        </html>
        """
        return final_html

    def send_report(self):
        """生成并发送报告邮件"""
        logger.info(f"[{self.schema_name}] 正在生成截至 {self.current_date} 的回测报告...")
        try:
            report_data = self._generate_report_data()
            plot_base64 = self._generate_plot_base64(report_data.get('plot_data', []))
            html_content = self._format_html_content(report_data, plot_base64)
            subject = f"回测报告 ({self.start_date}~{self.current_date}) - {self.current_date.strftime('%Y-%m-%d')}"
            
            self.email_handler.send_email(
                recipients=self.recipients,
                subject=subject,
                html_content=html_content
            )
            logger.info(f"[{self.start_date}~{self.current_date}] 回测报告邮件已成功发送。")
        except Exception as e:
            logger.error(f"[{self.start_date}~{self.current_date}] 生成或发送回测报告时失败: {e}", exc_info=True)


####文件结束####

####trade_manager\service\before_fix_service.py####
# trade_manager/service/before_fix_service.py

import logging
from datetime import date, timedelta, datetime
from decimal import Decimal, ROUND_HALF_UP
from django.utils import timezone
from django.db import transaction
from django.db.models import Q

# 导入项目内的模型
from common.models import (
    CorporateAction,
    DailyTradingPlan,
    Position,
    DailyQuotes,
    SystemLog
)

# 配置日志记录器
logger = logging.getLogger(__name__)


class BeforeFixService:
    """
    T日开盘前校准与预案修正服务。

    职责:
    1. 检查当天是否已成功执行过，防止重复运行。
    2. 获取T日的除权除息事件。
    3. 计算受影响股票的价格调整比率。
    4. 根据比率修正“每日交易预案”中的MIOP和MAOP。
    5. 根据比率修正“持仓信息”中的止盈止损价。
    6. 对近期发生配股的股票进行特殊风险处理。
    """
    MODULE_NAME = '盘前校准与预案修正'
    # 可配置参数
    MAX_PLAN_LOOKBACK_DAYS = 14  # 查找交易预案的最大回溯天数
    RIGHTS_ISSUE_LOOKBACK_DAYS = 30 # 配股事件特殊处理的回溯交易日数

    def __init__(self, execution_date: date = None):
        """
        初始化服务。
        :param execution_date: T日，即执行校准的日期。如果为None，则默认为当天。
        """
        self.t_day = execution_date if execution_date else date.today()
        self.t_minus_1_day = None
        self.adjustment_ratios = {} # 存储 {stock_code: ratio}
        logger.debug(f"[{self.MODULE_NAME}] 服务初始化，目标T日: {self.t_day}")

    def _log_to_db(self, level: str, message: str):
        """辅助方法：将日志写入数据库"""
        try:
            SystemLog.objects.create(
                log_level=level,
                module_name=self.MODULE_NAME,
                message=message
            )
        except Exception as e:
            logger.error(f"无法将日志写入数据库: {e}")

    def _is_trading_day(self, check_date: date) -> bool:
        """检查指定日期是否为交易日"""
        is_trade_day = DailyQuotes.objects.filter(trade_date=check_date).exists()
        logger.info(f"检查日期 {check_date} 是否为交易日: {'是' if is_trade_day else '否'}")
        return is_trade_day

    def _get_last_trading_day(self, from_date: date) -> date | None:
        """获取指定日期之前的最后一个交易日"""
        last_day = DailyQuotes.objects.filter(
            trade_date__lt=from_date
        ).order_by('-trade_date').values_list('trade_date', flat=True).first()
        
        if last_day:
            logger.info(f"{from_date} 的前一个交易日 (T-1) 是: {last_day}")
        else:
            logger.warning(f"无法找到 {from_date} 的前一个交易日。")
        return last_day

    def _find_latest_pending_plan_date(self) -> date | None:
        """从T日开始向前回溯，查找最新的一个包含待执行预案的日期"""
        for i in range(self.MAX_PLAN_LOOKBACK_DAYS):
            check_date = self.t_day - timedelta(days=i)
            if DailyTradingPlan.objects.filter(
                plan_date=check_date,
                status=DailyTradingPlan.StatusChoices.PENDING
            ).exists():
                logger.info(f"找到待执行的交易预案，预案日期为: {check_date}")
                return check_date
        logger.warning(f"在过去 {self.MAX_PLAN_LOOKBACK_DAYS} 天内未找到任何待执行的交易预案。")
        return None

    def _calculate_adjusted_price(self, t_minus_1_close: Decimal, events: list[CorporateAction]) -> Decimal:
        """
        核心算法：根据事件列表计算除权除息参考价。
        处理顺序：1.除息 -> 2.送/转股 -> 3.配股
        """
        adjusted_price = t_minus_1_close
        
        # 按事件类型优先级排序
        event_priority = {
            CorporateAction.EventType.DIVIDEND: 1,
            CorporateAction.EventType.BONUS: 2,
            CorporateAction.EventType.TRANSFER: 2,
            CorporateAction.EventType.SPLIT: 2,
            CorporateAction.EventType.RIGHTS: 3,
        }
        sorted_events = sorted(events, key=lambda e: event_priority.get(e.event_type, 99))

        for event in sorted_events:
            # 1. 现金分红 (除息)
            if event.event_type == CorporateAction.EventType.DIVIDEND and event.dividend_per_share:
                adjusted_price -= event.dividend_per_share
            
            # 2. 送股/转增股/并股/拆股 (除权)
            elif event.event_type in [CorporateAction.EventType.BONUS, CorporateAction.EventType.TRANSFER, CorporateAction.EventType.SPLIT]:
                if event.shares_before and event.shares_after and event.shares_after > 0:
                    adjusted_price = adjusted_price * (event.shares_before / event.shares_after)

            # 3. 配股 (除权) - 注意：按需求，此计算结果不用于常规校准，但逻辑保留
            elif event.event_type == CorporateAction.EventType.RIGHTS:
                if event.shares_before and event.shares_after and event.rights_issue_price is not None and event.shares_after > 0:
                    adjusted_price = (event.shares_before * adjusted_price + (event.shares_after - event.shares_before) * event.rights_issue_price) / event.shares_after
        
        return adjusted_price

    @transaction.atomic
    def run(self):
        """执行盘前校准与修正的主流程"""

        self.t_minus_1_day = self._get_last_trading_day(self.t_day)
        if not self.t_minus_1_day:
            logger.error(f"无法确定T-1日，任务终止。")
            return

        # a. 获取T日所有除权除息信息
        events_on_t_day = CorporateAction.objects.filter(ex_dividend_date=self.t_day)
        if not events_on_t_day.exists():
            logger.debug(f"T日 ({self.t_day}) 无除权除息事件，无需校准。")
            return

        # 按股票代码分组事件
        events_by_stock = {}
        for event in events_on_t_day:
            events_by_stock.setdefault(event.stock_code, []).append(event)
        
        affected_codes = list(events_by_stock.keys())
        logger.info(f"T日共有 {len(affected_codes)} 只股票发生股权事件。")

        # 获取这些股票在T-1日的收盘价
        quotes_qs = DailyQuotes.objects.filter(
            trade_date=self.t_minus_1_day,
            stock_code_id__in=affected_codes
        )
        # 使用字典推导式构建我们需要的映射关系
        quotes_t_minus_1 = {quote.stock_code_id: quote for quote in quotes_qs}

        # b. 计算价格调整比率
        for stock_code, events in events_by_stock.items():
            if stock_code not in quotes_t_minus_1:
                logger.warning(f"股票 {stock_code} 在T-1日({self.t_minus_1_day})无行情数据（可能停牌），跳过校准。")
                continue
            
            close_t_minus_1 = quotes_t_minus_1[stock_code].close
            if close_t_minus_1 <= 0:
                logger.warning(f"股票 {stock_code} 在T-1日收盘价为0或负数，不合理，跳过校准。")
                continue

            adjusted_close = self._calculate_adjusted_price(close_t_minus_1, events)
            ratio = adjusted_close / close_t_minus_1
            self.adjustment_ratios[stock_code] = ratio
            logger.info(f"股票 {stock_code}: T-1收盘价={close_t_minus_1}, 校准后价格={adjusted_close:.2f}, 调整比率={ratio:.6f}")

        # c. 修正交易预案
        self._process_trading_plans()

        # d. 修正持仓风控
        self._process_positions()

        # e. 配股事件特殊处理
        self._handle_rights_issue_special_case()

        logger.info(f"[{self.MODULE_NAME}] 任务成功完成。共处理 {len(self.adjustment_ratios)} 只股票的常规校准。")

    def _process_trading_plans(self):
        """修正交易预案中的MIOP和MAOP"""
        plan_date_to_fix = self._find_latest_pending_plan_date()
        if not plan_date_to_fix:
            return

        plans_to_fix = DailyTradingPlan.objects.filter(
            plan_date=plan_date_to_fix,
            status=DailyTradingPlan.StatusChoices.PENDING,
            stock_code__in=self.adjustment_ratios.keys()
        )

        plans_to_update = []
        for plan in plans_to_fix:
            ratio = self.adjustment_ratios[plan.stock_code_id]
            original_miop = plan.miop
            original_maop = plan.maop
            
            plan.miop = (original_miop * Decimal(str(ratio))).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            plan.maop = (original_maop * Decimal(str(ratio))).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            
            plans_to_update.append(plan)
            logger.info(f"交易预案修正: {plan.stock_code}, MIOP: {original_miop}->{plan.miop}, MAOP: {original_maop}->{plan.maop}")

        if plans_to_update:
            DailyTradingPlan.objects.bulk_update(plans_to_update, ['miop', 'maop'])
            logger.info(f"成功批量更新 {len(plans_to_update)} 条交易预案。")

    def _process_positions(self):
        """修正持仓中的止盈止损价"""
        positions_to_fix = Position.objects.filter(
            status=Position.StatusChoices.OPEN,
            stock_code__in=self.adjustment_ratios.keys()
        )

        positions_to_update = []
        for pos in positions_to_fix:
            ratio = self.adjustment_ratios[pos.stock_code_id]
            original_sl = pos.current_stop_loss
            original_tp = pos.current_take_profit

            pos.current_stop_loss = (original_sl * Decimal(str(ratio))).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            pos.current_take_profit = (original_tp * Decimal(str(ratio))).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            
            positions_to_update.append(pos)
            logger.info(f"持仓风控修正: {pos.stock_code}, 止损: {original_sl}->{pos.current_stop_loss}, 止盈: {original_tp}->{pos.current_take_profit}")

        if positions_to_update:
            Position.objects.bulk_update(positions_to_update, ['current_stop_loss', 'current_take_profit'])
            logger.info(f"成功批量更新 {len(positions_to_update)} 条持仓记录。")

    def _handle_rights_issue_special_case(self):
        """处理30个交易日内有配股事件的股票"""
        # 1. 获取过去30个交易日的日期列表
        recent_trading_days = list(
            DailyQuotes.objects.filter(trade_date__lte=self.t_day)
            .order_by('-trade_date')
            .values_list('trade_date', flat=True)[:self.RIGHTS_ISSUE_LOOKBACK_DAYS]
        )
        if not recent_trading_days:
            logger.warning("无法获取最近交易日列表，跳过配股特殊处理。")
            return

        # 2. 查找在此期间发生配股的股票
        rights_issue_stocks = list(
            CorporateAction.objects.filter(
                event_type=CorporateAction.EventType.RIGHTS,
                ex_dividend_date__in=recent_trading_days
            ).values_list('stock_code', flat=True).distinct()
        )
        if not rights_issue_stocks:
            logger.info("近期无配股事件，无需特殊处理。")
            return
        
        logger.warning(f"检测到 {len(rights_issue_stocks)} 只股票近期有配股事件: {rights_issue_stocks}，将进行风险剔除。")

        # 3. 处理交易预案
        plan_date_to_fix = self._find_latest_pending_plan_date()
        if plan_date_to_fix:
            plans_to_void = DailyTradingPlan.objects.filter(
                plan_date=plan_date_to_fix,
                status=DailyTradingPlan.StatusChoices.PENDING,
                stock_code__in=rights_issue_stocks
            )
            plans_to_update = []
            for plan in plans_to_void:
                plan.miop = Decimal('99999.00')
                plan.maop = Decimal('0.00')
                plans_to_update.append(plan)
            
            if plans_to_update:
                DailyTradingPlan.objects.bulk_update(plans_to_update, ['miop', 'maop'])
                logger.info(f"配股风险处理：将 {len(plans_to_update)} 条交易预案的MIOP/MAOP置为无效。")

        # 4. 处理持仓
        positions_to_void = Position.objects.filter(
            status=Position.StatusChoices.OPEN,
            stock_code__in=rights_issue_stocks
        )
        positions_to_update = []
        for pos in positions_to_void:
            pos.current_take_profit = Decimal('0.00')
            pos.current_stop_loss = Decimal('99999.00')
            positions_to_update.append(pos)
        
        if positions_to_update:
            Position.objects.bulk_update(positions_to_update, ['current_take_profit', 'current_stop_loss'])
            logger.info(f"配股风险处理：将 {len(positions_to_update)} 条持仓的止盈/止损置为紧急退出状态。")


# --- 如何在项目中使用这个服务 ---
# 你可以在一个Django Management Command或者定时任务（如Celery）中调用它
#
# from trade_manager.service.before_fix_service import BeforeFixService
#
# def run_daily_premarket_fix():
#     # 默认使用当天日期
#     service = BeforeFixService()
#     service.run()
#
# def run_backtest_premarket_fix(some_date):
#     # 传入指定日期进行回测
#     service = BeforeFixService(execution_date=some_date)
#     service.run()


####文件结束####

####trade_manager\service\db_utils.py####
# trade_manager/service/db_utils.py

import contextlib
import logging
import threading
from django.db import connections
from django.db.backends.signals import connection_created

logger = logging.getLogger(__name__)

# 使用线程局部存储来安全地在多线程环境中传递 schema 名称
_db_context = threading.local()

def backtest_schema_handler(sender, connection, **kwargs):
    """
    Django `connection_created` 信号的处理器。
    当一个新的数据库连接被创建时，此函数会被调用。
    它会检查当前线程是否在 `use_backtest_schema` 上下文中，
    如果是，则立即为这个新连接设置正确的 search_path。
    """
    if hasattr(_db_context, 'schema_name') and _db_context.schema_name:
        schema_name = _db_context.schema_name
        logger.debug(f"新数据库连接创建，为其设置 search_path -> {schema_name}, public")
        with connection.cursor() as cursor:
            # 使用参数化查询防止SQL注入
            cursor.execute("SET search_path TO %s, public;", [schema_name])

# 将信号处理器连接到 `connection_created` 信号
# dispatch_uid 确保即使代码被多次导入，信号处理器也只连接一次
connection_created.connect(backtest_schema_handler, dispatch_uid="set_backtest_search_path")

@contextlib.contextmanager
def use_backtest_schema(schema_name: str):
    """
    一个上下文管理器，用于在特定代码块内将所有数据库操作重定向到指定的 schema。

    用法:
    with use_backtest_schema('my_backtest_schema'):
        # 此处所有的 Django ORM 操作都会在 'my_backtest_schema' 中进行
        MyModel.objects.create(...)
    """
    # 进入 with 块时，设置线程局部变量
    _db_context.schema_name = schema_name
    # 强制关闭当前线程的现有连接，以确保下一个查询会创建一个新连接，从而触发信号处理器
    connections['default'].close()
    try:
        # 将控制权交还给 with 块内的代码
        yield
    finally:
        # 退出 with 块时（无论成功还是异常），清理线程局部变量
        if hasattr(_db_context, 'schema_name'):
            del _db_context.schema_name
        # 再次关闭连接，以便后续操作能恢复到默认的 search_path
        connections['default'].close()
        logger.debug("已退出回测 schema 上下文，恢复默认 search_path。")


####文件结束####

####trade_manager\service\decision_order_service.py####
# trade_manager/service/decision_order_service.py
# 版本: 2.0 - M(t)驱动的动态风险管理
# 描述: 此版本重构了止盈止损计算逻辑，使其与动态选股策略的市场状态判断(M(t))保持一致。
#       解决了旧版在非趋势行情中止损价可能高于止盈价的严重逻辑问题。

import logging
from datetime import date, timedelta
from decimal import Decimal, ROUND_HALF_UP
import pandas as pd
import pandas_ta as ta

from django.db import transaction
from django.utils import timezone

from common.models import (
    DailyTradingPlan,
    Position,
    TradeLog,
    StrategyParameters,
    DailyQuotes,
    SystemLog,
    DailyFactorValues  # 新增导入
)
from .trade_handler import ITradeHandler
from selection_manager.service.selection_service import MARKET_INDICATOR_CODE # 新增导入

# 配置日志记录器
logger = logging.getLogger(__name__)

class DecisionOrderService:
    """
    开盘决策与下单模块 (V2.0 - 动态风险版)。

    该服务负责在T日开盘后的黄金时间内，根据预案、实际开盘价和账户状态，
    做出最终的买入决策，并执行下单。其核心特色是，在订单成交后，
    能够根据T-1日的市场状态M(t)，为新持仓计算动态的、自适应的止盈止损价。
    """
    MODULE_NAME = '开盘决策与下单(动态风险版)'
    MAX_PLAN_LOOKBACK_DAYS = 14

    def __init__(self, handler: ITradeHandler, execution_date: date = None):
        """
        初始化服务。

        :param handler: 一个实现了 ITradeHandler 接口的实例，用于与交易环境交互。
        :param execution_date: T日，即执行决策的日期。如果为None，则默认为当天。
        """
        if not isinstance(handler, ITradeHandler):
            raise TypeError("传入的 handler 必须是 ITradeHandler 的一个实例。")
      
        self.handler = handler
        self.execution_date = execution_date if execution_date else date.today()
        self.params = self._load_strategy_parameters()
      
        # 新增：用于存储当日动态计算结果的实例变量
        self.current_max_positions = 0
        self.final_nominal_principal = Decimal('0.0')
 
        # 【全新】调用新的初始化引擎
        self._initialize_position_sizing_engine()
      
        logger.debug(f"[{self.MODULE_NAME}] 服务初始化。执行T日: {self.execution_date}")
        logger.debug(f"策略参数加载成功: {len(self.params)}个")
        logger.debug(f"当日动态最大持仓数: {self.current_max_positions}")
        logger.debug(f"当日动态单位名义本金: {self.final_nominal_principal:.2f}")

    def _initialize_position_sizing_engine(self):
        """
        【全新方法】
        在服务初始化时，完成所有基于T-1日M(t)的仓位 sizing 计算。
        """
        try:
            # 1. 获取T-1交易日
            t_minus_1_date = DailyQuotes.objects.filter(trade_date__lt=self.execution_date).latest('trade_date').trade_date
        except DailyQuotes.DoesNotExist:
            logger.error(f"无法找到 {self.execution_date} 的前一个交易日，动态仓位管理无法启动，将使用默认值。")
            self.current_max_positions = self.params.get('MIN_POSITIONS_COUNT', 1)
            self.final_nominal_principal = Decimal('0.0') # 导致无法买入
            return
 
        # 2. 获取T-1日的市场状态M(t)
        market_regime_M = self._get_market_regime_M(t_minus_1_date)
        logger.info(f"获取到 T-1 ({t_minus_1_date}) 的 M(t) = {market_regime_M:.4f}")
 
        # 3. 计算当日动态最大持仓数
        self.current_max_positions = self._calculate_dynamic_max_positions(market_regime_M)
        
        # 4. 计算当日动态单位名义本金
        self.final_nominal_principal = self._calculate_dynamic_nominal_principal(market_regime_M, t_minus_1_date)
 
    def _get_market_regime_M(self, t_minus_1_date: date) -> Decimal:
        """
        【全新方法】
        从数据库获取指定日期的 M(t) 值。
        """
        try:
            m_value_record = DailyFactorValues.objects.get(
                stock_code_id=MARKET_INDICATOR_CODE,
                trade_date=t_minus_1_date,
                factor_code_id='dynamic_M_VALUE'
            )
            return m_value_record.raw_value
        except DailyFactorValues.DoesNotExist:
            logger.error(f"严重警告: 无法在 {t_minus_1_date} 找到市场状态M(t)值！将使用最保守的中性值0.0进行计算。")
            return Decimal('0.0')
 
    def _calculate_dynamic_max_positions(self, M_t: Decimal) -> int:
        """
        【全新方法】
        根据M(t)计算动态最大持仓数 Current_Max_Positions。
        """
        S_min_pos = self.params['RISK_ADJ_POS_FLOOR_PCT']
        
        # i. 计算总仓位数风险缩放因子 S_pos(M(t))
        S_pos = S_min_pos + (1 - S_min_pos) * (M_t + 1) / 2
        
        # ii. 计算理论最大仓位数
        base_max_pos = self.params['ORIGINAL_MAX_POSITIONS']
        theoretical_max = Decimal(base_max_pos) * S_pos
        
        # iii. 取整并应用下限
        min_pos_count = self.params['MIN_POSITIONS_COUNT']
        current_max_positions = max(min_pos_count, int(theoretical_max.to_integral_value(rounding='ROUND_FLOOR')))
        
        logger.debug(f"动态持仓数计算: S_pos={S_pos:.4f}, 理财持仓={theoretical_max:.2f}, 最终取整={current_max_positions}")
        return current_max_positions
 
    def _calculate_dynamic_nominal_principal(self, M_t: Decimal, t_minus_1_date: date) -> Decimal:
        """
        【全新方法】
        根据M(t)计算动态单位名义本金 Final_Nominal_Principal。
        """
        # i. 获取当前总资产
        cash_balance = self.handler.get_available_balance()
        positions_market_value = Decimal('0.0')
        open_positions = Position.objects.filter(status=Position.StatusChoices.OPEN)
        if open_positions.exists():
            for pos in open_positions:
                try:
                    quote = DailyQuotes.objects.get(stock_code_id=pos.stock_code_id, trade_date=t_minus_1_date)
                    positions_market_value += quote.close * pos.quantity
                except DailyQuotes.DoesNotExist:
                    positions_market_value += pos.entry_price * pos.quantity
        
        total_assets = cash_balance + positions_market_value
        logger.debug(f"总资产计算: 现金{cash_balance:.2f} + 持仓市值{positions_market_value:.2f} = {total_assets:.2f}")
 
        # ii. 计算基准单位名义本金
        base_max_pos = self.params['ORIGINAL_MAX_POSITIONS']
        if base_max_pos <= 0: return Decimal('0.0')
        baseline_unit_principal = total_assets / Decimal(base_max_pos)
        
        # iii. 计算单位名义本金风险缩放因子 S_cap(M(t))
        S_min_cap = self.params['RISK_ADJ_CAPITAL_FLOOR_PCT']
        S_cap = S_min_cap + (1 - S_min_cap) * (M_t + 1) / 2
        S_cap=1
        # iv. 计算动态调整后的名义本金
        adjusted_unit_principal = baseline_unit_principal * S_cap
        
        logger.debug(f"动态名义本金计算: 基准本金={baseline_unit_principal:.2f}, S_cap={S_cap:.4f}, 调整后本金={adjusted_unit_principal:.2f}")
        
        # v. 确定最终下单名义本金 - 注意：与可用现金的比较将在下单时进行
        return adjusted_unit_principal

    def _log_to_db(self, level: str, message: str):
        """辅助方法：将日志写入数据库"""
        # 在高频回测中可以注释掉此方法以提高性能
        # SystemLog.objects.create(
        #     log_level=level,
        #     module_name=self.MODULE_NAME,
        #     message=message
        # )
        pass
    def _find_relevant_plan_date(self) -> date | None:
        # 1. 计算查询的起始日期
        start_date = self.execution_date - timedelta(days=self.MAX_PLAN_LOOKBACK_DAYS - 1)
        
        # 2. 执行一次数据库查询
        latest_plan = DailyTradingPlan.objects.filter(
            plan_date__gte=start_date,  # gte = greater than or equal to (大于等于)
            plan_date__lte=self.execution_date, # lte = less than or equal to (小于等于)
            status=DailyTradingPlan.StatusChoices.PENDING
        ).order_by('-plan_date').first() # 按日期降序排列，并取第一个
    
        # 3. 处理查询结果
        if latest_plan:
            found_date = latest_plan.plan_date
            if found_date != self.execution_date:
                logger.info(f"执行日 {self.execution_date} 无预案，回溯找到待执行预案，其生成日期为: {found_date}")
            else:
                logger.debug(f"找到当天 {found_date} 的待执行预案。")
            return found_date
        
        # 如果查询结果为空
        logger.warning(f"在过去 {self.MAX_PLAN_LOOKBACK_DAYS} 天内（从 {self.execution_date} 开始回溯）未找到任何待执行的交易预案。")
        return None
    def _load_strategy_parameters(self) -> dict:
        """从数据库加载所有策略参数到内存"""
        params = {}
        # 定义需要加载的参数及其默认值
        # 注意：这里的键名应与 initialize_strategy_parameters 中定义的完全一致
        required_params = {
            # 通用参数
            #'MAX_POSITIONS': '3',
            'MAX_CAPITAL_PER_POSITION': '20000.00',
            'k_slip': '0.002',
            'lookback_atr': '14',
            # 新版动态风险参数
            'risk_adj_tp_pct_min': '0.07',
            'risk_adj_tp_pct_max': '0.15',
            'risk_adj_sl_atr_min': '1.2',
            'risk_adj_sl_atr_max': '2.2',
            'risk_adj_max_loss_pct': '0.08',
            # 全新动态仓位参数
            'ORIGINAL_MAX_POSITIONS': '5',
            'MIN_POSITIONS_COUNT': '1',
            'RISK_ADJ_POS_FLOOR_PCT': '0.2',
            'RISK_ADJ_CAPITAL_FLOOR_PCT': '0.5',
        }
      
        db_params = {p.param_name: p.param_value for p in StrategyParameters.objects.all()}
      
        for key, default_value in required_params.items():
            value = db_params.get(key, Decimal(str(default_value)))
            if key in ['ORIGINAL_MAX_POSITIONS', 'MIN_POSITIONS_COUNT', 'lookback_atr']:
                params[key] = int(value)
            else:
                params[key] = Decimal(str(value))
        return params

    # --- 暴露给外部调度的核心函数 ---

    def adjust_trading_plan_daily(self):
        """
        函数一：执行每日交易预案再调整 (逻辑不变)。
        """
        logger.debug(f"开始执行 {self.execution_date} 的交易预案二次筛选...")
        relevant_plan_date = self._find_relevant_plan_date()
        if not relevant_plan_date:
            msg = f"在 {self.execution_date} 及之前 {self.MAX_PLAN_LOOKBACK_DAYS} 天内没有找到任何待执行的交易预案。"
            logger.debug(msg)
            self._log_to_db('WARNING', msg)
            return
        plans_today = DailyTradingPlan.objects.filter(
            plan_date=relevant_plan_date,
            status=DailyTradingPlan.StatusChoices.PENDING
        ).order_by('rank')

        if not plans_today.exists():
            msg = f"在 {self.execution_date} 没有找到待执行的交易预案。"
            logger.debug(msg)
            self._log_to_db('WARNING', msg)
            return

        plans_to_cancel = []
        for plan in plans_today:
            try:
                open_price = self.handler.get_opening_price(plan.stock_code_id)
                if open_price <= 0:
                    logger.warning(f"股票 {plan.stock_code_id} 开盘价为0或无效，视为不符合条件。")
                    plan.status = DailyTradingPlan.StatusChoices.CANCELLED
                    plans_to_cancel.append(plan)
                    continue

                if not (plan.miop <= open_price <= plan.maop):
                    msg = (f"预案 {plan.stock_code_id} (Rank:{plan.rank}) 开盘价 {open_price} "
                           f"不在区间 [{plan.miop}, {plan.maop}] 内，已作废。")
                    logger.debug(msg)
                    plan.status = DailyTradingPlan.StatusChoices.CANCELLED
                    plans_to_cancel.append(plan)

            except Exception as e:
                msg = f"获取 {plan.stock_code_id} 开盘价时发生错误: {e}，该预案作废。"
                logger.error(msg)
                self._log_to_db('ERROR', msg)
                plan.status = DailyTradingPlan.StatusChoices.CANCELLED
                plans_to_cancel.append(plan)

        if plans_to_cancel:
            with transaction.atomic():
                DailyTradingPlan.objects.bulk_update(plans_to_cancel, ['status'])
            logger.debug(f"成功作废 {len(plans_to_cancel)} 条不符合开盘条件的交易预案。")
        else:
            logger.debug("所有待执行预案均符合开盘价条件。")

    def execute_orders(self):
        """
        函数二：进行下单 (逻辑不变)。
        """
        logger.debug(f"开始执行 {self.execution_date} 的下单流程...")

        open_positions_count = Position.objects.filter(status=Position.StatusChoices.OPEN).count()
        # 使用动态计算的当日最大持仓数
        remaining_slots = self.current_max_positions - open_positions_count

        if remaining_slots <= 0:
            msg = f"当前持仓数 {open_positions_count} 已达或超过当日动态上限 {self.current_max_positions}，不进行买入。"
            logger.debug(msg)
            self._log_to_db('WARNING', msg)
            return

        relevant_plan_date = self._find_relevant_plan_date()
        if not relevant_plan_date:
            msg = f"在 {self.execution_date} 及之前 {self.MAX_PLAN_LOOKBACK_DAYS} 天内没有找到任何待执行的交易预案可供下单。"
            logger.debug(msg)
            self._log_to_db('INFO', msg)
            return

        candidates = DailyTradingPlan.objects.filter(
            plan_date=relevant_plan_date,
            status=DailyTradingPlan.StatusChoices.PENDING
        ).order_by('rank')
 
        if not candidates.exists():
            msg = f"在 {self.execution_date} 无符合条件的买入标的。"
            logger.debug(msg)
            self._log_to_db('INFO', msg)
            return

        for candidate in candidates:
            try:
                stock_code = candidate.stock_code_id
                open_price = self.handler.get_opening_price(stock_code)
              
                k_slip = self.params['k_slip']
                limit_price = (open_price * (Decimal('1.0') + k_slip)).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
 
                # 获取下单时最终的名义本金
                available_balance = self.handler.get_available_balance()
                
                # self.final_nominal_principal 是已按M(t)调整过的值
                # 再结合硬性风控和流动性约束
                nominal_principal = min(
                    self.final_nominal_principal, 
                    self.params['MAX_CAPITAL_PER_POSITION'], 
                    available_balance
                )
                
                logger.debug(f"标的 {stock_code}: 动态调整后本金={self.final_nominal_principal:.2f}, "
                             f"单仓上限={self.params['MAX_CAPITAL_PER_POSITION']:.2f}, "
                             f"可用现金={available_balance:.2f}. "
                             f"最终名义本金={nominal_principal:.2f}")
 
                if limit_price <= 0:
                    logger.debug(f"标的 {stock_code}: 计算出的下单限价无效（{limit_price}），跳过。")
                    continue
 
                shares_to_buy = int(nominal_principal / limit_price)
                quantity = (shares_to_buy // 100) * 100
 
                if quantity < 100:
                    msg = (f"标的 {stock_code}: 计算出的名义本金 {nominal_principal:.2f} 不足以购买一手（100股）。")
                    logger.warning(msg)
                    self._log_to_db('WARNING', msg)
                    continue
 
                msg = (f"确定唯一买入标的: {candidate.stock_code.stock_name}({stock_code}) (Rank:{candidate.rank})。 "
                       f"计划以限价 {limit_price} 买入 {quantity} 股。")
                logger.info(msg)
                self._log_to_db('INFO', msg)
              
                self.handler.place_buy_order(stock_code, limit_price, quantity)
              
                candidate.status = DailyTradingPlan.StatusChoices.EXECUTED
                candidate.save()
 
                return
 
            except Exception as e:
                msg = f"处理候选股 {candidate.stock_code_id} 时发生严重错误: {e}"
                logger.error(msg, exc_info=True)
                self._log_to_db('CRITICAL', msg)
                continue
 
        logger.debug(f"已尝试所有 {len(candidates)} 个候选标的，均未成功买入。")

    def calculate_stop_profit_loss(self, trade_id: int):
        """
        函数三：止盈止损区间计算 (V2.0 重构版)。
        在订单成交后，为新持仓计算并更新由M(t)驱动的动态止盈止损价。
 
        :param trade_id: 已成交的买入交易在 tb_trade_log 中的唯一ID。
        """
        logger.debug(f"开始为 trade_id={trade_id} 计算动态止盈止损区间...")
        try:
            with transaction.atomic():
                # 1. 获取交易和持仓信息
                trade_log = TradeLog.objects.select_for_update().get(
                    trade_id=trade_id,
                    trade_type=TradeLog.TradeTypeChoices.BUY,
                    status=TradeLog.StatusChoices.FILLED
                )
                position = Position.objects.select_for_update().get(pk=trade_log.position_id)
 
                if position.current_stop_loss > 0 and position.current_take_profit > 0:
                    logger.warning(f"Position ID {position.position_id} 似乎已计算过止盈止损，将跳过。")
                    return
 
                stock_code = trade_log.stock_code_id
                aep = trade_log.price
                buy_date = trade_log.trade_datetime.date()
                t_minus_1_date = DailyQuotes.objects.filter(trade_date__lt=buy_date).latest('trade_date').trade_date
              
                # 2. 获取计算所需的核心数据：M(t) 和 ATR
                # 2.1 获取 T-1 日的市场状态 M(t)
                try:
                    m_value_record = DailyFactorValues.objects.get(
                        stock_code_id=MARKET_INDICATOR_CODE,
                        trade_date=t_minus_1_date,
                        factor_code_id='dynamic_M_VALUE'
                    )
                    market_regime_M = m_value_record.raw_value
                except DailyFactorValues.DoesNotExist:
                    logger.error(f"无法找到 {t_minus_1_date} 的市场状态M(t)值！将使用中性值0.0进行计算。")
                    market_regime_M = Decimal('0.0')

                # 2.2 获取计算 ATR 所需的历史行情
                lookback_days = self.params['lookback_atr'] + 50 # 增加buffer
                start_date_for_calc = t_minus_1_date - timedelta(days=lookback_days * 2)
 
                quotes_qs = DailyQuotes.objects.filter(
                    stock_code_id=stock_code,
                    trade_date__gte=start_date_for_calc,
                    trade_date__lte=t_minus_1_date
                ).order_by('trade_date')
 
                if len(quotes_qs) < self.params['lookback_atr']:
                    raise ValueError(f"股票 {stock_code} 在 {t_minus_1_date} 前的历史数据不足，无法计算ATR。")
 
                df = pd.DataFrame.from_records(quotes_qs.values('high', 'low', 'close'))
                df = df.astype(float)
 
                atr_series = ta.atr(df['high'], df['low'], df['close'], length=self.params['lookback_atr'])
                atr_14_buy = Decimal(str(atr_series.iloc[-1])) if not atr_series.empty else Decimal('0.0')

                # 3. 计算动态止盈价 g_new(y)
                tp_min = self.params['risk_adj_tp_pct_min']
                tp_max = self.params['risk_adj_tp_pct_max']
                tp_pct = tp_min + (tp_max - tp_min) * (market_regime_M + 1) / 2
                take_profit_price = aep * (1 + tp_pct)

                # 4. 计算自适应止损价 h_new(z)
                # 4.1 计算动态ATR乘数 k_h(M(t))
                kh_min = self.params['risk_adj_sl_atr_min']
                kh_max = self.params['risk_adj_sl_atr_max']
                k_h_dynamic = kh_min + (kh_max - kh_min) * (market_regime_M + 1) / 2
                
                # 4.2 计算动态波动止损线
                z1_dynamic_atr = aep - k_h_dynamic * atr_14_buy

                # 4.3 计算绝对最大亏损底线
                z2_max_loss = aep * (1 - self.params['risk_adj_max_loss_pct'])
              
                # 4.4 取最严格的止损位（价格最高者）
                stop_loss_price = max(z1_dynamic_atr, z2_max_loss)
              
                logger.debug(f"[{stock_code}] 止损线比较 (基于M(t)={market_regime_M:.4f}): "
                            f"动态ATR止损(乘数{k_h_dynamic:.2f})={z1_dynamic_atr:.2f}, "
                            f"绝对最大亏损={z2_max_loss:.2f}")
 
                # 5. 更新持仓信息表
                position.current_take_profit = take_profit_price.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
                position.current_stop_loss = stop_loss_price.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
                
                # 最终校验，防止出现极端情况
                if position.current_stop_loss >= position.current_take_profit:
                    logger.critical(f"严重逻辑错误！计算后止损价({position.current_stop_loss})仍高于或等于止盈价({position.current_take_profit})。将使用最大亏损底线作为止损。")
                    position.current_stop_loss = z2_max_loss.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)

                position.save(update_fields=['current_take_profit', 'current_stop_loss'])
                loss_pct = (aep - position.current_stop_loss) / aep if aep > 0 else Decimal('0.0')
                msg = (f"成功计算并更新 Position ID {position.position_id} ({stock_code}) 的动态风控价格: "
                       f"购入价={aep:.2f}, 止盈价={position.current_take_profit:.2f} (目标收益率 {tp_pct:.2%}), "
                       f"止损价={position.current_stop_loss:.2f} (最大容忍亏损 {loss_pct:.2%})")
                logger.info(msg)
                self._log_to_db('INFO', msg)
 
        except TradeLog.DoesNotExist:
            logger.error(f"Trade ID {trade_id} 不存在或不满足计算条件（非买入/未成交）。")
        except Position.DoesNotExist:
            logger.error(f"与 Trade ID {trade_id} 关联的 Position 不存在。")
        except Exception as e:
            msg = f"为 Trade ID {trade_id} 计算动态止盈止损时发生严重错误: {e}"
            logger.critical(msg, exc_info=True)
            self._log_to_db('CRITICAL', msg)
            raise

    # --- 工具函数 ---

    @staticmethod
    def initialize_strategy_parameters():
        """
        工具函数：初始化本模块所需的策略参数到数据库。
        这是一个幂等操作，可以安全地重复运行。
        """
        logger.info("开始初始化[开盘决策与下单模块-动态风险版]的策略参数...")

        params_to_define = {
            # 通用参数
            #'MAX_POSITIONS': {'value': '3', 'group': 'POSITION_MGMT', 'desc': '最大可具备的总仓位数'},
            'MAX_CAPITAL_PER_POSITION': {'value': '20000.00', 'group': 'POSITION_MGMT', 'desc': '每仓最大投入资金数(元)'},
            'k_slip': {'value': '0.002', 'group': 'ORDER_EXEC', 'desc': '下单滑点系数, 用于计算限价单价格'},
            'lookback_atr': {'value': '14', 'group': 'INDICATORS', 'desc': 'ATR计算周期'},
            
            # 新版 M(t) 驱动的动态风险参数
            'risk_adj_tp_pct_min': {'value': '0.07', 'group': 'RISK_ADJUSTED', 'desc': 'M(t)驱动-最小止盈目标百分比 (熊市)'},
            'risk_adj_tp_pct_max': {'value': '0.15', 'group': 'RISK_ADJUSTED', 'desc': 'M(t)驱动-最大止盈目标百分比 (牛市)'},
            'risk_adj_sl_atr_min': {'value': '1.2', 'group': 'RISK_ADJUSTED', 'desc': 'M(t)驱动-最小ATR止损乘数 (熊市)'},
            'risk_adj_sl_atr_max': {'value': '2.2', 'group': 'RISK_ADJUSTED', 'desc': 'M(t)驱动-最大ATR止损乘数 (牛市)'},
            'risk_adj_max_loss_pct': {'value': '0.08', 'group': 'RISK_ADJUSTED', 'desc': 'M(t)驱动-绝对最大亏损百分比'},
            # --- 全新动态仓位管理参数 ---
            'ORIGINAL_MAX_POSITIONS': {'value': '5', 'group': 'DYNAMIC_POS_MGMT', 'desc': '【动态仓位】策略基准最大持仓数'},
            'MIN_POSITIONS_COUNT': {'value': '1', 'group': 'DYNAMIC_POS_MGMT', 'desc': '【动态仓位】最小持仓数硬下限'},
            'RISK_ADJ_POS_FLOOR_PCT': {'value': '0.1', 'group': 'DYNAMIC_POS_MGMT', 'desc': '【动态仓位】总仓位数缩放因子的下限 S_min_pos (例如0.4代表最差情况持有基准的40%)'},
            'RISK_ADJ_CAPITAL_FLOOR_PCT': {'value': '0.6', 'group': 'DYNAMIC_POS_MGMT', 'desc': '【动态仓位】单位名义本金缩放因子的下限 S_min_cap (例如0.6代表最差情况投入基准的60%)'}
        }

        with transaction.atomic():
            for name, data in params_to_define.items():
                StrategyParameters.objects.update_or_create(
                    param_name=name,
                    defaults={
                        'param_value': Decimal(data['value']),
                        'group_name': data['group'],
                        'description': data['desc']
                    }
                )
      
        logger.info(f"成功初始化/更新 {len(params_to_define)} 个动态风险策略参数。")

####文件结束####

####trade_manager\service\decision_order_service_old.py####
# trade_manager/service/decision_order_service.py

import logging
from datetime import date, timedelta
from decimal import Decimal, ROUND_HALF_UP
import pandas as pd
import pandas_ta as ta

from django.db import transaction
from django.utils import timezone

from common.models import (
    DailyTradingPlan,
    Position,
    TradeLog,
    StrategyParameters,
    DailyQuotes,
    SystemLog
)
from .trade_handler import ITradeHandler

# 配置日志记录器
logger = logging.getLogger(__name__)

class DecisionOrderService:
    """
    开盘决策与下单模块。

    该服务负责在T日开盘后的黄金时间内，根据预案、实际开盘价和账户状态，
    做出最终的买入决策，并执行下单。同时，它也提供了在订单成交后计算
    止盈止损区间的功能。
    """
    MODULE_NAME = '开盘决策与下单'

    def __init__(self, handler: ITradeHandler, execution_date: date = None):
        """
        初始化服务。

        :param handler: 一个实现了 ITradeHandler 接口的实例，用于与交易环境交互。
        :param execution_date: T日，即执行决策的日期。如果为None，则默认为当天。
                               此参数为回测模块提供了设置模拟日期的入口。
        """
        if not isinstance(handler, ITradeHandler):
            raise TypeError("传入的 handler 必须是 ITradeHandler 的一个实例。")
        
        self.handler = handler
        self.execution_date = execution_date if execution_date else date.today()
        self.params = self._load_strategy_parameters()
        
        logger.debug(f"[{self.MODULE_NAME}] 服务初始化。执行T日: {self.execution_date}")
        logger.debug(f"策略参数加载成功: {self.params}")

    def _log_to_db(self, level: str, message: str):
        """辅助方法：将日志写入数据库"""
        SystemLog.objects.create(
            log_level=level,
            module_name=self.MODULE_NAME,
            message=message
        )

    def _load_strategy_parameters(self) -> dict:
        """从数据库加载所有策略参数到内存"""
        params = {}
        # 定义需要加载的参数及其默认值，以防数据库中没有
        required_params = {
            'MAX_POSITIONS': 2,
            'MAX_CAPITAL_PER_POSITION': 25000.00,
            'k_slip': 0.002,
            'Base_Target': 0.07,
            'k_g1': 1.5,
            'Max_Target': 0.20,
            'k_h1': 2.0,
            'k_h2': 3.0,
            'Max_Loss_Percent': 0.08,
            'lookback_atr': 14,
            'lookback_adx': 14,
            'lookback_ma20': 20,
            'param_adx_threshold': 25
        }
        
        db_params = {p.param_name: p.param_value for p in StrategyParameters.objects.all()}
        
        for key, default_value in required_params.items():
            # 优先使用数据库中的值，否则使用默认值
            value = db_params.get(key, Decimal(str(default_value)))
            # 将需要整数的参数转换为int
            if key in ['MAX_POSITIONS', 'lookback_atr', 'lookback_adx', 'lookback_ma20', 'param_adx_threshold']:
                params[key] = int(value)
            else:
                params[key] = Decimal(str(value))
        return params

    # --- 暴露给外部调度的核心函数 ---

    def adjust_trading_plan_daily(self):
        """
        函数一：执行每日交易预案再调整。
        根据实际开盘价与剩余仓位进行二次筛选，关闭不会被选择的交易预案。
        """
        logger.debug(f"开始执行 {self.execution_date} 的交易预案二次筛选...")
        
        plans_today = DailyTradingPlan.objects.filter(
            plan_date=self.execution_date,
            status=DailyTradingPlan.StatusChoices.PENDING
        ).order_by('rank')

        if not plans_today.exists():
            msg = f"在 {self.execution_date} 没有找到待执行的交易预案。"
            logger.warning(msg)
            self._log_to_db('WARNING', msg)
            return

        plans_to_cancel = []
        for plan in plans_today:
            try:
                open_price = self.handler.get_opening_price(plan.stock_code)
                if open_price <= 0:
                    logger.warning(f"股票 {plan.stock_code} 开盘价为0或无效，视为不符合条件。")
                    plan.status = DailyTradingPlan.StatusChoices.CANCELLED
                    plans_to_cancel.append(plan)
                    continue

                if not (plan.miop <= open_price <= plan.maop):
                    msg = (f"预案 {plan.stock_code} (Rank:{plan.rank}) 开盘价 {open_price} "
                           f"不在区间 [{plan.miop}, {plan.maop}] 内，已作废。")
                    logger.debug(msg)
                    plan.status = DailyTradingPlan.StatusChoices.CANCELLED
                    plans_to_cancel.append(plan)

            except Exception as e:
                msg = f"获取 {plan.stock_code} 开盘价时发生错误: {e}，该预案作废。"
                logger.error(msg)
                self._log_to_db('ERROR', msg)
                plan.status = DailyTradingPlan.StatusChoices.CANCELLED
                plans_to_cancel.append(plan)

        if plans_to_cancel:
            with transaction.atomic():
                DailyTradingPlan.objects.bulk_update(plans_to_cancel, ['status'])
            logger.info(f"成功作废 {len(plans_to_cancel)} 条不符合开盘条件的交易预案。")
        else:
            logger.info("所有待执行预案均符合开盘价条件。")

    def execute_orders(self):
        """
        函数二：进行下单。
        读取预案表，选择最优标的，计算仓位和价格，并调用处理器执行下单。
        """
        logger.info(f"开始执行 {self.execution_date} 的下单流程...")

        # 1. 检查剩余仓位
        open_positions_count = Position.objects.filter(status=Position.StatusChoices.OPEN).count()
        remaining_slots = self.params['MAX_POSITIONS'] - open_positions_count

        if remaining_slots <= 0:
            msg = f"当前持仓数 {open_positions_count} 已达上限 {self.params['MAX_POSITIONS']}，今日不进行买入操作。"
            logger.warning(msg)
            self._log_to_db('WARNING', msg)
            return

        #2. 获取所有待处理的候选标的
        candidates = DailyTradingPlan.objects.filter(
            plan_date=self.execution_date,
            status=DailyTradingPlan.StatusChoices.PENDING
        ).order_by('rank')
 
        if not candidates.exists():
            msg = f"在 {self.execution_date} 无符合条件的买入标的。"
            logger.info(msg)
            self._log_to_db('INFO', msg)
            return

        # 3. 遍历所有候选标的，直到成功买入一个
        for candidate in candidates:
            try:
                stock_code = candidate.stock_code
                open_price = self.handler.get_opening_price(stock_code)
                
                # 计算下单限价
                k_slip = self.params['k_slip']
                limit_price = (open_price * (Decimal('1.0') + k_slip)).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
 
                # 计算本次交易可用资金
                available_balance = self.handler.get_available_balance()
                capital_per_slot = available_balance / Decimal(remaining_slots)
                nominal_principal = min(capital_per_slot, self.params['MAX_CAPITAL_PER_POSITION'])
 
                # 计算购入股数
                if limit_price <= 0:
                    logger.warning(f"标的 {stock_code}: 计算出的下单限价无效（{limit_price}），跳过。")
                    continue # 尝试下一个候选
 
                shares_to_buy = int(nominal_principal / limit_price)
                quantity = (shares_to_buy // 100) * 100 # 向下取整到100的倍数
 
                if quantity < 100:
                    msg = (f"标的 {stock_code}: 计算出的名义本金 {nominal_principal:.2f} 不足以购买一手（100股），"
                           f"所需金额约为 {limit_price * 100:.2f}。放弃本次交易。")
                    logger.warning(msg)
                    self._log_to_db('WARNING', msg)
                    continue # 资金不足，尝试下一个候选
 
                # 4. 执行下单
                msg = (f"确定唯一买入标的: {stock_code} (Rank:{candidate.rank})。 "
                       f"计划以限价 {limit_price} 买入 {quantity} 股。")
                logger.info(msg)
                self._log_to_db('INFO', msg)
                
                self.handler.place_buy_order(stock_code, limit_price, quantity)
                
                # 标记预案为已执行
                candidate.status = DailyTradingPlan.StatusChoices.EXECUTED
                candidate.save()
 
                # 成功买入后，立即退出函数，外层循环会决定是否继续买入下一个仓位
                return
 
            except Exception as e:
                msg = f"处理候选股 {candidate.stock_code} 时发生严重错误: {e}"
                logger.error(msg, exc_info=True)
                self._log_to_db('CRITICAL', msg)
                continue # 发生异常，继续尝试下一个候选
 
        # 如果循环正常结束，说明所有候选股都无法买入
        logger.info(f"已尝试所有 {len(candidates)} 个候选标的，均未成功买入。")

    def calculate_stop_profit_loss(self, trade_id: int):
        """
        函数三：止盈止损区间计算 (修正版)。
        在订单成交后，为新持仓计算并更新初始的止盈止损价。
 
        :param trade_id: 已成交的买入交易在 tb_trade_log 中的唯一ID。
        """
        logger.info(f"开始为 trade_id={trade_id} 计算止盈止损区间...")
        try:
            with transaction.atomic():
                # 1. 获取交易和持仓信息
                trade_log = TradeLog.objects.select_for_update().get(
                    trade_id=trade_id,
                    trade_type=TradeLog.TradeTypeChoices.BUY,
                    status=TradeLog.StatusChoices.FILLED
                )
                position = Position.objects.select_for_update().get(pk=trade_log.position_id)
 
                if position.current_stop_loss > 0:
                    logger.warning(f"Position ID {position.position_id} 似乎已计算过止盈止损，将跳过。")
                    return
 
                stock_code = trade_log.stock_code_id
                aep = trade_log.price
                buy_date = trade_log.trade_datetime.date()
                
                # 2. 获取计算所需行情数据 (避免未来函数)
                lookback_days = self.params['lookback_adx'] + 50
                start_date_for_calc = buy_date - timedelta(days=lookback_days * 2)
                end_date_for_calc = buy_date - timedelta(days=1)
 
                quotes_qs = DailyQuotes.objects.filter(
                    stock_code_id=stock_code,
                    trade_date__gte=start_date_for_calc,
                    trade_date__lte=end_date_for_calc
                ).order_by('trade_date')
 
                if len(quotes_qs) < max(self.params['lookback_atr'], self.params['lookback_adx'], self.params['lookback_ma20']):
                    raise ValueError(f"股票 {stock_code} 在 {end_date_for_calc} 前的历史数据不足，无法计算指标。")
 
                df = pd.DataFrame.from_records(quotes_qs.values('high', 'low', 'close'))
                df = df.astype(float)
 
                # 3. 计算所有必需指标
                atr_series = ta.atr(df['high'], df['low'], df['close'], length=self.params['lookback_atr'])
                atr_14_buy = Decimal(str(atr_series.iloc[-1]))
 
                ma20_series = ta.sma(df['close'], length=self.params['lookback_ma20'])
                ma20_buy = Decimal(str(ma20_series.iloc[-1]))
 
                adx_df = ta.adx(df['high'], df['low'], df['close'], length=self.params['lookback_adx'])
                adx_14_buy = Decimal(str(adx_df[f'ADX_{self.params["lookback_adx"]}'].iloc[-1]))
 
                # 4. 计算止盈价 g(y) - 逻辑不变
                profit_margin = min(
                    self.params['Base_Target'] + self.params['k_g1'] * (atr_14_buy / aep),
                    self.params['Max_Target']
                )
                take_profit_price = aep * (Decimal('1.0') + profit_margin)
 
                # 5. 计算止损价 h(z) - 严格按照需求文档逻辑
                # 5.1 根据ADX判断市场状态，选择z_final
                adx_threshold = self.params['param_adx_threshold']
                if adx_14_buy > adx_threshold:
                    # 趋势状态，使用较窄的ATR乘数
                    z_final = aep - self.params['k_h1'] * atr_14_buy
                else:
                    # 震荡状态，使用较宽的ATR乘数
                    z_final = aep - self.params['k_h2'] * atr_14_buy
 
                # 5.2 计算其他止损线
                z2_technical = ma20_buy
                z3_max_loss = aep * (Decimal('1.0') - self.params['Max_Loss_Percent'])
                
                # 5.3 取最严格的止损位（价格最高者）
                stop_loss_price = max(z_final, z2_technical, z3_max_loss)
                
                logger.info(f"[{stock_code}] 止损线比较: 趋势位={z_final:.2f}, 技术位={z2_technical:.2f}, 底线={z3_max_loss:.2f}")
 
                # 6. 更新持仓信息表
                position.current_take_profit = take_profit_price.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
                position.current_stop_loss = stop_loss_price.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
                position.save(update_fields=['current_take_profit', 'current_stop_loss'])
 
                msg = (f"成功计算并更新 Position ID {position.position_id} ({stock_code}) 的风控价格: "
                       f"购入价={aep}, 止盈价={position.current_take_profit}, 止盈率={((Decimal('1.0') + profit_margin)*100):.2f}%, 止损价={position.current_stop_loss}, 止损率={((position.current_stop_loss/aep)*100):.2f}%")
                logger.info(msg)
                self._log_to_db('INFO', msg)
 
        except TradeLog.DoesNotExist:
            logger.error(f"Trade ID {trade_id} 不存在或不满足计算条件（非买入/未成交）。")
        except Position.DoesNotExist:
            logger.error(f"与 Trade ID {trade_id} 关联的 Position 不存在。")
        except Exception as e:
            msg = f"为 Trade ID {trade_id} 计算止盈止损时发生严重错误: {e}"

    # --- 工具函数 ---

    @staticmethod
    def initialize_strategy_parameters():
        """
        工具函数：初始化本模块所需的策略参数到数据库。
        这是一个幂等操作，可以安全地重复运行。
        """
        logger.info("开始初始化[开盘决策与下单模块]的策略参数...")

        params_to_define = {
            # 仓位管理
            'MAX_POSITIONS': {'value': '2', 'group': 'POSITION_MGMT', 'desc': '最大可具备的总仓位数'},
            'MAX_CAPITAL_PER_POSITION': {'value': '25000.00', 'group': 'POSITION_MGMT', 'desc': '每仓最大投入资金数(元)'},
            # 下单参数
            'k_slip': {'value': '0.002', 'group': 'ORDER_EXEC', 'desc': '下单滑点系数, 用于计算限价单价格'},
            # 止盈参数 g(y)
            'Base_Target': {'value': '0.07', 'group': 'TAKE_PROFIT', 'desc': '基础止盈目标百分比'},
            'k_g1': {'value': '1.5', 'group': 'TAKE_PROFIT', 'desc': 'ATR溢价乘数, 用于动态调整止盈目标'},
            'Max_Target': {'value': '0.20', 'group': 'TAKE_PROFIT', 'desc': '最大止盈目标百分比上限'},
            # 止损参数 h(z)
            'k_h1': {'value': '2.0', 'group': 'STOP_LOSS', 'desc': '趋势市ATR止损乘数 (盘中动态使用)'},
            'k_h2': {'value': '3.0', 'group': 'STOP_LOSS', 'desc': '震荡市ATR止损乘数 (用于计算初始止损)'},
            'Max_Loss_Percent': {'value': '0.08', 'group': 'STOP_LOSS', 'desc': '最大回撤容忍度(绝对亏损百分比上限)'},
            # 指标周期
            'lookback_atr': {'value': '14', 'group': 'INDICATORS', 'desc': 'ATR计算周期'},
            'lookback_adx': {'value': '14', 'group': 'INDICATORS', 'desc': 'ADX计算周期'},
            'lookback_ma20': {'value': '20', 'group': 'INDICATORS', 'desc': 'MA20计算周期'},
        }

        with transaction.atomic():
            for name, data in params_to_define.items():
                StrategyParameters.objects.update_or_create(
                    param_name=name,
                    defaults={
                        'param_value': Decimal(data['value']),
                        'group_name': data['group'],
                        'description': data['desc']
                    }
                )
        
        logger.info(f"成功初始化/更新 {len(params_to_define)} 个策略参数。")


####文件结束####

####trade_manager\service\monitor_exit_service.py####
# trade_manager/service/monitor_exit_service.py

import logging
from datetime import date
from django.utils import timezone
from decimal import Decimal

# 导入项目内的模型和接口
from common.models import Position, TradeLog
from .trade_handler import ITradeHandler

persistent_logger = logging.getLogger(__name__)


class MonitorExitService:
    """
    3.5 - 盘中持仓监控与退出模块

    该服务负责在交易时段内，以固定频率轮询，监控所有非当日建仓的持仓。
    当持仓股票的实时价格触及预设的止盈或止损线时，调用交易处理器执行卖出操作。
    """
    MODULE_NAME = '盘中持仓监控与退出'

    def __init__(self, handler: ITradeHandler,execution_date: date = None):
        """
        初始化监控服务。

        :param handler: 一个实现了 ITradeHandler 接口的实例，用于与交易环境交互。
        """
        if not isinstance(handler, ITradeHandler):
            raise TypeError("传入的 handler 必须是 ITradeHandler 的一个实例。")
        
        self.handler = handler
        self.execution_date = execution_date if execution_date else timezone.now().date()
        # 使用特定的logger进行高频、非持久化的日志记录
        self.logger = persistent_logger

    def monitor_and_exit_positions(self):
        """
        执行一次完整的持仓监控与退出检查。
        此函数应由一个定时调度器在交易时段内（09:30:01 - 14:57:00）
        以设定的频率反复调用。
        """
        self.logger.debug(f"[{self.MODULE_NAME}] 任务开始...")

        # 1. 从持仓信息表读取出entry_datetime建仓成交时间不为今天的持仓信息
        today = timezone.now().date()
        positions_to_monitor = Position.objects.filter(
            status=Position.StatusChoices.OPEN
        ).exclude(
            entry_datetime__date=self.execution_date
        )

        if not positions_to_monitor.exists():
            self.logger.debug("当前无需要监控的隔夜持仓。")
            return

        # 2. 循环调用处理器判断是否达到了止盈止损状态
        for position in positions_to_monitor:
            try:
                # 获取实时价格
                current_price = self.handler.get_realtime_price(position.stock_code)

                if current_price is None or current_price <= 0:
                    self.logger.debug(f"无法获取 {position.stock_code} 的有效实时价格，跳过本次检查。")
                    continue
                
                self.logger.debug(
                    f"监控: {position.stock_code}, "
                    f"当前价: {current_price}, "
                    f"止损价: {position.current_stop_loss}, "
                    f"止盈价: {position.current_take_profit}"
                )

                # 检查是否触发止损
                if current_price <= position.current_stop_loss:
                    msg = (f"触发止损条件! 股票: {position.stock_code}, "
                           f"当前价: {current_price} <= 止损价: {position.current_stop_loss}。准备执行卖出。")
                    persistent_logger.info(msg) # 这是一个重要事件，使用可持久化的logger
                    self.handler.sell_stock_by_market_price(position, TradeLog.ReasonChoices.STOP_LOSS)
                    # 卖出后，此持仓在下一次循环中将不再被查询到，无需从当前循环中移除

                # 检查是否触发止盈
                elif current_price >= position.current_take_profit:
                    msg = (f"触发止盈条件! 股票: {position.stock_code}, "
                           f"当前价: {current_price} >= 止盈价: {position.current_take_profit}。准备执行卖出。")
                    persistent_logger.info(msg) # 这是一个重要事件，使用可持久化的logger
                    self.handler.sell_stock_by_market_price(position, TradeLog.ReasonChoices.TAKE_PROFIT)

            except Exception as e:
                # 根据要求，卖出失败等异常只在控制台打印错误日志，等待下一次循环
                self.logger.error(
                    f"处理持仓 {position.position_id} ({position.stock_code}) 时发生错误: {e}",
                    exc_info=False # 在高频场景下，可以关闭traceback以保持日志简洁
                )
                continue
        
        self.logger.debug(f"[{self.MODULE_NAME}] 任务结束。")


####文件结束####

####trade_manager\service\real_trade_handler.py####
# trade_manager/service/real_trade_handler.py

import logging
import json
from decimal import Decimal, ROUND_HALF_UP
from datetime import date, time, datetime, timedelta

import easytrader
import akshare as ak
from django.db import transaction
from django.utils import timezone

from .trade_handler import ITradeHandler
from common.models import Position, TradeLog, DailyQuotes
from trade_manager.service.decision_order_service import DecisionOrderService
from common.config_loader import config_loader # 使用统一的配置加载器

logger = logging.getLogger(__name__)

class ConnectionManager:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(ConnectionManager, cls).__new__(cls, *args, **kwargs)
        return cls._instance

    def __init__(self):
        if not hasattr(self, 'initialized'):
            self.user = None
            self.last_connected_date = None
            self.last_refreshed_time = None # 新增：上次刷新时间
            self.refresh_interval = timedelta(seconds=5) # 新增：刷新间隔
            self.initialized = True
            logger.info("ConnectionManager 已初始化。")

    def get_user(self):
        """获取或创建当天的 easytrader 连接，并按需刷新"""
        config = config_loader.get('easytrader')
        today = date.today()
        
        if not self.user or self.last_connected_date != today:
            logger.info("当天首次连接或连接已失效，正在重新建立 easytrader 连接...")
            try:
                self._connect(config)
                self.last_connected_date = today
                self.last_refreshed_time = datetime.now()
                logger.info("easytrader 连接成功。")
            except Exception as e:
                logger.error(f"连接 easytrader 失败: {e}", exc_info=True)
                self.user = None
                self.last_connected_date = None
                raise
        
        # 检查是否需要刷新
        if datetime.now() - self.last_refreshed_time > self.refresh_interval:
            logger.info("会话超过5分钟未刷新，执行 user.refresh()...")
            try:
                self.user.refresh()
                self.last_refreshed_time = datetime.now()
                logger.info("user.refresh() 执行成功。")
            except Exception as e:
                logger.error(f"执行 user.refresh() 失败: {e}，将尝试断开重连。")
                self.disconnect() # 刷新失败，可能连接已断，强制断开
                # 下次调用 get_user 时会自动重连
                raise # 抛出异常，让当前操作失败
        
        return self.user

    def _connect(self, config: dict):
        client_type = config.get('client_type', 'ht_client')
        user_config_path = config.get('user_config_path')
        
        if client_type == 'ht_client':
            self.user = easytrader.use('ht_client')
            self.user.prepare(user_config_path)
        else:
            raise NotImplementedError(f"不支持的客户端类型: {client_type}")

    def disconnect(self):
        if self.user:
            try:
                self.user.exit()
                logger.info("easytrader 连接已成功断开。")
            except Exception as e:
                logger.error(f"断开 easytrader 连接时出错: {e}", exc_info=True)
            finally:
                self.user = None
                self.last_connected_date = None
                self.last_refreshed_time = None

connection_manager = ConnectionManager()

class RealTradeHandler(ITradeHandler):
    COMMISSION_RATE = Decimal('0.00025')
    MIN_COMMISSION = Decimal('5')
    STAMP_DUTY_RATE = Decimal('0.001')

    def __init__(self):
        config = config_loader.get_config()
        self.is_simulation = (config.get('trading_mode') == 'real_simulation_observation')
        logger.info(f"RealTradeHandler 初始化。模式: {'实盘模拟观测' if self.is_simulation else '实盘交易'}")

    def _get_user(self):
        return connection_manager.get_user()

    def _api_buy(self, stock_code: str, price: Decimal, quantity: int):
        user = self._get_user()
        ak_code = stock_code.split('.')[-1]
        return user.buy(ak_code, price=float(price), amount=quantity)

    def _api_sell(self, stock_code: str, quantity: int):
        user = self._get_user()
        ak_code = stock_code.split('.')[-1]
        return user.sell(ak_code, amount=quantity)

    def _api_get_orders(self):
        user = self._get_user()
        return user.entrust

    def _api_get_balance(self):
        user = self._get_user()
        return user.balance

    def _api_get_realtime_quote(self, stock_code: str) -> dict:
        ak_code = stock_code.split('.')[-1]
        try:
            df = ak.stock_zh_a_spot_em(symbol=ak_code)
            if not df.empty:
                quote = df.iloc[0]
                return {
                    'open': Decimal(str(quote['今开'])),
                    'price': Decimal(str(quote['最新价'])),
                }
        except Exception as e:
            logger.warning(f"通过 akshare 获取 {stock_code} 实时行情失败: {e}")
        return {}

    def get_opening_price(self, stock_code: str) -> Decimal:
        quote = self._api_get_realtime_quote(stock_code)
        return quote.get('open', Decimal('0.00'))

    def get_realtime_price(self, stock_code: str) -> Decimal | None:
        quote = self._api_get_realtime_quote(stock_code)
        return quote.get('price')

    def get_available_balance(self) -> Decimal:
        if self.is_simulation:
            return Decimal('1000000.00')
        
        balance_info = self._api_get_balance()
        return Decimal(str(balance_info.get('可用金额', '0.00')))

    @transaction.atomic
    def place_buy_order(self, stock_code: str, price: Decimal, quantity: int):
        logger.info(f"准备下单买入: {stock_code}, 价格: {price}, 数量: {quantity}")
        
        entry_datetime = timezone.now()
        position = Position.objects.create(
            stock_code_id=stock_code, entry_datetime=entry_datetime,
            entry_price=price, quantity=quantity,
            current_stop_loss=Decimal('0.00'), current_take_profit=Decimal('0.00'),
            status=Position.StatusChoices.OPEN
        )
        trade_log = TradeLog.objects.create(
            position=position, stock_code_id=stock_code,
            trade_datetime=entry_datetime, trade_type=TradeLog.TradeTypeChoices.BUY,
            order_type=TradeLog.OrderTypeChoices.LIMIT, price=price,
            quantity=quantity, commission=Decimal('0.00'), stamp_duty=Decimal('0.00'),
            reason=TradeLog.ReasonChoices.ENTRY, status=TradeLog.StatusChoices.PENDING
        )

        if self.is_simulation:
            logger.info("[模拟模式] 跳过真实API调用，直接模拟成交。")
            amount = price * quantity
            commission = max(amount * self.COMMISSION_RATE, self.MIN_COMMISSION)
            trade_log.status = TradeLog.StatusChoices.FILLED
            trade_log.commission = commission.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            trade_log.save()
            
            decision_service = DecisionOrderService(self, execution_date=date.today())
            decision_service.calculate_stop_profit_loss(trade_log.trade_id)
        else:
            try:
                order_result = self._api_buy(stock_code, price, quantity)
                logger.info(f"真实买入委托已提交: {order_result}")
                # 关键：保存委托编号
                if order_result and 'entrust_no' in order_result:
                    trade_log.external_order_id = str(order_result['entrust_no'])
                    trade_log.save()
            except Exception as e:
                logger.error(f"提交买入委托失败: {e}", exc_info=True)
                trade_log.status = TradeLog.StatusChoices.FAILED
                trade_log.save()
                position.status = Position.StatusChoices.CLOSED
                position.save()

    @transaction.atomic
    def sell_stock_by_market_price(self, position: Position, reason: str):
        logger.info(f"准备市价卖出: {position.stock_code_id}, 数量: {position.quantity}, 原因: {reason}")

        trade_log = TradeLog.objects.create(
            position=position, stock_code_id=position.stock_code_id,
            trade_datetime=timezone.now(), trade_type=TradeLog.TradeTypeChoices.SELL,
            order_type=TradeLog.OrderTypeChoices.MARKET, price=Decimal('0.00'),
            quantity=position.quantity, commission=Decimal('0.00'), stamp_duty=Decimal('0.00'),
            reason=reason, status=TradeLog.StatusChoices.PENDING
        )

        if self.is_simulation:
            logger.info("[模拟模式] 跳过真实API调用，直接模拟成交。")
            try:
                last_quote = DailyQuotes.objects.filter(stock_code_id=position.stock_code_id).latest('trade_date')
                sell_price = last_quote.close
            except DailyQuotes.DoesNotExist:
                sell_price = position.entry_price

            amount = sell_price * position.quantity
            commission = max(amount * self.COMMISSION_RATE, self.MIN_COMMISSION)
            stamp_duty = amount * self.STAMP_DUTY_RATE

            trade_log.status = TradeLog.StatusChoices.FILLED
            trade_log.price = sell_price
            trade_log.commission = commission.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            trade_log.stamp_duty = stamp_duty.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            trade_log.save()

            position.status = Position.StatusChoices.CLOSED
            position.save()
        else:
            try:
                order_result = self._api_sell(position.stock_code_id, position.quantity)
                logger.info(f"真实卖出委托已提交: {order_result}")
                if order_result and 'entrust_no' in order_result:
                    trade_log.external_order_id = str(order_result['entrust_no'])
                    trade_log.save()
            except Exception as e:
                logger.error(f"提交卖出委托失败: {e}", exc_info=True)
                trade_log.status = TradeLog.StatusChoices.FAILED
                trade_log.save()

####文件结束####

####trade_manager\service\scheduler_service.py####
# trade_manager/service/scheduler_service.py

import logging
import pandas as pd # 修正：导入pandas
from datetime import date, timedelta, datetime

import akshare as ak
from apscheduler.schedulers.background import BackgroundScheduler # 使用BackgroundScheduler
from django.conf import settings
from django.db import transaction
from decimal import Decimal

from selection_manager.service.selection_service import SelectionService
from data_manager.service.corporate_action_service import CorporateActionService
from data_manager.service.stock_service import StockService
from data_manager.service.email_service import EmailNotificationService
from trade_manager.service.before_fix_service import BeforeFixService
from trade_manager.service.decision_order_service import DecisionOrderService
from trade_manager.service.monitor_exit_service import MonitorExitService
from trade_manager.service.real_trade_handler import RealTradeHandler, connection_manager
from common.models import TradeLog, Position
from common.config_loader import config_loader

logger = logging.getLogger(__name__)

class TradingCalendar:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(TradingCalendar, cls).__new__(cls, *args, **kwargs)
        return cls._instance

    def __init__(self):
        if not hasattr(self, 'initialized'):
            self.trade_dates = set()
            self.last_updated = None
            self.initialized = True
            self._update_calendar()

    def _update_calendar(self):
        logger.info("正在更新交易日历...")
        try:
            df = ak.tool_trade_date_hist_sina()
            self.trade_dates = set(pd.to_datetime(df['trade_date']).dt.date)
            self.last_updated = date.today()
            logger.info(f"交易日历更新成功，共获取 {len(self.trade_dates)} 个交易日。")
        except Exception as e:
            logger.error(f"更新交易日历失败: {e}", exc_info=True)

    def is_trading_day(self, check_date: date) -> bool:
        if date.today() != self.last_updated:
            self._update_calendar()
        return check_date in self.trade_dates

trading_calendar = TradingCalendar()

# --- Job Functions ---

def run_job_wrapper(job_func, job_name, *args, **kwargs):
    scheduler_status = config_loader.get('scheduler', {}).get('status')
    if scheduler_status == 'off': return

    logger.info(f"--- [{job_name}] 任务触发 ---")
    if scheduler_status == 'dry_run':
        logger.info(f"[{job_name}] 空转模式，任务仅打印日志，不执行。")
        return
    
    try:
        job_func(*args, **kwargs)
        logger.info(f"--- [{job_name}] 任务成功执行 ---")
    except Exception as e:
        logger.error(f"--- [{job_name}] 任务执行失败: {e} ---", exc_info=True)

def daily_check():
    today = date.today()
    if not trading_calendar.is_trading_day(today):
        logger.debug(f"{today} 不是交易日，今日主要交易流程任务将跳过。")
        return False
    return True

def selection_job():
    

    t_minus_1 = date.today() - timedelta(days=1)
    if not trading_calendar.is_trading_day(date.today()):
        logger.info(f"今日({date.today()})不是交易日，不执行选股任务。")
        return
    service = StockService()
    service.update_local_a_shares(start_date=date.today().strftime('%Y-%m-%d'),end_date=date.today().strftime('%Y-%m-%d'))
    service = SelectionService(trade_date=date.today(), mode='realtime')
    service.run_selection()

def premarket_fix_job():
    if not daily_check(): return
    service = BeforeFixService(execution_date=date.today())
    service.run()

def opening_decision_job():
    if not daily_check(): return
    handler = RealTradeHandler()
    service = DecisionOrderService(handler, execution_date=date.today())
    
    logger.info("执行交易预案二次筛选...")
    service.adjust_trading_plan_daily()
    
    logger.info("循环执行下单，尝试填满仓位...")
    max_positions = service.current_max_positions
    logger.info(f"根据M(t)计算，当日动态最大持仓数为: {max_positions}")

    
    open_positions_count = Position.objects.filter(status=Position.StatusChoices.OPEN).count()
    slots_to_fill = max_positions - open_positions_count
 
    # 3. 循环调用同一个实例的方法
    for i in range(slots_to_fill):
        logger.info(f"尝试填充第 {i+1}/{slots_to_fill} 个仓位...")
        service.execute_orders()

def monitoring_job():
    if not daily_check(): return
    handler = RealTradeHandler()
    service = MonitorExitService(handler, execution_date=date.today())
    service.monitor_and_exit_positions()

def update_order_status_job():
    if not daily_check(): return
    handler = RealTradeHandler()
    if handler.is_simulation: return

    pending_trades = TradeLog.objects.filter(status=TradeLog.StatusChoices.PENDING, external_order_id__isnull=False)
    if not pending_trades.exists(): return
    
    try:
        real_orders = handler._api_get_orders()
        if not real_orders: return
        real_orders_map = {str(o['entrust_no']): o for o in real_orders}

        for trade in pending_trades:
            real_order = real_orders_map.get(trade.external_order_id)
            if not real_order: continue
            
            if real_order['order_status'] in ['已成', '全部成交']:
                with transaction.atomic():
                    trade.status = TradeLog.StatusChoices.FILLED
                    trade.price = Decimal(str(real_order['filled_price']))
                    # 注意：easytrader返回的佣金可能不准确，这里仅为示例
                    trade.commission = Decimal(str(real_order.get('business_balance', '0.0'))) - Decimal(str(real_order.get('clear_balance', '0.0')))
                    trade.save()

                    if trade.trade_type == 'buy':
                        decision_service = DecisionOrderService(handler, execution_date=date.today())
                        decision_service.calculate_stop_profit_loss(trade.trade_id)
                    else: # sell
                        position = trade.position
                        position.status = Position.StatusChoices.CLOSED
                        position.save()
                logger.info(f"订单 {trade.trade_id} (委托号: {trade.external_order_id}) 状态更新为已成交。")

            elif real_order['order_status'] in ['已撤', '废单', '部成已撤']:
                with transaction.atomic():
                    trade.status = TradeLog.StatusChoices.CANCELLED if '撤' in real_order['order_status'] else TradeLog.StatusChoices.FAILED
                    trade.save()
                    if trade.trade_type == 'buy':
                        position = trade.position
                        position.status = Position.StatusChoices.CLOSED
                        position.save()
                logger.info(f"订单 {trade.trade_id} (委托号: {trade.external_order_id}) 状态更新为 {trade.status}。")

    except Exception as e:
        logger.error(f"更新订单状态时出错: {e}", exc_info=True)

def update_corporate_actions_job():
    today = date.today()
    start_date = today - timedelta(days=30)
    end_date = today + timedelta(days=30)
    service = CorporateActionService()
    service.sync_corporate_actions(start_date=start_date.strftime('%Y-%m-%d'), end_date=end_date.strftime('%Y-%m-%d'))

def disconnect_job():
    logger.info("执行每日断开连接任务...")
    connection_manager.disconnect()

scheduler = BackgroundScheduler(timezone='Asia/Shanghai')


def schedule_intraday_jobs():
    """在每个交易日开盘前，添加当天的盘中监控任务。"""
    job_id_monitor = 'intraday_monitoring_job'
    job_id_order_status = 'intraday_order_status_job'
    
    # 为防止重复添加，先尝试移除旧的（如果存在）
    try:
        scheduler.remove_job(job_id_monitor)
        logger.info(f"成功移除旧的盘中监控任务 (ID: {job_id_monitor})。")
    except Exception:
        pass # JobNotFoundError, a normal case
    
    try:
        scheduler.remove_job(job_id_order_status)
        logger.info(f"成功移除旧的订单状态更新任务 (ID: {job_id_order_status})。")
    except Exception:
        pass
 
    if not daily_check(): return
 
    today_str = date.today().isoformat()
    logger.info(f"正在为 {today_str} 添加盘中任务...")
 
    scheduler.add_job(
        run_job_wrapper, 
        'interval', 
        seconds=5, 
        start_date=f'{today_str} 09:30:01', 
        end_date=f'{today_str} 14:57:00', 
        args=[monitoring_job, '盘中监控'],
        id=job_id_monitor, # **给任务一个唯一的ID**
        replace_existing=True # 如果ID已存在，则替换
    )
 
    scheduler.add_job(
        run_job_wrapper, 
        'interval', 
        seconds=10, 
        start_date=f'{today_str} 09:30:00', 
        end_date=f'{today_str} 15:00:00', 
        args=[update_order_status_job, '更新订单状态'],
        id=job_id_order_status, # **给任务一个唯一的ID**
        replace_existing=True
    )
    logger.info("当日盘中任务已成功调度。")
 
 
# 清理任务的函数，虽然 replace_existing=True也能工作，但显式清理更干净
def cleanup_intraday_jobs():
    """收盘后清理，以防万一。"""
    try:
        scheduler.remove_job('intraday_monitoring_job')
        scheduler.remove_job('intraday_order_status_job')
        logger.info("已清理当日盘中任务。")
    except Exception:
        pass

# 邮件发送任务
def email_jobs():
    """每天发送计划邮件"""
    today = date.today()
    service = EmailNotificationService(today)
    service.runEmailSend()


def start():
    """启动调度器的主函数"""
    if config_loader.get('scheduler', {}).get('status') == 'off':
        logger.info("调度器状态为 'off'，不启动。")
        return

    if scheduler.running:
        logger.warning("调度器已在运行中。")
        return

    # 添加任务
    scheduler.add_job(run_job_wrapper, 'cron', day='*', hour=19, minute=0, args=[selection_job, '日终选股'])
    scheduler.add_job(run_job_wrapper, 'cron', day='*', hour=6, minute=10, args=[premarket_fix_job, '盘前校准'])
    scheduler.add_job(run_job_wrapper, 'cron', day='*', hour=6, minute=30, args=[email_jobs, '预案推送'])
    #scheduler.add_job(run_job_wrapper, 'cron', day='*', hour=9, minute=25, second=5, args=[opening_decision_job, '开盘决策'])
    
    # --- 每日动态任务的调度器 ---
    # 在每个交易日的开盘前（例如9:00）安排好当天的盘中任务
    #scheduler.add_job(schedule_intraday_jobs, 'cron', day='*', hour=9, minute=0)
    #在收盘后清理
    #scheduler.add_job(cleanup_intraday_jobs, 'cron', day='*', hour=15, minute=5)
    
    # 数据和连接管理任务
    scheduler.add_job(run_job_wrapper, 'cron', day='*', hour=6, minute=0, args=[update_corporate_actions_job, '更新除权除息'])
    #scheduler.add_job(run_job_wrapper, 'cron', day='*', hour=15, minute=30, args=[disconnect_job, '断开连接'])
    # today_str = date.today().isoformat()
    # scheduler.add_job(
    #     run_job_wrapper, 
    #     'interval', 
    #     seconds=10, 
    #     start_date=f'{today_str} 07:30:00', 
    #     end_date=f'{today_str} 19:30:00',
    #     args=[update_order_status_job, '更新订单状态'],
    #     id='job_id_order_status', # **给任务一个唯一的ID**
    #     replace_existing=True
    # )
    logger.info("APScheduler 已配置完成，准备在后台启动...")
    scheduler.start()

####文件结束####

####trade_manager\service\simulate_trade.py####
# ==============================================================================
# 文件 4/5: trade_manager/service/simulate_trade.py (修改)
# 描述: 核心回测服务，集成日志记录和邮件发送。
# ==============================================================================
# trade_manager/service/simulate_trade.py

import logging
from datetime import date, timedelta, datetime
from decimal import Decimal
import numpy as np
import pandas as pd
from django.db import connections, transaction
from django.core.management import call_command

# 内部模块导入
from common.models import (
    DailyFactorValues, DailyTradingPlan, Position, TradeLog, SystemLog,
    StrategyParameters, DailyQuotes, CorporateAction
)
# 新增导入
from common.models.backtest_logs import BacktestDailyLog, BacktestOperationLog 
from selection_manager.service.selection_service import SelectionService, MARKET_INDICATOR_CODE
from trade_manager.service.before_fix_service import BeforeFixService
from trade_manager.service.decision_order_service import DecisionOrderService
from trade_manager.service.monitor_exit_service import MonitorExitService
from .simulate_trade_handler import SimulateTradeHandler
from .db_utils import use_backtest_schema
from .backtest_reporter import BacktestReporter # 新增导入

logger = logging.getLogger(__name__)

class SimulateTradeService:
    """
    回测实施服务 (V3 - 集成日志与报告)。
    """
    COMMISSION_RATE = Decimal('0.0002854')
    MIN_COMMISSION = Decimal('5')
    STAMP_DUTY_RATE = Decimal('0.001')
    SELL_SLIPPAGE_RATE = Decimal('0.002')

    def __init__(self):
        self.start_date: date = None
        self.end_date: date = None
        self.current_date: date = None
        self.initial_capital = Decimal('0.0')
        self.cash_balance = Decimal('0.0')
        self.portfolio_history = []
        self.last_buy_trade_id = None
        self.backtest_run_id: str = None # 新增：回测唯一ID

    def _setup_backtest_schema(self, schema_name: str, initial_capital: Decimal):
        logger.info(f"--- 1. 在 Schema '{schema_name}' 中准备回测环境 ---")
        
        logger.info("正在新 Schema 中创建表结构 (执行 migrate)...")
        with connections['default'].cursor() as cursor:
            logger.info(f"临时隔离 search_path 到 '{schema_name}' 以便运行 migrate 命令。")
            cursor.execute(f'SET search_path TO "{schema_name}";')
            
            logger.info("正在新 Schema 中创建表结构 (执行 migrate)...")
            # 在这个隔离的环境下，migrate 看不到 public.django_migrations，因此会创建所有表。
            call_command('migrate')
            logger.info("表结构创建完成。")

        tables_to_copy = [
            'tb_stock_info', 'tb_daily_quotes', 'tb_corporate_actions',
            'tb_factor_definitions', 'tb_strategy_parameters', 
            'tb_daily_factor_values','tb_daily_trading_plan'
        ]
        
        logger.info(f"准备从 'public' schema 复制基础数据到 '{schema_name}'...")
        with transaction.atomic(), connections['default'].cursor() as cursor:
            cursor.execute(f'SET search_path TO "{schema_name}";')
            for table_name in tables_to_copy:
                logger.info(f"  - 正在处理表: {table_name}")
                # 1. 区分并获取 "普通索引" 和 "约束"
                # =========================================================================
                # 1a. 获取普通索引 (不包括由 UNIQUE 或 PRIMARY KEY 约束创建的索引)
                logger.info(f"    - 正在获取 '{table_name}' 的普通索引...")
                cursor.execute("""
                    SELECT indexdef
                    FROM pg_indexes
                    WHERE schemaname = %s AND tablename = %s
                    AND indexname NOT IN (
                        SELECT conname FROM pg_constraint WHERE conrelid = %s::regclass
                    );
                """, [schema_name, table_name, f'"{schema_name}"."{table_name}"'])
                plain_indexes_to_recreate = [row[0] for row in cursor.fetchall()]
                # 1b. 获取约束 (外键和唯一约束)
                logger.info(f"    - 正在获取 '{table_name}' 的外键和唯一约束...")
                cursor.execute("""
                    SELECT 'ALTER TABLE ' || quote_ident(conrelid::regclass::text) || ' ADD CONSTRAINT ' || quote_ident(conname) || ' ' || pg_get_constraintdef(oid)
                    FROM pg_constraint
                    WHERE contype IN ('f', 'u') AND conrelid = %s::regclass;
                """, [f'"{schema_name}"."{table_name}"'])
                constraints_to_recreate = [row[0] for row in cursor.fetchall()]
                # 2. 删除索引和约束 (删除约束会自动删除其底层索引)
                # =========================================================================
                # 2a. 删除约束
                for const_def in constraints_to_recreate:
                    const_name = const_def.split('ADD CONSTRAINT ')[1].split(' ')[0]
                    logger.info(f"      - 删除约束: {const_name}")
                    cursor.execute(f'ALTER TABLE "{table_name}" DROP CONSTRAINT IF EXISTS {const_name};')
                
                # 2b. 删除普通索引
                for index_def in plain_indexes_to_recreate:
                    # 从 "CREATE INDEX index_name ON ..." 中提取 index_name
                    try:
                        index_name = index_def.split(' ')[2]
                        logger.info(f"      - 删除索引: {index_name}")
                        cursor.execute(f'DROP INDEX IF EXISTS "{index_name}";')
                    except IndexError:
                        logger.warning(f"无法从 '{index_def}' 解析索引名称，跳过删除。")
                # 3. 高效复制数据 (现在非常快)
                # =========================================================================
                logger.info(f"    - 正在从 public.{table_name} 复制数据...")
                sql = f'INSERT INTO "{table_name}" SELECT * FROM public."{table_name}";'
                cursor.execute(sql)
                logger.info(f"    - 数据复制完成。")
                # 4. 重建索引和约束
                # =========================================================================
                logger.info(f"    - 正在重建 '{table_name}' 的索引和约束...")
                # 4a. 重建普通索引
                for index_def in plain_indexes_to_recreate:
                    logger.info(f"      - 重建索引: {index_def}")
                    cursor.execute(index_def)
                
                # 4b. 重建约束 (这会自动重建它们的底层索引)
                for const_def in constraints_to_recreate:
                    logger.info(f"      - 重建约束: {const_def}")
                    cursor.execute(const_def)

                # =========================================================================
                # 5. 重置自增主键序列 (解决主键冲突的关键)
                # =========================================================================
                # 自动查找并更新当前表的自增序列
                find_serial_sql = """
                    SELECT 
                        a.attname, 
                        pg_get_serial_sequence(
                            quote_ident(n.nspname) || '.' || quote_ident(c.relname), 
                            a.attname
                        )
                    FROM 
                        pg_class c
                    JOIN 
                        pg_attribute a ON a.attrelid = c.oid
                    JOIN 
                        pg_namespace n ON c.relnamespace = n.oid -- 通过namespace OID关联
                    WHERE 
                        n.nspname = %s      -- 参数1: schema的名称
                        AND c.relname = %s  -- 参数2: 表的名称
                        AND a.attnum > 0 
                        AND NOT a.attisdropped
                        AND pg_get_serial_sequence(quote_ident(n.nspname) || '.' || quote_ident(c.relname), a.attname) IS NOT NULL;
                """
                cursor.execute(find_serial_sql, [schema_name, table_name])
                serial_columns = cursor.fetchall()

                for column_name, sequence_name in serial_columns:
                    logger.info(f"    - 发现自增列 '{column_name}'，正在重置其序列 '{sequence_name}'...")
                    
                    # 将序列的下一个值设置为 (表中该列的最大值 + 1)，如果表为空则设置为1
                    update_sequence_sql = f"""
                        SELECT setval(
                            '{sequence_name}', 
                            COALESCE((SELECT MAX("{column_name}") FROM "{table_name}"), 0) + 1, 
                            true
                        )
                    """
                    cursor.execute(update_sequence_sql)
                    logger.info(f"    - 序列 '{sequence_name}' 已更新。")

                
        logger.info("基础数据复制完成。")
        # with connections['default'].cursor() as cursor:
        #     for table_name in tables_to_copy:
        #         logger.info(f"  - 正在复制表: {table_name}")
        #         sql = f'INSERT INTO "{schema_name}"."{table_name}" SELECT * FROM public."{table_name}";'
        #         cursor.execute(sql)
        # logger.info("基础数据复制完成。")

        self.initial_capital = initial_capital
        self.cash_balance = self.initial_capital
        logger.info(f"初始资金已设定为: {self.initial_capital:.2f}")

    def run_backtest(self, start_date: str, end_date: str, initial_capital: Decimal) -> dict:
        self.start_date = date.fromisoformat(start_date)
        self.end_date = date.fromisoformat(end_date)
        self.backtest_run_id = f"backtest_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        logger.info(f"为本次回测创建临时 Schema: {self.backtest_run_id}")

        try:
            with connections['default'].cursor() as cursor:
                cursor.execute(f'CREATE SCHEMA IF NOT EXISTS "{self.backtest_run_id}";')

            with use_backtest_schema(self.backtest_run_id):
                self._setup_backtest_schema(self.backtest_run_id, initial_capital)

                handler = SimulateTradeHandler(self)
                trading_days = self._get_trading_days()
                if not trading_days:
                    logger.error("在指定日期范围内未找到任何交易日，回测终止。")
                    return {}

                logger.info(f"--- 2. 开始日度回测循环 ({len(trading_days)}天) ---")
                
                last_sent_month = None # 用于邮件触发

                for i, current_day in enumerate(trading_days):
                    self.current_date = current_day
                    logger.info(f"\n{'='*20} 模拟日: {self.current_date} ({i+1}/{len(trading_days)}) {'='*20}")


                    logger.info("-> [T日 盘前校准] ...")
                    before_fix_service = BeforeFixService(execution_date=self.current_date)
                    before_fix_service.run()
                    
                    self._handle_dividends()

                    logger.info("-> [T日 开盘决策与买入] ...")
                    decision_order_service = DecisionOrderService(handler=handler, execution_date=self.current_date)
                    decision_order_service.adjust_trading_plan_daily()
                    
                    while True:
                        open_positions_count = Position.objects.filter(status=Position.StatusChoices.OPEN).count()
                        max_pos = decision_order_service.current_max_positions
                        if open_positions_count >= max_pos: break
                        
                        self.last_buy_trade_id = None
                        decision_order_service.execute_orders()
                        
                        if self.last_buy_trade_id:
                            decision_order_service.calculate_stop_profit_loss(self.last_buy_trade_id)
                            # 在止盈止损计算完毕后，获取更新后的持仓对象
                            trade_log = TradeLog.objects.get(pk=self.last_buy_trade_id)
                            position = trade_log.position
                            # 现在才调用日志记录函数，此时 position 对象已包含正确的止盈止损价
                            handler._record_buy_operation(position)
                        else:
                            break

                    monitor_exit_service = MonitorExitService(handler=handler, execution_date=self.current_date)
                    logger.info("-> [T日 盘中监控] 模拟价格跌至最低点...")
                    handler.current_price_node = 'LOW'
                    monitor_exit_service.monitor_and_exit_positions()
                    logger.info("-> [T日 盘中监控] 模拟价格涨至最高点...")
                    handler.current_price_node = 'HIGH'
                    monitor_exit_service.monitor_and_exit_positions()

                    


                    logger.info(f"-> [T日 盘后选股] 基于 {self.current_date} 的数据为下一交易日做准备...")
                    selection_service = SelectionService(trade_date=self.current_date, mode='backtest')
                    selection_service.run_selection()
                    
                    self._record_daily_log()

                    # --- 邮件发送逻辑 ---
                    is_last_day = (i == len(trading_days) - 1)
                    current_month = current_day.month
                    send_mail_flag = False

                    if is_last_day:
                        send_mail_flag = True
                        logger.info("回测结束，触发最终邮件报告。")
                    elif last_sent_month is not None and current_month != last_sent_month:
                        send_mail_flag = True
                        logger.info(f"月份从 {last_sent_month} 变为 {current_month}，触发月度邮件报告。")
                    
                    if send_mail_flag:
                        reporter = BacktestReporter(
                            schema_name=self.backtest_run_id,
                            start_date=self.start_date,
                            current_date=self.current_date,
                            initial_capital=self.initial_capital
                        )
                        reporter.send_report()
                    
                    last_sent_month = current_month
                    # --- 邮件发送逻辑结束 ---

                logger.info("--- 3. 回测循环结束 ---")
                return self._calculate_performance_metrics()

        except Exception as e:
            logger.critical(f"回测过程中发生严重错误: {e}", exc_info=True)
            return {"error": str(e)}

    def _get_trading_days(self) -> list[date]:
        dates = DailyQuotes.objects.filter(
            trade_date__gte=self.start_date,
            trade_date__lte=self.end_date
        ).values_list('trade_date', flat=True).distinct().order_by('trade_date')
        return list(dates)

    def _handle_dividends(self):
        dividend_events = CorporateAction.objects.filter(
            ex_dividend_date=self.current_date, event_type=CorporateAction.EventType.DIVIDEND
        )
        if not dividend_events.exists(): return

        events_by_stock = {}
        for event in dividend_events:
            events_by_stock.setdefault(event.stock_code, []).append(event)
        
        open_positions = Position.objects.filter(
            stock_code_id__in=events_by_stock.keys(), status=Position.StatusChoices.OPEN
        )
        for pos in open_positions:
            for event in events_by_stock.get(pos.stock_code_id, []):
                dividend_amount = event.dividend_per_share * pos.quantity
                self.cash_balance += dividend_amount
                logger.info(f"除息事件: 持仓ID {pos.position_id} ({pos.stock_code_id}) 获得分红 {dividend_amount:.2f}")

    def _record_daily_log(self):
        open_positions = Position.objects.filter(status=Position.StatusChoices.OPEN)
        market_value = Decimal('0.0')
        for pos in open_positions:
            try:
                quote = DailyQuotes.objects.get(stock_code_id=pos.stock_code_id, trade_date=self.current_date)
                market_value += quote.close * pos.quantity
            except DailyQuotes.DoesNotExist:
                market_value += pos.entry_price * pos.quantity
        
        total_assets = self.cash_balance + market_value

        try:
            m_value_obj = DailyFactorValues.objects.get(
                stock_code_id=MARKET_INDICATOR_CODE,
                factor_code_id='dynamic_M_VALUE',
                trade_date=self.current_date
            )
            m_value = m_value_obj.raw_value
        except DailyFactorValues.DoesNotExist:
            m_value = None

        BacktestDailyLog.objects.create(
            backtest_run_id=self.backtest_run_id,
            trade_date=self.current_date,
            total_assets=total_assets,
            cash=self.cash_balance,
            holdings_value=market_value,
            market_m_value=m_value
        )
        logger.info(f"--- 日终结算 ({self.current_date}) ---")
        logger.info(f"现金: {self.cash_balance:.2f}, 持仓市值: {market_value:.2f}, 总资产: {total_assets:.2f}, M值: {m_value}")

    def _calculate_performance_metrics(self) -> dict:
        logger.info("--- 4. 计算回测性能指标 ---")
        daily_logs = BacktestDailyLog.objects.filter(backtest_run_id=self.backtest_run_id).order_by('trade_date')
        if not daily_logs.exists():
            return {}

        df = pd.DataFrame(list(daily_logs.values('total_assets')))
        df['total_assets'] = df['total_assets'].astype(float)
        
        final_value = df['total_assets'].iloc[-1]
        total_return_rate = (final_value / float(self.initial_capital)) - 1
        
        total_days = (self.end_date - self.start_date).days
        if total_days > 0:
            annualized_return = ((final_value / float(self.initial_capital)) ** (365.0 / total_days)) - 1
        else:
            annualized_return = 0.0

        df['peak'] = df['total_assets'].cummax()
        df['drawdown'] = (df['total_assets'] - df['peak']) / df['peak']
        max_drawdown = df['drawdown'].min()

        result = {
            'total_return_rate': f"{total_return_rate:.2%}",
            'annualized_return': f"{annualized_return:.2%}",
            'max_drawdown': f"{max_drawdown:.2%}"
        }
        logger.info(f"最终回测结果: {result}")
        return result


####文件结束####

####trade_manager\service\simulate_trade_handler.py####
# ==============================================================================
# 文件 5/5: trade_manager/service/simulate_trade_handler.py (修改)
# 描述: 模拟交易处理器，集成操作日志记录。
# ==============================================================================
# trade_manager/service/simulate_trade_handler.py

import logging
from datetime import time, timedelta
from decimal import Decimal, ROUND_HALF_UP
from datetime import date, timedelta, datetime
from django.db import transaction
from django.utils import timezone

from .trade_handler import ITradeHandler
from common.models import Position, TradeLog, DailyQuotes, StockInfo, DailyFactorValues
from common.models.backtest_logs import BacktestOperationLog # 新增导入
from selection_manager.service.selection_service import MARKET_INDICATOR_CODE # 新增导入

from typing import TYPE_CHECKING, Literal
if TYPE_CHECKING:
    from .simulate_trade import SimulateTradeService

logger = logging.getLogger(__name__)

class SimulateTradeHandler(ITradeHandler):
    """
    模拟交易处理器 (SimulateTradeHandler) - 集成操作日志。
    """

    def __init__(self, service: 'SimulateTradeService'):
        self.service = service
        self.current_price_node: Literal['OPEN', 'LOW', 'HIGH', 'CLOSE'] = 'CLOSE'

    def get_opening_price(self, stock_code: str) -> Decimal:
        try:
            quote = DailyQuotes.objects.get(
                stock_code_id=stock_code,
                trade_date=self.service.current_date
            )
            return quote.open
        except DailyQuotes.DoesNotExist:
            logger.warning(f"[回测] 无法在 {self.service.current_date} 找到 {stock_code} 的行情数据，返回0。")
            return Decimal('0.00')

    def get_realtime_price(self, stock_code: str) -> Decimal | None:
        try:
            quote = DailyQuotes.objects.get(
                stock_code_id=stock_code,
                trade_date=self.service.current_date
            )
            if self.current_price_node == 'LOW':
                return quote.low
            elif self.current_price_node == 'HIGH':
                return quote.high
            else:
                return quote.close
        except DailyQuotes.DoesNotExist:
            return None

    def get_available_balance(self) -> Decimal:
        return self.service.cash_balance

    @transaction.atomic
    def place_buy_order(self, stock_code: str, price: Decimal, quantity: int) -> None:
        amount = price * quantity
        commission = max(amount * self.service.COMMISSION_RATE, self.service.MIN_COMMISSION)
        total_cost = amount + commission

        if self.service.cash_balance < total_cost:
            raise ValueError(f"资金不足！")

        self.service.cash_balance -= total_cost
        logger.info(f"[回测] 买入 {stock_code} {quantity}股 @{price:.2f}, 花费: {amount:.2f}, 现金余额: {self.service.cash_balance:.2f}")

        entry_time = time(9, 30, 1)
        entry_datetime = timezone.make_aware(timezone.datetime.combine(self.service.current_date, entry_time))

        new_position = Position.objects.create(
            stock_code_id=stock_code, entry_datetime=entry_datetime, entry_price=price,
            quantity=quantity, status=Position.StatusChoices.OPEN,
            current_stop_loss=Decimal('0.00'), current_take_profit=Decimal('0.00')
        )

        trade_log = TradeLog.objects.create(
            position=new_position, stock_code_id=stock_code, trade_datetime=entry_datetime,
            trade_type=TradeLog.TradeTypeChoices.BUY, order_type=TradeLog.OrderTypeChoices.LIMIT,
            price=price, quantity=quantity, commission=commission,
            reason=TradeLog.ReasonChoices.ENTRY, status=TradeLog.StatusChoices.FILLED
        )
        
        self.service.last_buy_trade_id = trade_log.trade_id

        

    @transaction.atomic
    def sell_stock_by_market_price(self, position: Position, reason: str) -> None:
        if reason == TradeLog.ReasonChoices.STOP_LOSS:
            #有可能触发止损是因为配股把止损金额改到了999999，所以止损金额应该取开盘价和止损价更低的那个
            base_sell_price = self.get_opening_price(position.stock_code_id)
            trigger_price=min(base_sell_price,position.current_stop_loss)
        else: # TAKE_PROFIT
            trigger_price = position.current_take_profit

        sell_price = (trigger_price * (Decimal('1.0') - self.service.SELL_SLIPPAGE_RATE))
        sell_price = sell_price.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)

        amount = sell_price * position.quantity
        commission = max(amount * self.service.COMMISSION_RATE, self.service.MIN_COMMISSION)
        stamp_duty = amount * self.service.STAMP_DUTY_RATE
        net_income = amount - commission - stamp_duty

        self.service.cash_balance += net_income
        logger.info(f"[回测] 卖出 {position.stock_code_id} {position.quantity}股 @{sell_price:.2f}, 现金余额: {self.service.cash_balance:.2f}")

        position.status = Position.StatusChoices.CLOSED
        position.save()

        sell_time = time(14, 57, 0)
        sell_datetime = timezone.make_aware(timezone.datetime.combine(self.service.current_date, sell_time))

        TradeLog.objects.create(
            position=position, stock_code_id=position.stock_code_id, trade_datetime=sell_datetime,
            trade_type=TradeLog.TradeTypeChoices.SELL, order_type=TradeLog.OrderTypeChoices.MARKET,
            price=sell_price, quantity=position.quantity, commission=commission,
            stamp_duty=stamp_duty, reason=reason, status=TradeLog.StatusChoices.FILLED
        )
        
        # --- 新增: 记录卖出操作日志 ---
        self._record_sell_operation(position, sell_price, reason)
        
    def _get_t_minus_1_date(self) -> date:
        """安全地获取T-1交易日"""
        try:
            return DailyQuotes.objects.filter(trade_date__lt=self.service.current_date).latest('trade_date').trade_date
        except DailyQuotes.DoesNotExist:
            logger.warning(f"无法找到 {self.service.current_date} 的前一个交易日。")
            return self.service.current_date - timedelta(days=1)

    def _record_buy_operation(self, position: Position):
        t_minus_1 = self._get_t_minus_1_date()
        
        # 获取M值
        try:
            m_value_obj = DailyFactorValues.objects.get(
                stock_code_id=MARKET_INDICATOR_CODE,
                factor_code_id='dynamic_M_VALUE',
                trade_date=t_minus_1
            )
            m_value = m_value_obj.raw_value
        except DailyFactorValues.DoesNotExist:
            m_value = None
        
        # 获取因子得分
        # 步骤1: 先获取该股票当天的所有因子值
        all_factor_scores_qs = DailyFactorValues.objects.filter(
            stock_code_id=position.stock_code_id,
            trade_date=t_minus_1
        )
        
        # 步骤2: 在 Python 层面进行过滤和格式化
        scores_list = []
        for f in all_factor_scores_qs:
            scores_list.append(f"{f.factor_code_id}:{f.norm_score:.2f}")
        scores_str = "|".join(scores_list)
        
        # 获取止盈止损率 (在调用此函数时，Position应已被更新)
        profit_rate = (position.current_take_profit / position.entry_price) - 1 if position.entry_price > 0 else 0
        loss_rate = 1 - (position.current_stop_loss / position.entry_price) if position.entry_price > 0 else 0

        BacktestOperationLog.objects.create(
            backtest_run_id=self.service.backtest_run_id,
            position_id_ref=position.position_id,
            stock_code=position.stock_code_id,
            stock_name=position.stock_code.stock_name,
            trade_date=self.service.current_date,
            direction=BacktestOperationLog.Direction.BUY,
            exit_reason=None,
            profit_rate=profit_rate,
            loss_rate=loss_rate,
            buy_date_m_value=m_value,
            factor_scores=scores_str,
            price=position.entry_price,
            quantity=position.quantity,
            amount=position.entry_price * position.quantity
        )
        logger.debug(f"已记录买入操作日志 for Position ID: {position.position_id}")
        
    def _record_sell_operation(self, position: Position, sell_price: Decimal, reason: str):
        # 反查买入记录
        try:
            buy_op = BacktestOperationLog.objects.get(
                backtest_run_id=self.service.backtest_run_id,
                position_id_ref=position.position_id,
                direction=BacktestOperationLog.Direction.BUY
            )
            m_value = buy_op.buy_date_m_value
            scores_str = buy_op.factor_scores
            profit_rate = buy_op.profit_rate
            loss_rate = buy_op.loss_rate
        except BacktestOperationLog.DoesNotExist:
            logger.error(f"严重错误：无法找到 Position ID {position.position_id} 对应的买入操作日志！")
            m_value, scores_str, profit_rate, loss_rate = None, "", None, None

        exit_reason_for_log = None
        if reason == TradeLog.ReasonChoices.TAKE_PROFIT:
            exit_reason_for_log = BacktestOperationLog.ExitReason.TAKE_PROFIT
        elif reason == TradeLog.ReasonChoices.STOP_LOSS:
            exit_reason_for_log = BacktestOperationLog.ExitReason.STOP_LOSS

        BacktestOperationLog.objects.create(
            backtest_run_id=self.service.backtest_run_id,
            position_id_ref=position.position_id,
            stock_code=position.stock_code_id,
            stock_name=position.stock_code.stock_name,
            trade_date=self.service.current_date,
            direction=BacktestOperationLog.Direction.SELL,
            exit_reason=exit_reason_for_log,
            profit_rate=profit_rate,
            loss_rate=loss_rate,
            buy_date_m_value=m_value,
            factor_scores=scores_str,
            price=sell_price,
            quantity=position.quantity,
            amount=sell_price * position.quantity
        )
        logger.debug(f"已记录卖出操作日志 for Position ID: {position.position_id}")

####文件结束####

####trade_manager\service\simulate_trade_old.py####
# trade_manager/service/simulate_trade.py

import logging
import shutil
import os
from datetime import date, timedelta
from decimal import Decimal, ROUND_HALF_UP
import numpy as np
import pandas as pd
import time
from django.conf import settings
from django.db import connections, transaction
import sqlite3
from common.models import (
    DailyFactorValues, DailyTradingPlan, Position, TradeLog, SystemLog,
    StrategyParameters, DailyQuotes, CorporateAction
)
from selection_manager.service.selection_service import SelectionService
from trade_manager.service.before_fix_service import BeforeFixService
from trade_manager.service.decision_order_service import DecisionOrderService
from trade_manager.service.monitor_exit_service import MonitorExitService
from .simulate_trade_handler import SimulateTradeHandler

logger = logging.getLogger(__name__)

class SimulateTradeService:
    """
    回测实施服务。
    """
    COMMISSION_RATE = Decimal('0.0002854')
    MIN_COMMISSION = Decimal('5')
    STAMP_DUTY_RATE = Decimal('0.001')
    SELL_SLIPPAGE_RATE = Decimal('0.002')
    ANNUAL_RISK_FREE_RATE = Decimal('0.015')
    TRADING_DAYS_PER_YEAR = 252

    def __init__(self):
        self.start_date: date = None
        self.end_date: date = None
        self.current_date: date = None
        self.initial_capital = Decimal('0.0')
        self.cash_balance = Decimal('0.0')
        self.portfolio_history = []
        self.last_buy_trade_id = None
        self.original_db_config = None
    def _load_db_to_memory(self, source_db_path: str):
        """
        【优化版】使用 SQLite Backup API 高效地将磁盘数据库加载到内存。
        """
        logger.info(f"开始将数据从 {source_db_path} 加载到内存 (使用 Backup API)...")
        start_time = time.time()
        
        # 1. 创建一个到源文件数据库的直接连接 (只读)
        try:
            source_conn = sqlite3.connect(f'file:{source_db_path}?mode=ro', uri=True)
        except sqlite3.OperationalError as e:
            logger.error(f"无法以只读模式打开源数据库 {source_db_path}: {e}")
            raise
 
        # 2. 获取到Django管理的内存数据库的底层连接
        mem_conn = connections['default'].connection
 
        try:
            # 3. 【核心优化】使用 backup 方法
            #    它会以最有效的方式（通常是按数据页）将源数据库内容复制到目标数据库
            source_conn.backup(mem_conn)
            
            duration = time.time() - start_time
            logger.info(f"数据成功加载到内存数据库，耗时: {duration:.2f} 秒。")
 
        except Exception as e:
            logger.error(f"使用 Backup API 加载数据到内存时发生错误: {e}")
            raise
        finally:
            # 4. 关闭连接
            source_conn.close()
            # mem_conn 不需要我们手动关闭，Django会管理它
 
    def _setup_environment(self):
        """
        修正版：调整了操作顺序，先加载数据，再执行ORM操作。
        """
        logger.info("--- 1. 准备回测环境 (内存模式) ---")
        
        base_dir = settings.BASE_DIR
        source_db = os.path.join(base_dir, 'mainDB.sqlite3')
        
        # 1. 关闭所有现有连接
        connections.close_all()
        
        # 2. 保存原始配置，并将 'default' 数据库重定向到内存
        self.original_db_config = settings.DATABASES['default'].copy()
        settings.DATABASES['default']['NAME'] = ':memory:'
        logger.info("已将 'default' 数据库连接重定向到 :memory:")
 
        # 3. 确保Django建立到新内存数据库的连接
        #    这一步至关重要，它会创建一个空的内存数据库实例
        connections['default'].ensure_connection()
        
        # 4. 【核心修正】立即将磁盘数据加载到内存数据库中
        #    此时，内存数据库从空变成了 mainDB.sqlite3 的一个完整克隆
        self._load_db_to_memory(source_db)
 
        # 5. 【顺序调整】现在内存数据库是完整的了，可以安全地执行任何Django ORM操作
        

        #DailyFactorValues, DailyTradingPlan,
        # 清空回测过程中会产生数据的表
        tables_to_clear = [
             Position,
            TradeLog, SystemLog
        ]
        # 使用 transaction.atomic() 来保证操作的原子性
        with transaction.atomic():
            for model in tables_to_clear:
                # 现在 model.objects.all() 可以正常工作了
                model.objects.all().delete()
                logger.info(f"已清空表: {model._meta.db_table}")
 
        # 读取策略参数
        # 现在 StrategyParameters.objects.all() 也可以正常工作了
        params = {p.param_name: p.param_value for p in StrategyParameters.objects.all()}
        max_positions = int(params.get('MAX_POSITIONS', Decimal('5')))
        max_capital_per_pos = params.get('MAX_CAPITAL_PER_POSITION', Decimal('10000'))
        self.initial_capital = Decimal(max_positions) * max_capital_per_pos
        self.initial_capital=150000
        self.cash_balance = self.initial_capital
        logger.info(f"初始资金已设定为: {self.initial_capital:.2f}")
 
    def _cleanup_environment(self):
        """在回测结束后恢复原始数据库配置"""
        if self.original_db_config:
            connections.close_all()
            settings.DATABASES['default'] = self.original_db_config
            # 内存数据库的连接关闭后，其内容会自动销毁，无需手动删除文件
            logger.info("已恢复 'default' 数据库连接到原始配置，内存数据库已释放。")
    def _get_trading_days(self) -> list[date]:
        dates = DailyQuotes.objects.filter(
            trade_date__gte=self.start_date,
            trade_date__lte=self.end_date
        ).values_list('trade_date', flat=True).distinct().order_by('trade_date')
        return list(dates)

    def _calculate_daily_portfolio_value(self):
        open_positions = Position.objects.filter(status=Position.StatusChoices.OPEN)
        market_value = Decimal('0.0')
        for pos in open_positions:
            try:
                quote = DailyQuotes.objects.get(
                    stock_code_id=pos.stock_code_id,
                    trade_date=self.current_date
                )
                market_value += quote.close * pos.quantity
            except DailyQuotes.DoesNotExist:
                market_value += pos.entry_price * pos.quantity
        
        total_value = self.cash_balance + market_value
        self.portfolio_history.append({
            'date': self.current_date,
            'total_value': total_value
        })
        logger.info(f"--- 日终结算 ({self.current_date}) ---")
        logger.info(f"现金: {self.cash_balance:.2f}, 持仓市值: {market_value:.2f}, 总资产: {total_value:.2f}")

    def _calculate_performance_metrics(self) -> dict:
        logger.info("--- 4. 计算回测性能指标 ---")
        if not self.portfolio_history:
            return {}

        df = pd.DataFrame(self.portfolio_history)
        df['total_value'] = df['total_value'].astype(float)
        df['daily_return'] = df['total_value'].pct_change().fillna(0)
        
        final_value = float(df['total_value'].iloc[-1])
        total_return_amount = final_value - float(self.initial_capital)
        total_return_rate = (final_value / float(self.initial_capital)) - 1

        mean_daily_return = df['daily_return'].mean()
        std_daily_return = df['daily_return'].std()
        
        if std_daily_return == 0 or np.isnan(std_daily_return):
            sharpe_ratio = 0.0
        else:
            daily_risk_free_rate = (1 + self.ANNUAL_RISK_FREE_RATE) ** Decimal(1/self.TRADING_DAYS_PER_YEAR) - 1
            sharpe_ratio = (mean_daily_return - float(daily_risk_free_rate)) / std_daily_return
            sharpe_ratio *= np.sqrt(self.TRADING_DAYS_PER_YEAR)

        result = {
            'total_return_amount': round(total_return_amount, 2),
            'total_return_rate': round(total_return_rate, 4),
            'sharpe_ratio': round(float(sharpe_ratio), 4)
        }
        logger.info(f"回测结果: {result}")
        return result

    def run_backtest(self, start_date: str, end_date: str) -> dict:
        try:
            self.start_date = date.fromisoformat(start_date)
            self.end_date = date.fromisoformat(end_date)

            self._setup_environment()

            handler = SimulateTradeHandler(self)
            
            trading_days = self._get_trading_days()
            if not trading_days:
                logger.error("在指定日期范围内未找到任何交易日，回测终止。")
                return {}

            baseline_date = trading_days[0] - timedelta(days=1)
            self.portfolio_history.append({'date': baseline_date, 'total_value': self.initial_capital})

            logger.info(f"--- 2. 开始日度回测循环 ({len(trading_days)}天) ---")
            for i, current_day in enumerate(trading_days):
                self.current_date = current_day
                logger.info(f"\n{'='*20} 模拟日: {self.current_date} ({i+1}/{len(trading_days)}) {'='*20}")

                prev_trading_day = trading_days[i-1] if i > 0 else None
                if prev_trading_day:
                    logger.info(f"-> [T-1 选股] 基于 {prev_trading_day} 的数据...")
                    selection_service = SelectionService(trade_date=prev_trading_day, mode='backtest')
                    selection_service.run_selection()

                logger.info("-> [T日 盘前校准] ...")
                before_fix_service = BeforeFixService(execution_date=self.current_date)
                before_fix_service.run()
                
                dividend_events = CorporateAction.objects.filter(
                    ex_dividend_date=self.current_date, event_type=CorporateAction.EventType.DIVIDEND
                )
                # 按股票代码分组，提高效率
                events_by_stock = {}
                for event in dividend_events:
                    events_by_stock.setdefault(event.stock_code, []).append(event)

                if events_by_stock:
                    # 获取所有可能受影响的持仓
                    open_positions_for_dividend = Position.objects.filter(
                        stock_code_id__in=events_by_stock.keys(),
                        status=Position.StatusChoices.OPEN
                    )
                    
                    for pos in open_positions_for_dividend:
                        # 找到该股票对应的所有分红事件（通常只有一个）
                        stock_events = events_by_stock.get(pos.stock_code_id, [])
                        for event in stock_events:
                            dividend_amount = event.dividend_per_share * pos.quantity
                            self.cash_balance += dividend_amount
                            logger.info(f"除息事件: 持仓ID {pos.position_id} ({pos.stock_code_id}) 获得分红 {dividend_amount:.2f}，现金余额更新为 {self.cash_balance:.2f}")



                logger.info("-> [T日 开盘决策与买入] ...")
                decision_order_service = DecisionOrderService(handler=handler, execution_date=self.current_date)
                decision_order_service.adjust_trading_plan_daily()
                
                while True:
                    open_positions_count = Position.objects.filter(status=Position.StatusChoices.OPEN).count()
                    max_pos = decision_order_service.current_max_positions
                    if open_positions_count >= max_pos:
                        break
                    
                    self.last_buy_trade_id = None
                    decision_order_service.execute_orders()
                    
                    if self.last_buy_trade_id:
                        decision_order_service.calculate_stop_profit_loss(self.last_buy_trade_id)
                    else:
                        break

                # 关键修复：在循环内实例化 MonitorExitService 并传入日期
                monitor_exit_service = MonitorExitService(handler=handler, execution_date=self.current_date)

                logger.info("-> [T日 盘中监控] 模拟价格跌至最低点...")
                handler.current_price_node = 'LOW'
                monitor_exit_service.monitor_and_exit_positions()

                logger.info("-> [T日 盘中监控] 模拟价格涨至最高点...")
                handler.current_price_node = 'HIGH'
                monitor_exit_service.monitor_and_exit_positions()

                self._calculate_daily_portfolio_value()

            logger.info("--- 3. 回测循环结束 ---")
            return self._calculate_performance_metrics()
        
        finally:
            # 确保无论成功还是失败，都清理环境
            self._cleanup_environment()

####文件结束####

####trade_manager\service\trade_handler.py####
# trade_manager/service/trade_handler.py

from abc import ABC, abstractmethod
from decimal import Decimal
from django.db import transaction
from django.utils import timezone
# 为了类型提示，我们可以从 common.models 导入 Position 和 TradeLog
# 注意：为了避免循环导入，通常在实现类中进行实际导入，这里仅为类型提示
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from common.models import Position, TradeLog



class ITradeHandler(ABC):
    """
    交易处理器抽象基类 (Abstract Base Class)。

    该接口定义了开盘决策与下单模块所需的所有外部交互行为。
    通过依赖此抽象接口而非具体实现，`DecisionOrderService` 可以与不同的
    交易环境（如真实交易接口、回测引擎）解耦。

    - 对于真实交易，实现类将通过API与券商服务器交互。
    - 对于回测，实现类将模拟这些交互，例如从历史数据中读取开盘价、
      模拟订单成交、并管理一个虚拟账户的余额。
    """

    @abstractmethod
    def get_opening_price(self, stock_code: str) -> Decimal:
        """
        获取指定股票在执行日的实际开盘价。

        :param stock_code: 股票代码，格式与 tb_stock_info 表一致 (如 'sh.600000')。
        :return: 当日的开盘价。如果无法获取（例如停牌），应引发异常或返回一个可识别的错误值（如Decimal('0.00')）。
        """
        pass

    @abstractmethod
    def place_buy_order(self, stock_code: str, price: Decimal, quantity: int) -> None:
        """
        提交一个买入订单。

        此方法的实现者负责处理与交易系统的所有交互。根据需求，此方法
        在执行时，需要完成以下数据库操作：
        1. 在 `tb_positions` 表中插入一条新的持仓记录，其中所有非空字段
           （如 current_stop_loss, current_take_profit）可使用哨兵值（如-1）填充，
           等待后续的止盈止损计算任务来更新。
        2. 在 `tb_trade_log` 表中插入一条对应的交易记录，初始状态应为
           'pending'。

        :param stock_code: 股票代码。
        :param price: 预期的买入限价。
        :param quantity: 计划买入的股数（必须是100的整数倍）。
        :return: 无返回值。
        """
        pass

    @abstractmethod
    def get_available_balance(self) -> Decimal:
        """
        查询当前账户的可用资金余额。

        :return: 可用于交易的现金余额。
        """
        pass

    
    @abstractmethod
    def get_realtime_price(self, stock_code: str) -> Decimal | None:
        """
        获取一只股票的实时价格。
 
        :param stock_code: 股票代码，格式如 'sh.600000'。
        :return: 该股票此时此刻的市场价 (Decimal类型)。如果获取失败（如网络问题、股票停牌），
                 应返回 None，以便调用方进行错误处理。
        """
        pass
 
    @abstractmethod
    def sell_stock_by_market_price(self, position: 'Position', reason: str) -> None:
        """
        以市价单全量卖出指定的持仓。
 
        此方法的具体实现需要完成一个原子性的操作流程：
        1. 调用交易API，以市价单卖出 `position.quantity` 数量的 `position.stock_code`。
        2. **在API调用成功返回成交回报后**，执行以下数据库操作：
           a. **更新持仓表 (tb_positions)**: 将传入的 `position` 对象的状态更新为 'closed'。
              `position.status = Position.StatusChoices.CLOSED`
              `position.save()`
           b. **插入交易记录 (tb_trade_log)**: 创建一条新的卖出记录。
              - `position`: 关联到此持仓。
              - `stock_code`: 股票代码。
              - `trade_datetime`: 交易的实际成交时间。
              - `trade_type`: 'sell'。
              - `order_type`: 'market'。
              - `quantity`: 实际成交数量。
              - `price`: 实际的成交均价。从成交回报中获取。如果无法立即获取，
                                            则使用 -1 作为占位符，等待后续任务回补。
              - `commission`, `stamp_duty`: 从成交回报中获取。如果无法立即获取，
                                            则使用 -1 作为占位符，等待后续任务回补。
              - `reason`: 使用传入的 `reason` 参数 ('take_profit' 或 'stop_loss')。
              - `status`: 'filled' (已成交)。
        3. 整个数据库更新过程应该被包裹在一个事务中 (`transaction.atomic`)，确保数据一致性。
 
        :param position: 要卖出的持仓对象 (common.models.positions.Position)。
                         该对象包含了持仓ID、股票代码、持仓数量等所有必要信息。
        :param reason: 卖出原因的字符串，如 'take_profit' 或 'stop_loss'。
                       这个值将用于填充交易记录表的 `reason` 字段。
        :return: 无返回值。如果执行失败（如API调用失败、股票跌停无法卖出），
                 应在方法内部处理异常（如记录日志），并向上层调用者（MonitorExitService）
                 抛出异常或通过其他方式通知失败，以便上层决定是否重试。
        """
        pass
####文件结束####
