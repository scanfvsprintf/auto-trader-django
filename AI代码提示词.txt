我现在要实现交易模块的代码，
你需要实现的有两部分：
trader_manager.service.real_trade_handler.py
这个文件为实现交易的具体实现，负责调用easytrader进行数据返回
另一个为基于APScheduler定时调度，负责串联整个流程
帮我编写代码。在写代码前，你先详细捋捋你的思路与设计，接着问我还有哪些待确认的事项，输出问题，然后我来回答后你再写代码
有以下要求：
1.严格按照设计文档设置执行时间与定时调度，整个流程你可以参考现有的回测模块SimulateTradeService，但是执行的逻辑是不一样的，回测模块没有中间态，现在业务发生交易后，落库数据必须是中间态
2.除了文档中的业务定时调度外，你还需要增加两个更新交易状态的定时调度任务，第一个事在每个交易日的执行时段内，你需要每10秒用查询easytrader（我的easytrader基于华泰客户端连接）我的订单状态并更新数据库；第二个是早上六点执行更新数据库里的除权除息信息，调用CorporateActionService，其中你传入的日期跨度得前后各推移30天，增量更新库
3.real_trade_handler再加一个变量标志，代表是实盘模拟观测阶段还是实盘交易阶段，如果是实盘模拟观测阶段，逻辑有降级，不会真实的去调用easytrader的交易接口，而更新交易状态的定时调度任务，直接更新交易状态为成功，并且计税等事项参考回测模块的逻辑
4.real_trader_handler里，除了出口对外提供的方法实现外，具体去调用easytrader的api你必须用单独的内部方法去封装，这是为了未来更好的切换数据源，不能和执行数据库操作的事项耦合在一起
5.你的实际处理逻辑得尽量和回测模块对齐，就像每一天你要尽可能的实施符合条件的交易预案，试图填满最大仓数，意味着你需要循环调用decision_order_service.py里的execute_orders接口
6.需要用到其他代码依赖时，得仔细读代码,你捋的流程得足够详细
7.你得智能判断交易日，不是每个周末都不是交易日，也不是周一到周五都是交易日，并且回测模块里的查询日线表判断对于实际交易模块是不能使用的，你得有更先进的办法，这部分必须详细体现在你的思路文档里
8.新增一个config.json的配置文件，里面保存我的easytrader基础连接信息，以及我的定时调度状态（这个状态有三个，第一个是彻底关闭，用于我回测；第二个是空转，只打印任务开始执行，用于我后期验证任务调度流程是否正确；第三个是实际运行，执行调度任务）
9.APScheduler你得与django深度集成

这是我现在的设计文档：
1. 项目概述
1.1 系统目标
本系统旨在构建一个服务于小额资金（初始设定为5万元人民币）的、全自动化的、基于多因子模型的A股市场中低频量化交易策略。系统的核心哲学是先求不败，再求大胜，将风险控制置于盈利预期之上。其最终目标是通过一套系统化、纪律化、可重复的流程，在复杂多变的A股市场中，发掘并捕捉具备良好风险回报比的交易机会，以期实现长期、稳健、超越市场基准的资本增值。
1.2 设计原则
本系统的构建遵循以下五大核心原则，它们是贯穿整个系统设计、开发、测试与运行全过程的指导方针。
● 系统化 : 将所有模糊的、经验性的交易直觉，转化为精确、可量化、无歧义的数学模型与计算机程序。人类在面对金融市场的涨跌时，极易受到贪婪、恐惧、侥幸心理和处置效应等情绪偏见的影响，导致决策的非理性与不一致。本原则要求彻底根除这种主观干扰，确保每一次交易决策都严格遵循预设的逻辑，无论市场情绪如何狂热或悲观，系统的执行标准都恒定不变。
● 模块化 : 整个系统被解构成一系列高内聚、低耦合的功能模块，具体包括数据处理、日终选股、开盘决策、盘中监控与回测优化。每个模块的职责单一且明确，接口定义清晰。这种设计理念如同现代工业的流水线，极大地简化了系统的开发、测试、故障排查和未来功能迭代的复杂性。例如，当我们需要更换一个因子时，只需修改日终选股模块，而无需触动其他部分，使得系统具备良好的可维护性和可扩展性。
● 数据驱动 : 系统的所有决策，从股票的筛选、排序，到买卖点位的精确确定，均严格基于可获取、可验证的历史与实时市场数据。任何策略的有效性都必须通过严格、科学的回测框架进行检验，拒绝任何未经数据证实的主观臆断和“想当然”。本原则强调，我们相信的是数据的统计规律，而非个别的、传奇性的交易故事。
● 风险优先 : 本系统将风险管理视为交易流程的第一道关卡，而非盈利之后的附属品或事后补救措施。与追求单次交易最高收益的思路相反，本策略将长期生存能力放在首位。这体现在多个层面：入场前，通过严格的开盘价区间过滤掉高风险的交易机会；持仓中，通过自适应的止损机制控制单笔交易的最大回撤；在系统层面，通过科学的仓位管理来分散非系统性风险。我们追求的是长期稳定的夏普比率，而非短期暴利。
● 成本敏感 : 深刻认识到对于小额资金账户，交易成本，尤其是券商佣金的最低5元收费标准，是侵蚀利润的一个重要且不可忽视的因素。小额的交易极有可能导致利润被手续费完全吞噬。因此，本策略在设计上尽可能的让每一次交易覆盖最低手续费支出。这一设计的目的是为了确保每一笔被执行的交易，其预期收益在概率上能够显著覆盖其双边交易成本，从而避免因无效的高频换手而导致的“手续费内耗”。
2. 系统架构
本系统采用事件驱动的模块化架构，将一个完整的交易生命周期，从机会的发现到交易的终结，清晰地划分为四个按时间顺序执行的核心模块。这种架构确保了数据流的单向性、逻辑的清晰性与执行的可靠性，如同一个精密的工厂流水线，各司其职，协同工作。
1. 日终选股与预案生成模块 (T-1日 18:00 后)
  ○ 触发时机: 每个交易日收盘后，在确认当日所有数据均已更新完毕后启动。
  ○ 核心职责: 此模块是策略的大脑和情报分析中心，负责在非交易时间进行大规模的、计算密集型的数据分析工作。它扫描整个A股市场，基于一套多维度因子评分模型，对数千只股票进行全面的评估、打分和排序。最终，它会筛选出一个规模较小，通常为10支的精英候选股池，我们称之为次日观察池。本模块最重要的产出，不仅是这个股票列表，更是为列表中的每一支候选股，都精确计算出一个合理开盘价区间，作为次日交易决策的刚性先决条件。
2. 盘前校准与预案修正模块 (T日 08:30 - 09:00)
  a. 触发时机: T日开盘前，在获取到最新的除权除息公告后，集合竞价前。
  b. 核心职责: 此模块是策略应对非交易性价格变动的“校准中心”。其唯一职责是获取当日所有发生除权除息事件的股票列表，并基于这些信息，对系统中的两个核心数据集进行精确修正：
    ⅰ. 修正交易预案: 重新计算“次日观察池”中受影响股票的MIOP和MAOP。
    ⅱ. 修正持仓风控: 重新计算“持仓信息表”中受影响股票的止盈价和止损价。 同时，该模块还承担着对配股这类复杂事件的特殊风险排查任务，确保策略不会介入或持有此类需要人工决策和额外资金投入的股票。
3. 开盘决策与下单模块 (T日 09:25:01 - 09:30:00)
  ○ 触发时机: T日集合竞价结果产生后的黄金五分钟内。
  ○ 核心职责: 此模块扮演着连接理论研究与实战交易的关键决策网关。它在时间高度敏感的环境下工作，获取“次日观察池”中所有股票的实际开盘价，并逐一与T-1日计算出的“合理开盘价区间”进行比对。只有开盘价精准地落入该预设区间的股票，才被视为一个有效的、符合策略预期的交易候选。然后，系统会根据预设的优先级规则，例如选择原始综合得分最高的一支，作为当日唯一的买入目标。确定目标后，模块会立即计算仓位大小，并生成一份带有微小上滑点的限价单，通过交易应用程序接口执行买入操作。
4. 盘中持仓监控与退出模块 (T日 09:30:01 - 14:57:00)
  ○ 触发时机: 在确认买入订单成功成交后即刻启动，并在整个交易时段内持续运行。
  ○ 核心职责: 此模块是策略的执行官，全权负责已建成仓位的风险管理和利润锁定。它以高频率（例如每3-5秒）持续监控持仓股票的实时价格，并严格对照一个动态的、自适应的风控体系。该体系包括基于实际成交成本计算出的自适应止损价和动态止盈价。一旦实时价格触及预设的任一边界，模块会绕过所有犹豫和侥幸，立即触发市价卖出指令，确保交易纪律的绝对、严格执行。
5. 回测与优化模块 (离线运行)
  ○ 触发时机: 由研究人员在非交易时间人工启动，用于策略的研发、验证和迭代。
  ○ 核心职责: 此模块旨在构建一个与真实市场环境高度相似的数字孪生沙盒环境。它能够完整地、高保真地复现上述三个在线模块的所有逻辑，包括数据处理、选股、开盘决策、成本滑点模拟以及盘中监控的全部细节。其主要目的有二：一是验证策略的有效性，通过在长周期的历史数据上进行模拟交易，评估其在牛市、熊市、震荡市等不同市场阶段的盈利能力和抗风险能力。二是优化策略参数，通过系统化的方法，例如本方案后续将详细阐述的迭代式单参数优化，寻找一组能够显著提升策略表现的、并且具备良好泛化能力的健壮参数组合。
3. 模块详细设计
3.1 数据处理模块
● 职责:
  ○ 历史数据管理: 作为整个系统的基石，负责数据的获取、存储和维护。使用 akshare 等稳定可靠的开源工具库，每日定时（例如17:00）获取全市场A股的日线行情数据。获取的数据必须包含后复权因子，这是保证历史数据可比性的关键。所有数据将被存入一个本地关系型数据库中，例如 SQLite 用于轻量级部署，或 MySQL/PostgreSQL 用于更大数据量和更高并发的场景。
  ○ 数据规整与清洗: 在数据入库前，必须进行基础的数据清洗工作，例如检查是否存在价格为0或负数、成交量为负等明显异常值，并处理API可能返回的空值。
  ○ 基准价格生成: 为了进行无偏的、跨越时间的策略研究，例如计算移动平均线、收益率等技术指标，必须使用经过复权处理的价格序列。本系统统一采用后复权价格作为所有历史分析的基准。在数据库层面，动态生成一个计算列 hfq_close。
    ■ 计算公式: hfq_close = close * adjust_factor
    ■ 后复权价格的必要性深度解析: 假设某股票在T-1日收盘价为20元。T日该公司实施了10送10的分配方案，其股价在T日开盘时会自然变为10元。如果直接使用这个不复权的价格序列，那么任何基于价格的计算，比如计算20日移动平均线，都会在T日出现一个巨大的、无任何经济学意义的断崖。这会导致所有技术指标在这一天完全失真，策略模型会误判为一次剧烈的暴跌，从而产生错误的交易信号。后复权通过将T-1日及以前的所有价格按比例调高（在这个例子中是乘以2），使得调整后的T-1日收盘价变为40元，而T日收盘价仍为10元（假设当天平盘）。这样，价格序列在图形上是连续的，能够真实地反映股东总权益的实际增长轨迹，从而保证了所有技术分析的有效性。
3.2 日终选股与预案生成模块
● 职责: 在T-1日收盘后，运用一套严谨的多因子模型，从数千只股票中大浪淘沙，生成T日具体、可执行的交易预案。
● 执行流程:
  a. 数据加载: 从本地数据库中加载截至T-1日的全市场最新日线数据。
  b. 初步筛选 : 建立一个基础的、排除了具有明显风险或不适合本策略进行交易的股票池。这个过程是后续精细化选股的前提。
    ■ 剔除ST股: 坚决剔除所有名称前带有 ST 和 *ST 标记的股票。这类股票通常因为公司财务状况出现严重问题而被交易所实施特别处理，存在极高的退市风险和剧烈的非市场性波动。
    ■ 剔除次新股: 剔除上市交易日未满60个自然日的股票。次新股在上市初期往往因为筹码不稳定、估值不明确而表现出极端的波动性，其价格走势更多受情绪和炒作影响，而非基本面或技术面。同时，过短的历史数据也无法支撑本策略中部分技术指标（如60日均量）的有效计算。
    ■ 剔除低流动性股: 剔除近20个交易日日均成交额低于1亿元人民币的股票。流动性是交易的生命线。对于成交稀疏的股票，即使策略发出了买卖信号，也可能因为缺乏对手盘而无法顺利成交，或者自身的买卖行为就会对股价造成巨大的冲击，导致实际成交价远劣于预期。1亿元的门槛确保了我们的交易对象具备足够的市场深度。
  c. 因子计算与标准化: 对经过初步筛选的股票池，计算模型所需的全部原始因子值。随后，对每一个因子，在T-1日的股票截面上，统一使用3.2.1节中详细定义的 norm 函数进行标准化处理。此步骤的目的是将所有不同量纲、不同分布的原始因子值，全部转化为一个统一的、位于 [-100, 100] 区间的标准化评分。
  d. 综合评分: 使用3.2.2节中定义的 f(x) 选股评分函数，对股票池中的每一只股票计算其最终的综合得分。然后，对所有股票按照此综合得分进行降序排列，选取排名最高的Top 10，构成“次日观察池”。
  e. 生成开盘价决策区间: 对观察池中的这10支精英候选股，逐一计算其在T日的合理开盘价区间，即明确其最低可接受开盘价 (MIOP) 和 最高可接受开盘价 (MAOP)。
    ■ 最低可接受开盘价 (Minimum Acceptable Open Price, MIOP): 此项设计的目的是为了过滤掉那些因为夜间突发重大利空消息（例如业绩爆雷、核心人物被调查、行业遭遇重磅利空政策等）而导致开盘时出现大幅非理性跳水的股票。我们的策略旨在捕捉稳健的上升趋势，而非冒险去博弈这种暴跌后的反弹。
      ● 计算公式: MIOP = Close_T-1 * (1 - k_drop * (ATR_14,T-1 / Close_T-1))
    ■ 最高可接受开盘价 (Maximum Acceptable Open Price, MAOP): 此项设计的目的是为了过滤掉那些因为市场情绪过度狂热或突发重大利好消息刺激而导致开盘时大幅向上跳空的股票。在这种情况下直接追入，往往意味着承担了过高的初始成本和当日价格回落的风险。
      ● 计算公式: MAOP = Close_T-1 * (1 + k_gap * (ATR_14,T-1 / Close_T-1))
    ■ 变量定义:
      ● Close_T-1: 指的是T-1日的不复权收盘价。因为开盘价本身是不复权的，所以用于比较的边界也必须是不复权的。
      ● ATR_14,T-1: 指的是截至T-1日收盘时计算出的14日平均真实波幅。这个指标客观地度量了该股票在最近14个交易日里的平均每日波动幅度。
      ● k_drop: 这是一个低开容忍系数。它是一个需要通过回测优化的正数参数，例如设定为 0.3。其物理意义是：我们最多能容忍的开盘向下跌幅，不应超过其近期平均日波动幅度的30%。超过这个幅度的低开，我们倾向于认为背后有未知的负面信息。
      ● k_gap: 这是一个高开容忍系数。它也是一个需要优化的正数参数，例如设定为 0.5。其物理意义是：我们最多能容忍的开盘向上跳空幅度，不应超过其近期平均日波动幅度的50%。超过这个幅度的跳空，我们认为短期情绪可能过热，风险收益比变差。
  f. 数据输出: 将最终生成的“次日观察池”（包含股票代码、f(x)综合得分）以及每一支股票对应的MIOP与MAOP，以结构化的数据格式（例如JSON文件或一个专门的数据库表）进行持久化存储。这份数据是次日开盘决策模块唯一需要读取的输入信息。
3.2.1 核心方法：因子标准化处理
因子标准化是多因子模型中至关重要的一步。如果处理不当，会导致不同因子之间的权重失去意义，模型表现也会大打折扣。为确保所有因子能够在同一尺度上进行公平的比较和加权，并增强模型对于金融数据中常见极端值的稳健性，我们不采用简单的Z-score或Min-Max方法，而是采用一种更为专业和稳健的百分位映射法。此方法能将每个因子的原始值 x，映射到一个标准化的、具有直观商业意义的评分 Score，其值域被严格限定在 [-100, 100]。
● 函数定义: Score = norm(x, direction)
  ○ x: 指的是某一只股票在某个因子上的原始计算值。
  ○ direction: 这是一个字符串参数，用于指明该因子的方向性，其取值为 positive 或 negative。
    ■ positive: 表示该因子的原始值越大，我们认为其对股价的未来表现越有利，因此应该得到越高的评分。例如，价格涨幅、均线斜率等。
    ■ negative: 表示该因子的原始值越小，我们认为其越有利，因此应该得到越高的评分。例如，股价波动率。
● 执行步骤 (在每个交易日的股票截面上，对单个因子独立进行):
  a. 计算稳健边界: 对当日股票池中所有股票的某一个因子 x 的数值集合，我们不计算其绝对的最大值和最小值，而是计算其 1%分位数 (P1) 和 99%分位数 (P99)。在金融数据中，极端值是常态，可能源于数据错误、特殊事件或流动性极差的股票。使用百分位数作为边界，可以有效地将这些极端异常值排除在核心区间的计算之外，避免它们对整体评分分布造成不成比例的扭曲。
  b. 数据压缩 (Winsorization): 对每一个原始因子值 x，我们将其与计算出的稳健边界 P1 和 P99 进行比较。如果 x 的值小于 P1，则将其值强制设定为 P1；如果 x 的值大于 P99，则将其值强制设定为 P99。这个过程在统计学上称为“缩尾处理”，其目的是将所有离群值“拉回”到核心数据群体的边缘，从而“钝化”这些极端值对后续线性映射的过度影响。
    ■ 处理后的值 x_prime = max(P1, min(x, P99))
  c. 线性映射至评分区间: 将经过缩尾处理后的值 x_prime，通过一个简单的线性变换，映射到我们预设的 [-100, 100] 评分区间。
    ■ 处理特殊情况: 在极少数情况下，如果一个因子的所有股票取值都完全相同，会导致 P99 小于或等于 P1。为了避免计算中出现分母为零的错误，此时我们将所有股票在该因子上的得分统一设定为 0。
    ■ 根据因子方向进行映射:
      ● 如果 direction 为 positive (值越大，得分越高):
        ○ Score = ( (x_prime - P1) / (P99 - P1) ) * 200 - 100
        ○ 公式解释: 当一个股票的因子值 x_prime 等于 P1 (即在所有股票中表现最差的1%)时，括号内的分式为0，最终得分为-100。当其值等于 P99 (即表现最好的1%)时，分式为1，最终得分为+100。处于中间的值则按比例线性分布在这两者之间。
      ● 如果 direction 为 negative (值越小，得分越高):
        ○ Score = ( (P99 - x_prime) / (P99 - P1) ) * 200 - 100
        ○ 公式解释: 此时分子被反转。当 x_prime 等于 P99 (表现最差)时，分子为0，得分为-100。当 x_prime 等于 P1 (表现最好)时，分子等于分母，得分为+100。
3.2.2 核心函数 f(x) (选股评分函数)
● 注: 在此评分函数中，所有使用的 norm 函数即为 3.2.1节 中详细定义的标准化函数。所有的因子权重 k_i 和维度权重 w_dim 均为正数，因为因子的正负向关系已经在 norm 函数内部通过 direction 参数得到了妥善处理。
● 总分公式:
  ○ f(x) = w_trend * Score_trend + w_momentum * Score_momentum + w_quality * Score_quality
  ○ 变量定义:
    ■ w_trend, w_momentum, w_quality: 分别代表趋势、动能、质量这三个维度的权重。这些权重需要通过回测进行优化，以反映在特定市场阶段下哪一类因子的重要性更高。它们三者之和必须恒等于1。
● 趋势维度 (Score_trend): 此维度旨在衡量价格走势的持续性和方向性，寻找那些已经形成稳定上升趋势的股票。
  ○ Score_trend = k1 * norm(x1, 'positive') + k2 * norm(x2, 'positive') + k3 * norm(x3, 'positive')
  ○ 因子详解:
    ■ x1: 20日简单移动平均线 (MA20) 的回归斜率。我们取过去20个交易日的MA20数值，将它们视为一个时间序列，然后对这个序列进行一元线性回归。得到的斜率值 x1 客观地量化了中期趋势的方向和强度。正斜率表示中期趋势向上，斜率的绝对值越大，趋势越强劲。
    ■ x2: 均线排列评分。这是一个定性指标的量化表达，用于评估短期、中期、长期均线的排列结构。具体评分规则为：如果当日收盘价大于5日均线，得1分；如果5日均线大于10日均线，得1分；如果10日均线大于20日均线，得1分。总分范围为0到3分。得分越高，代表市场成本支撑越强，形成所谓“多头排列”的看涨技术形态。
    ■ x3: ADX趋势强度。ADX指标本身不区分上涨或下跌，只衡量趋势的“强度”或“存在感”。我们对其进行改造：只有当 ADX 指标值大于25（通常认为趋势开始形成）并且代表上涨方向的+DI线在代表下跌方向的-DI线之上时，我们才取ADX的值作为因子值，否则因子值为0。这确保了我们只关注处于明确上升趋势中的股票的趋势强度。
● 动能维度 (Score_momentum): 此维度旨在衡量价格变化的爆发力和速度，捕捉那些短期内表现出强劲上涨势头的股票。
  ○ Score_momentum = k4 * norm(x4, 'positive') + k5 * norm(x5, 'positive') + k6 * norm(x6, 'positive')
  ○ 因子详解:
    ■ x4: 10日价格变化率 (ROC10)。计算公式为 (今日收盘价 / 10日前收盘价 - 1) * 100。它直接衡量了股票在过去两周内的涨速，是捕捉短期强势股最直接的指标之一。
    ■ x5: 成交量突破。计算为 最近5日的平均成交量 / 最近60日的平均成交量。这个比值如果显著大于1，通常意味着近期有增量资金正在积极入场，当前的价格上涨是由真实的买盘推动的，而非存量资金的博弈，这大大增加了上涨趋势的可靠性。
    ■ x6: 新高动能。计算为 当前收盘价 / 过去60个交易日内的最高价。这个比值越接近1，说明股价正处于或非常接近阶段性的新高。处于这种位置的股票，上方的历史套牢盘压力较小，一旦突破，后续的上涨空间可能更大。
● 质量/风控维度 (Score_quality): 此维度旨在从风险的角度筛选股票，偏好那些内在走势更稳定、风险水平更低的品种。
  ○ Score_quality = k7 * norm(x7, 'negative') + k8 * norm(x8, 'positive')
  ○ 因子详解:
    ■ x7: 波动率。计算为最近20个交易日每日收益率的标准差。这是一个核心的风险指标，标准差越大，代表股价在近期表现得越不稳定，未来的不确定性也越高。我们的策略偏好更平稳的上涨，因此这是一个负向因子，其 direction 为 negative，即波动率越低，得分越高。
    ■ x8: 流动性。计算为最近20个交易日的日均成交额。高流动性对于任何交易策略都至关重要，它不仅降低了交易的冲击成本，更是在市场出现极端情况时能够顺利退出的安全保障。因此，这是一个正向因子，流动性越好，得分越高。

3.3 盘前校准与预案修正模块 
● 职责: 在T日开盘前，根据官方发布的除权除息信息，对所有在途的交易计划和持仓风控价格进行精确的数学调整，并剔除高风险的配股事件。
● 执行时段: T日 08:30:00 - 09:00:00
● 执行流程: 
  a. 获取除权除息信息: 在T日早上（例如8:30），通过数据接口获取当日（以除权除息日为准）所有A股的股权登记变更信息，包括但不限于：现金分红（除息）、送股、转增股（除权）、配股。 
  b. 价格校准核心算法: 对每一个受影响的股票，根据其T-1日的不复权收盘价 Close_T-1 和事件详情，计算出其理论上的除权除息参考价 Adjusted_Close_T-1。
    ■ 现金分红 (除息): 
      ● Adjusted_Close_T-1 = Close_T-1 - Dividend_Per_Share 
      ● (其中 Dividend_Per_Share 为每股税前派息额)
    ■ 送股/转增股/并股/拆股 (除权): 
      ● Adjusted_Close_T-1 = Close_T-1 * (share_before)/ (share_after)
      ●  参数说明:
        ○ share_before: 送股/转增股/并股/拆股前的值
        ○ share_after: 送股/转增股/并股/拆股后的值
      ● 示例：
        ○ 10赠3，则share_before=10，share_after=13
        ○ 10合1，则share_before=10，share_after=1
    ■ 配股 : 
      ● Adjusted_Close_T-1 = (share_before * Close_T-1 + (share_after - share_before) * rights_issue_price) / share_after
      ● 参数说明:
        ○ share_before: 配股前的基准股数。
        ○ share_after: 配股后的总股数。
        ○ rights_issue_price: 配股价格，即参与配股时每股的认购价格
      ● 示例：
        ○ 10配3，配股价8元，则share_before=10，share_after=13，right _issue_price=8
      ● 注意事项：
        ○ 对于涉及配股的股票，应被放弃购入或立刻售出，因此目前该计算不会被实际运行
    ■ 复合事件: 
      ● 若同时发生多种事件，则按顺序依次计算：
        ○ Step 1: 
          ■ 计算除息后价格
        ○ Step 2: 
          ■ 在除息后价格基础上，计算送/转股后价格
        ○ Step 3: 
          ■ 在第二次调整后价格基础上，计算配股后最终参考价 
      ● 注意事项：
        ○ 对于涉及配股的股票，应被放弃购入或立刻售出，因此Step3不会被实际运行
  c. 修正交易预案: 
    ■ 遍历“次日观察池”中的每一支股票。 
    ■ 若某股票今日有除权除息事件，则其在T-1日计算的MIOP和MAOP已经失效。我们需计算一个价格调整比率 (Price Adjustment Ratio) 来校准它们。： 
      ● 价格调整比率: 
        ○ Ratio = Adjusted_Close_T-1 / Close_T-1
      ● 基于此比率，对预设的开盘价区间进行等比例缩放：
        ○ MIOP_new = MIOP_old * Ratio
        ○ MAOP_new = MAOP_old * Ratio 
    ■ 将数据库中对应记录的MIOP和MAOP更新为新值。 
  d. 修正持仓风控: 
    ■ 遍历所有“持仓中”的股票。 
    ■ 若某持仓股今日有除权除息事件，其基于历史成本价AEP计算的止盈止损位也已失效，也必须进行等比例调整，以维持原有的盈亏比设定：
      ● 价格调整比率: 
        ○ Ratio = Adjusted_Close_T-1 / Close_T-1 
      ● 基于此比率，对预设的止盈止损区间进行等比例缩放：
        ○ Take_Profit_Price_new = Take_Profit_Price_old * Ratio 
        ○ Stop_Loss_Price_new = Stop_Loss_Price_old * Ratio 
    ■ 将数据库中对应持仓的止盈价和止损价更新为新值。 
  e. 配股事件特殊处理: 
    ■ 对于交易预案: 对于开盘前或30日内发生过配股的股票，应该使其不会被开盘决策与下单模块选中，将最高可接受开盘价（MAOP）置为0，最低可接受开盘价（MIOP）置为99999。 
    ■ 对于持仓: 若发现某持仓股T日为配股除权日，这构成了策略的紧急退出条件。系统应为其止盈价置为0，止损价置为99999。
3.4 开盘决策与下单模块
● 职责: 在T日开盘后的黄金几分钟内，基于T-1日制定的严谨预案，做出最终的、唯一的买入决策，并高效、可靠地完成下单操作。
● 执行时段: T日 09:25:01 - 09:30:00
● 执行流程:
  a. 加载预案: 模块在09:25准时启动，第一件事就是从持久化存储中（JSON文件或数据库）加载T-1日晚间生成的“次日观察池”以及其中每只股票对应的MIOP和MAOP。
  b. 获取开盘价: 在09:25集合竞价结果产生后，系统立即通过 akshare 的实时行情接口，批量获取观察池中所有股票的实际开盘价 (Open_T)。
  c. 最终筛选: 遍历观察池中的10支股票，对每一支都执行开盘价验证。只有当某支股票的实际开盘价 Open_T 同时满足以下两个条件时，它才能进入最终的候选名单：
    ■ Open_T >= MIOP  并且  Open_T <= MAOP
    ■ 这个双边过滤条件是本策略风险控制体系中至关重要的一道防线。它既能有效避免在市场情绪过热时追高，也能防止买入那些因未知重大利空而大幅低开的“问题股”。
  d. 唯一标的选择:
    ■ 情况一: 如果经过上述筛选后，最终的候选名单为空，这意味着当日市场的开盘情况不符合本策略为任何一支候选股设定的入场条件。此时，系统将放弃今日所有的买入操作，并生成一条“无合适买点”的日志。这并非策略的失败，而是一种内化的、主动的市场风险规避机制。随后，本模块执行结束。
    ■ 情况二: 如果最终候选名单中包含一支或多支股票，系统将遵循“优中选优”的原则，选择其中在T-1日计算出的 f(x) 综合得分最高的那一支，作为今日的唯一买入目标。
  e. 仓位计算:
    ■ 单笔名义本金 (Nominal Principal, NP): 我们的策略采用等名义本金的仓位管理方法。计算公式为：NP = 当前账户总资产 / 预设的最大持仓股票数量。例如，若总资产为50000元，计划最多同时持有5支股票，则单笔名义本金为10000元。
    ■ 计划买入股数 (Shares to Buy, StB): 根据名义本金和目标股票的开盘价，计算出理论上可以购买的股数，并向下取整到100的倍数，因为A股市场的最低交易单位为1手，即100股。
      ● StB = floor( (NP / Open_T) / 100 ) * 100
  f. 下单执行:
    ■ 为了在开盘后价格可能快速波动的几分钟内，最大限度地提高订单的成交概率，避免因微小的价格跳动而导致订单失效（废单），我们设置一个微小的价格滑点缓冲区。
    ■ 下单限价 (Limit Price):
      ● Limit_Price = Open_T * (1 + k_slip)
      ● k_slip: 这是一个下单滑点系数，是一个微小的正值，例如 0.003。这意味着我们愿意以比开盘价最高上浮0.3%的价格提交限价单，以此来“抢”到成交机会。这个系数也是一个可以优化的参数。
    ■ 系统通过 easytrader 库，将计算出的 Limit_Price 和 StB 封装成一个限价买入单 (Limit Order)，并发送给券商的交易服务器。
  g. 交易后处理:
    ■ 下单后，系统需要通过轮询查询订单状态的API，来确认订单的成交情况。一旦订单被确认为完全成交，系统必须立即记录下这笔交易的实际成交均价 (Actual Execution Price, AEP) 和实际成交股数。
    ■ 关键一步: 在获取到 AEP 的一瞬间，系统必须立即调用风控函数 g(y) 和 h(z)，基于这个真实的、分毫不差的成本价，为这笔新建立的持仓计算出其初始的止盈价和止损价。
    ■ 最后，将这笔持仓的完整信息（包括股票代码、持仓成本AEP、持仓股数、初始止盈价、初始止损价、持仓状态等）存入一个专门的持仓管理数据库表中，并激活“盘中持仓监控与退出模块”对这笔新仓位进行监控。
    ■ 如果买入指令因流动性问题（如开盘后迅速涨停）在15分钟内未能成交并被撤单，进行以下策略：
      ● 撤单后，系统应立即依次顺位检查最终候选名单中排名在次一位的股票，看其当前价格是否仍在MIOP/MAOP区间内，若是，则尝试买入次位优选
3.5 盘中持仓监控与退出模块
● 职责: 作为策略纪律的忠实守护者，以机器的精准和不知疲倦，严格、实时地执行所有已建立持仓的退出策略。
● 执行时段: T日 09:30:00 - 14:57:00。在收盘集合竞价前几分钟停止监控和交易，以避免尾盘阶段的异常波动和流动性问题。
● 执行流程 (本地轮询):
  a. 加载持仓: 模块启动时，首先从持仓管理数据库中查询所有状态为“持仓中”的股票，并加载它们的所有相关信息，特别是不复权的止盈价和止损价。
  b. 循环监控: 系统以一个设定的频率（例如每3秒）执行一次完整的监控循环。
    ■ 通过 akshare 的实时行情接口，批量获取所有持仓股票的最新不复权实时价格 (Current Price)。
    ■ 遍历持仓列表，对每一只股票，将其 Current Price 与其预设的退出边界进行比较，执行退出条件判断：
      ● 止损检查: if Current_Price <= Stop_Loss_Price
        ○ 一旦条件满足，系统会立即触发最高优先级的操作：通过 easytrader 以市价单发出卖出指令。止损是风险控制的底线，必须以最快的速度、不计较微小价差地保证成交。
      ● 止盈检查: elif Current_Price >= Take_Profit_Price
        ○ 一旦条件满足，系统同样会立即通过 easytrader 以市价单发出卖出指令，锁定利润。
  c. 状态更新: 任何一只股票的卖出订单一旦被确认成交，系统必须立即执行一系列状态更新操作：在持仓数据库中将该股票的状态从“持仓中”更新为“已平仓”；详细记录交易日志，包括卖出原因（止损或止盈）、确切的卖出时间和价格、以及这笔交易的最终盈亏；最后，将这只已平仓的股票从当前的实时监控列表中移除，以减少后续轮询的API请求负担和计算量。
3.5.1 核心函数：动态止盈与自适应止损
● 动态止盈价 g(y): 我们的止盈目标不是一个僵化的固定百分比，而是能够根据股票自身的波动特性进行动态调整的。
  ○ 止盈涨幅 (Profit Margin):
    ■ Profit_Margin = min( Base_Target + k_g1 * (ATR_14_buy / AEP), Max_Target )
  ○ 最终止盈价 (Take Profit Price):
    ■ Take_Profit_Price = AEP * (1 + Profit_Margin)
  ○ 变量定义:
    ■ AEP: 实际成交均价。这是所有后续风控计算的唯一、坚实的基石。
    ■ Base_Target: 基础止盈目标。这是一个固定的百分比，例如 0.05，代表了我们对任何一笔交易最低的盈利预期。
    ■ ATR_14_buy: 买入当日的14日ATR值。这个值反映了我们买入这只股票时，它近期的市场波动水平。
    ■ k_g1: ATR溢价乘数。这是一个可优化的参数，例如 1.5。其背后的逻辑是：波动性越大的股票，其价格的正常日内波动范围也越大，因此我们的止盈目标也应该设置得更宽，给予利润更多“奔跑”的空间，避免被正常的市场噪音提前洗出。
    ■ Max_Target: 最大止盈目标。这是一个固定的百分比上限，例如 0.20。它的作用是在市场出现极端连续上涨的“主升浪”行情时，强制锁定大部分利润，防止因人性的贪婪而错失最佳卖点，导致利润大幅回吐。
● 自适应止损价 h(z): 这是对传统固定ATR止损的重大改进，旨在解决其在震荡市中容易被反复触发的问题。我们引入了市场状态判断，让止损策略能够“智能化”地适应不同的市场环境。
  ○ 第一步：实时判断市场状态 (Regime Filter)
    ■ 在盘中监控持仓股时，系统会实时计算该股票当前的 ADX(14) 指标值。ADX是衡量趋势强弱的经典指标。
    ■ IF ADX(14) > 20: 我们判定当前市场处于趋势状态。在这种状态下，价格的波动可能是单向且持续的，我们应该采用更灵敏的止损来紧跟趋势，保护已有利润。
    ■ ELSE (ADX(14) <= 20): 我们判定当前市场处于震荡或无趋势状态。在这种状态下，价格容易在一定区间内反复拉锯，小幅的波动不代表趋势的改变。因此，我们应该采用更宽松的止损，以避免被无意义的市场噪音轻易“洗出局”。
  ○ 第二步：根据市场状态选择差异化的止损策略
    ■ 最终的止损价将是多重防线中的最高者（即最严格的那个）。
    ■ Stop_Loss_Price = max(z_final, z2, z3)
    ■ 其中，核心的波动率止损线 z_final 是根据市场状态动态选择的：
      ● z_final = z_1_trend  如果 ADX(14) > 20 (趋势状态)
      ● z_final = z_1_range  如果 ADX(14) <= 20 (震荡状态)
  ○ 各条止损线的具体定义:
    ■ z_1_trend: 趋势市波动止损线。采用一个相对较窄的ATR乘数，以便在趋势反转时能够快速反应。
      ● z_1_trend = AEP - k_h1 * ATR_14_buy
    ■ z_1_range: 震荡市波动止损线。采用一个明显更宽的ATR乘数，给予价格在震荡区间内更多的缓冲空间，容忍更大的正常回撤。
      ● z_1_range = AEP - k_h2 * ATR_14_buy
    ■ z2: 技术位止损线。取值为买入当日的20日移动平均线价格（不复权）。MA20通常被视作中期趋势的生命线，一旦价格跌破这个位置，往往意味着中期上升趋势可能已经遭到破坏。
    ■ z3: 最大容忍度止损线。这是我们风险控制的最后一道、也是最坚固的防线。无论市场状态如何，技术指标如何变化，任何一笔交易的最大亏损都绝不能超过这个预设的极限。
      ● z3 = AEP * (1 - Max_Loss_Percent)
  ○ 变量定义:
    ■ k_h1: 趋势市ATR止损乘数，一个可优化的参数，例如 2.0。
    ■ k_h2: 震荡市ATR止损乘数，一个可优化的参数，其值必须大于k_h1，例如 3.0。
    ■ Max_Loss_Percent: 最大回撤容忍度，一个绝对的亏损百分比上限，例如 0.08，即我们能接受的单笔最大亏损为8%。
3.6 回测与优化模块
● 职责: 在一个完全隔离的离线环境中，通过对历史数据进行高保真的模拟交易，系统性地评估策略的过往表现，并科学地提升其未来的盈利潜力。
● 核心原则:
  ○ 数据基准统一: 这是保证回测结果有意义的基石。所有用于计算技术指标（如MA, ADX）和因子的数据，必须是后复权价格，以保证价格序列的连续性。而所有用于模拟交易撮合的环节，例如开盘价的比较、盘中止盈止损的触发，都必须使用不复权价格，因为这才是真实市场中交易发生的价格。
  ○ 亏损优先原则: 在模拟每一天的交易时，系统会检查当日的最高价和最低价。如果某一天的K线范围同时向上触及了预设的止盈价，并且向下触及了预设的止损价，系统将一律按照触发止损价进行结算。这是对策略在最不利情况下的压力测试，能够有效避免高估策略的胜率和盈亏比。
  ○ 成本与滑点精确模拟:
    ■ 交易成本: 必须完整地、精确地计算每一笔模拟交易的成本。这包括买入佣金（费率通常为万分之2.5，但必须考虑最低5元的收费标准，这对小额交易影响巨大）、卖出佣金，以及卖出时征收的印花税（目前为千分之一）。
    ■ 买入滑点: 模拟的买入成交价不应理想化地设为开盘价，而应设为 min(Limit_Price, High_Price_of_the_day)。这模拟了我们的限价单在真实市场中可能无法立即成交，而是在当日稍晚的更高价格成交的情况。
    ■ 卖出滑点: 模拟的卖出成交价不应理想化地设为触发价，而应设为 触发价 * (1 - 0.001)。这模拟了市价单在卖出时，因为消耗了市场流动性而导致的微小不利成交差价，即冲击成本。
  ○ 模拟除权除息:
    ■ 在进入T日的模拟循环时，首先查询本地的股权事件表，获取在T日发生除权除息事件的股票列表。 
    ■ 严格按照3.3模块中定义的策略，对模拟环境中所有受影响的持仓和交易预案的相应价格（止盈止损、MIOP/MAOP）进行调整。 
    ■ 模拟对配股事件的特殊处理：从当日的交易预案中移除相关股票，并对持仓中的相关股票在开盘时以模拟开盘价执行强制卖出。 
3.6.1 参数优化策略：迭代式单参数优化
此方法旨在通过一种简单、直观、计算成本可控的方式，系统性地寻找一组能够提升策略表现的优良参数组合。它避免了在参数众多时，使用网格搜索等方法带来的“维度灾难”和巨大的时间开销。
● 执行流程:
  a. 数据准备与划分:
    ■ 训练集: 用于进行参数优化的历史数据区间。例如，我们可以使用 2024年1月1日至2024年12月31日 的全年数据。
    ■ 验证集: 用于检验优化后参数组合泛化能力的历史数据区间，这个区间必须与训练集完全独立。例如，我们可以使用 2023年1月1日至2023年12月31日 的全年数据。使用未来数据做训练，过去数据做验证，是一种更为严格、更能考验策略稳健性的时间序列交叉验证方法。
  b. 设定初始参数:
    ■ 为模型中所有可调节的参数（包括维度权重 w_trend, w_momentum, w_quality；因子权重 k1 到 k8；开盘价区间系数 k_drop, k_gap；止盈系数 k_g1；止损系数 k_h1, k_h2；以及最大亏损比例 Max_Loss_Percent 等）设定一组合理的初始值。这些初始值可以基于行业经验，或者可以借助大语言模型（如Gemini）的知识库，生成一个符合逻辑的起点。
  c. 迭代优化循环:
    ■ 选择一个参数: 从待优化的参数列表中，选择第一个参数，例如 k1。
    ■ 设定基准表现: 使用当前完整的一套参数，在训练集（2024年数据）上完整地运行一次回测，记录下我们最关心的关键绩效指标，例如夏普比率或卡玛比率（年化收益/最大回撤）。我们将这个值记录为基准表现 KPI_base。
    ■ 微调与测试:
      ● 正向尝试: 将 k1 的值增加一个预设的、微小的步长（例如，k1_new = k1 * 1.01），而其他所有参数保持不变。用这套新参数重新运行一次回测，得到新的绩效指标 KPI_positive。
      ● 负向尝试: 将 k1 的值减少一个微小的步长（例如，k1_new = k1 * 0.99），其他参数保持不变。再次运行回测，得到 KPI_negative。
    ■ 决策与更新:
      ● 如果 KPI_positive 大于 KPI_base，并且也大于 KPI_negative，那么我们就接受这个正向的改变，将 k1 的值更新为增加后的新值。然后，我们可以在这个新值的基础上，继续尝试增加，直到KPI不再提升为止，从而找到 k1 在当前参数组合下的一个“局部最优值”。
      ● 如果 KPI_negative 大于 KPI_base，并且也大于 KPI_positive，我们就接受这个负向的改变，更新 k1 的值，并继续尝试减少，直至找到局部最优点。
      ● 如果 KPI_base 是三者中最大的，那么说明在当前位置，k1 的初始值就是最好的，我们保持其值不变。
    ■ 遍历所有参数: 对列表中的下一个参数（例如 k2）重复上述“微调-测试-更新”的完整步骤。当列表中的所有参数都完成了这样一轮优化后，我们称之为完成了一次“大循环”。
  d. 收敛或终止: 我们可以重复进行多轮这样的大循环。当出现一整轮大循环下来，没有任何一个参数的值发生变化时，我们认为参数组合已经收敛。或者，我们也可以设定一个最大的循环次数（例如10次）作为终止条件。
  e. 最终验证: 将在训练集上优化得到的这套最终参数组合，应用到验证集（2023年数据）上，进行一次完全独立的回测。这是对策略未来表现的“模拟考”。如果其在验证集上的表现依然稳健，例如夏普比率、最大回撤等核心指标没有出现大幅度的劣化，那么我们就更有信心认为这组参数具备良好的泛化能力，可以考虑将其部署到实盘交易中。
● 局限性与未来展望:
  ○ 局限性: 这种迭代式单参数优化的主要缺点是它无法捕捉到参数之间的交互效应。例如，最优的止损系数 k_h1 的取值，可能本身就依赖于止盈系数 k_g1 的取值。因此，该方法容易陷入局部最优点，而不一定是全局最优解。
  ○ 未来展望: 当系统运行稳定，并且我们有更强的计算资源时，可以引入更先进的、能够处理多维参数空间的优化算法。例如网格搜索、随机搜索，乃至更高效的贝叶斯优化（可以借助 Optuna, Hyperopt 等专业的Python库来实现），以期找到更优的参数组合。
4. 核心：复权处理与价格体系
为确保从历史研究到实时交易的每一个环节都无缝衔接，避免因价格口径不一而导致的逻辑错误，本系统建立了一套清晰、无歧义的价格转换与使用流程，贯穿整个交易生命周期：
环节	核心动作	使用价格类型	目的与理由
1. 历史分析 (T-1)	计算所有技术指标和因子 (f(x))	后复权价 (hfq_close)	保证指标计算的数学连续性与经济意义的准确性，彻底消除股票除权除息事件对价格序列造成的伪信号和断层。
2. 生成预案 (T-1)	计算开盘价区间 (MIOP, MAOP)	不复权价 (Close)	MIOP和MAOP是为次日的真实开盘价设定的边界，因此必须使用与开盘价相同的口径，即不复权收盘价作为计算基准。
3. 开盘决策 (T)	比较 Open_T 与 MIOP/MAOP	不复权价 (Open)	直接与交易所发布的、所有市场参与者都能看到的真实集合竞价结果进行匹配，确保决策的现实有效性。
4. 下单执行 (T)	计算下单限价 Limit_Price	不复权价 (Open)	向券商交易系统发送的任何交易指令，其价格都必须是当前市场正在交易的、不复权的真实价格。
5. 风控设定 (T)	基于AEP计算TP和SL	不复权价 (AEP)	所有风险控制的目标，无论是止盈还是止损，都必须基于我们真实的、不复权的持仓成本价。这是计算真实盈亏的唯一基准。
6. 盘中监控 (T)	比较Current_Price与TP/SL	不复权价 (Real-time)	与交易所通过行情接口实时推送的、正在发生交易的最新成交价进行比对，以触发平仓指令。
5. 部署与执行计划
1. 阶段一: 系统基建与回测 (1-2个月)
  ○ 任务清单: 完成四个核心模块的Python代码开发与详尽的单元测试；搭建并初始化本地历史数据库，编写并验证数据获取和清洗脚本；严格按照3.5节定义的原则和流程，完成参数的初步优化和严格的样本外验证，确定第一版可用于实盘的参数组合。
2. 阶段二: 模拟盘前向测试 (1个月)
  ○ 任务清单: 将完整的自动化交易系统部署到一台稳定的服务器上（可以是本地主机）；本地记账，进行全流程的、纯记录的模拟交易。
  ○ 核心目的: 此阶段不以盈利为目的，而是对系统的工程稳定性和策略实战性进行最终检验。重点观察：开盘决策模块是否总能按时、准确地执行；API接口在盘中高频请求下是否稳定；真实环境下的网络延迟和交易滑点与回测的差距有多大；策略在当前真实的市场环境下的表现是否符合预期。
3. 阶段三: 小资金实盘 (持续)
  ○ 任务清单: 若模拟盘表现稳定且符合预期，投入初始的5万元真实资金进行实盘交易。
  ○ 核心工作: 严密监控实盘交易的每一个环节，将实盘的成交记录、滑点数据、盈亏情况与回测结果进行细致的对比分析，找出差异并进行归因。同时，定期（例如每季度或每半年）重新运行回测与优化模块，以评估当前参数是否仍然适应可能已经发生变化的市场风格，并决策是否需要对策略参数进行微调。
6. 风险管理与应急预案
● 技术风险:
  ○ 程序中断: 建立详细的分级日志系统（DEBUG, INFO, WARNING, ERROR），记录系统的每一个关键动作。为核心的盘中监控和下单模块增加断线重连和状态恢复机制。例如，程序因故重启后，能够自动从数据库加载当前的持仓和未完成的订单状态，而不是从零开始。
  ○ 下单失败: 所有与 easytrader 相关的交易操作，都必须被包裹在 try...except 异常处理块中。一旦下单失败，系统应记录下详细的失败原因，并立即通过邮件或微信推送等方式发出人工介入警报。
  ○ API接口风险: 准备备用的数据源或行情接口，以应对主接口失效的情况。对API的请求频率进行严格的控制和节流，避免因请求过于频繁而被服务商暂时封禁。
● 策略风险:
  ○ 过拟合风险: 这是所有量化策略的天敌。本方案通过多种手段来最大程度地缓解此风险：采用严格的训练集/验证集划分；在回测中精确模拟成本和滑点；采用悲观的亏损优先原则；以及使用相对稳健的参数优化方法而非暴力拟合。
  ○ 市场制度风险: 策略本身不依赖于特定的市场政策，但需要对交易规则的重大变化保持警惕，例如T+0制度的试点、涨跌停板幅度的调整、印花税的变动等。一旦发生，需要评估其对策略的影响并及时进行调整。
  ○ 黑天鹅事件: 对于无法预测的、极端的小概率事件，任何策略都可能失效。我们能做的，是通过硬性的仓位管理来构建抵御未知风险的最后、也是最坚固的防线。本策略规定，单只股票的仓位绝不超过总资金的20%（即最多同时持有5支股票），并且总仓位上限可设定为80%或90%，始终保留一部分现金。这部分现金不仅能降低整体风险暴露，更能在市场极端下跌、流动性枯竭时，提供宝贵的缓冲和潜在的低吸机会。
  ○ 流动性风险: 若买入的限价单在开盘后15分钟内仍未成交，系统应自动撤单，以避免资金被一个可能永远无法成交的订单无效占用。若在执行卖出指令时，股票不幸遭遇跌停而无法成交，程序应自动改为以跌停价持续挂单，直至成交或当日收盘，并同时发出高优先级警报，提示人工关注。
附录：数据库表结构
1. 基础数据层
1.1. 股票基础信息表 (tb_stock_info)
说明: 存储所有A股股票的基本信息，如代码、名称、上市日期等，作为其他数据表的关联基础。
字段名	字段类型	约束	中文备注
stock_code	VARCHAR(10)	主键, 非空	股票代码, 格式如 'sh.600000'
stock_name	VARCHAR(50)	非空	股票名称
listing_date	DATE	非空	上市日期, 用于剔除次新股
status	VARCHAR(20)	非空	股票状态。枚举: listing(上市), delisted(退市), suspended(停牌)
created_at	DATETIME	非空, 默认当前时间	记录创建时间
updated_at	DATETIME	非空, 默认当前时间	记录更新时间
1.2. 日线行情表 (tb_daily_quotes)
说明: 存储从数据源获取的最原始的日线行情数据，是所有计算的基石。
字段名	字段类型	约束	中文备注
stock_code	VARCHAR(10)	复合主键, 外键(stock_info)	股票代码
trade_date	DATE	复合主键, 非空	交易日期
open	DECIMAL(10, 2)	非空	不复权开盘价
high	DECIMAL(10, 2)	非空	不复权最高价
low	DECIMAL(10, 2)	非空	不复权最低价
close	DECIMAL(10, 2)	非空	不复权收盘价
volume	BIGINT	非空	成交量 (股)
turnover	DECIMAL(20, 2)	非空	成交额 (元)
adjust_factor	DECIMAL(20, 10)	非空	截至当日的后复权因子
hfq_close	计算列 (DECIMAL)	-	(要求1) 后复权收盘价，公式: close * adjust_factor

1.3. 股权事件表 (tb_corporate_actions)
说明: 存储所有影响股价非交易性变动的股权事件，是盘前校准模块和回测引擎的核心数据源。
例子
10送5：event_type='bonus', shares_before=10, shares_after=15
10转3：event_type='transfer', shares_before=10, shares_after=13
10配3，配股价8元：event_type='rights', shares_before=10, shares_after=13, rights_issue_price=8
1拆2：event_type='split', shares_before=1, shares_after=2 (理解为在1股基础上增加1股)
10并1：event_type='split', shares_before=10, shares_after=1 (理解为在10股基础上减少9股)
派1元：event_type='dividend', dividend_per_share=0.1
字段名	字段类型	约束	中文备注
event_id	BIGINT	主键, 自增	事件唯一ID
stock_code	VARCHAR(10)	非空	股票代码, 格式如 'sh.600000'
ex_dividend_date	DATE	非空, 索引	除权除息日 (策略判断的基准日期)
record_date	DATE	-	股权登记日
notice_date	DATE	-	公告日期
event_type	VARCHAR(20)	非空	事件类型。枚举: dividend(分红), bonus(送股), transfer(转股),rights(配股), split(拆股/并股)
dividend_per_share	DECIMAL(10, 4)	-	每股派息(税前, 元，分红专用)
shares_before	DECIMAL(10, 4)	-	基准股数 (如“10送5”，此值为10，送股/转股/拆股/并股专用)
shares_after	DECIMAL(10, 4)		变动股数 (如“10送5”，此值为15，送股/转股/拆股/并股专用)
rights_issue_price	DECIMAL(10, 2)	-	配股价格，配股专用
created_at	DATETIME	非空, 默认当前时间	记录创建时间

2. 因子与参数层 (支持可扩展)
2.1. 因子定义表 (tb_factor_definitions)
说明: (核心设计) 用于定义所有策略中使用的因子，实现因子的可插拔。新增因子只需在此表增加一条记录。
字段名	字段类型	约束	中文备注
factor_code	VARCHAR(50)	主键, 非空	因子唯一英文代码, 如 'MA20_SLOPE'
factor_name	VARCHAR(100)	非空	因子中文名称, 如 '20日均线斜率'
description	TEXT	-	详细描述因子的计算逻辑和业务含义
direction	VARCHAR(10)	非空	因子方向性。枚举: positive(正向, 值越大越好), negative(负向, 值越小越好)
is_active	BOOLEAN	非空, 默认 true	是否启用该因子
2.2. 每日因子值表 (tb_daily_factor_values)
说明: (核心设计) 存储每只股票在每个交易日计算出的所有因子原始值和标准化分值。
字段名	字段类型	约束	中文备注
stock_code	VARCHAR(10)	复合主键, 外键(stock_info)	股票代码
trade_date	DATE	复合主键, 非空	交易日期
factor_code	VARCHAR(50)	复合主键, 外键(factor_definitions)	因子代码
raw_value	DECIMAL(20, 10)	非空	因子计算出的原始值
norm_score	DECIMAL(10, 4)	-	经过norm()函数标准化后的分值 (-100到100)
2.3. 策略参数表 (tb_strategy_parameters)
说明: 存储所有策略中可优化的参数，如权重、系数等，方便回测与优化模块进行读取和修改。
字段名	字段类型	约束	中文备注
param_name	VARCHAR(50)	主键, 非空	参数唯一英文名, 如 'w_trend', 'k_h1'
param_value	DECIMAL(20, 10)	非空	参数的数值
group_name	VARCHAR(50)	-	参数所属分组, 如 'WEIGHTS', 'STOP_LOSS'
description	TEXT	-	参数的详细说明

3. 策略执行与交易层
3.1. 每日交易预案表 (tb_daily_trading_plan)
说明: 存储 T-1 日终选股模块生成的“次日观察池”及相关交易预案。
字段名	字段类型	约束	中文备注
plan_date	DATE	复合主键, 非空	预案执行日期 (T日)
stock_code	VARCHAR(10)	复合主键, 外键(stock_info)	候选股票代码
rank	INT	非空	综合得分排名 (1-10)
final_score	DECIMAL(10, 4)	非空	f(x)选股综合得分
miop	DECIMAL(10, 2)	非空	最低可接受开盘价 (Minimum Acceptable Open Price)
maop	DECIMAL(10, 2)	非空	最高可接受开盘价 (Maximum Acceptable Open Price)
status	VARCHAR(20)	非空, 默认 'pending'	预案状态。枚举: pending(待执行), executed(已执行买入), cancelled(当日未满足条件作废)
3.2. 持仓信息表 (tb_positions)
说明: 存储当前所有持仓的详细信息，是盘中监控模块的核心数据依据。
字段名	字段类型	约束	中文备注
position_id	BIGINT	主键, 自增	持仓唯一ID
stock_code	VARCHAR(10)	非空, 外键(stock_info)	股票代码
entry_datetime	DATETIME	非空	建仓成交时间
entry_price	DECIMAL(10, 2)	非空	实际成交均价 (AEP)
quantity	BIGINT	非空	持仓数量 (股)
current_stop_loss	DECIMAL(10, 2)	非空	当前止损价
current_take_profit	DECIMAL(10, 2)	非空	当前止盈价
status	VARCHAR(20)	非空, 默认 'open'	持仓状态。枚举: open(持仓中), closed(已平仓)
3.3. 交易记录表 (tb_trade_log)
说明: 记录每一次买入和卖出的详细信息，用于成本核算、业绩分析和问题排查。
字段名	字段类型	约束	中文备注
trade_id	BIGINT	主键, 自增	交易唯一ID
position_id	BIGINT	外键(positions)	关联的持仓ID (买入时生成, 卖出时引用)
stock_code	VARCHAR(10)	非空, 外键(stock_info)	股票代码
trade_datetime	DATETIME	非空	交易成交时间
trade_type	VARCHAR(10)	非空	交易类型。枚举: buy(买入), sell(卖出)
order_type	VARCHAR(10)	非空	订单类型。枚举: limit(限价), market(市价)
price	DECIMAL(10, 2)	非空	成交均价
quantity	BIGINT	非空	成交数量
commission	DECIMAL(10, 2)	非空	佣金
stamp_duty	DECIMAL(10, 2)	非空, 默认 0	印花税 (仅卖出时有)
reason	VARCHAR(50)	-	交易原因。枚举: entry(策略入场), take_profit(止盈), stop_loss(止损), manual(人工干预)
status	VARCHAR(20)	非空	订单状态。枚举: filled(已成交), failed(失败), cancelled(已撤销), pending(待执行)

4. 系统监控与日志层
4.1. 系统日志表 (tb_system_log)
说明: 记录系统运行过程中的关键信息、警告和错误，便于监控和调试。
字段名	字段类型	约束	中文备注
log_id	BIGINT	主键, 自增	日志唯一ID
log_time	DATETIME	非空, 默认当前时间	日志记录时间
log_level	VARCHAR(10)	非空	日志级别。枚举: INFO, WARNING, ERROR, CRITICAL
module_name	VARCHAR(50)	-	产生日志的模块名, 如 '日终选股', '开盘决策'
message	TEXT	非空	日志内容, 如 '无合适买点', '下单API请求失败'


这是我现在的全量代码仓库：
======= 项目文件树 =======

📂 ./
    📄 mainDB.sqlite3
    📄 manage.py
    📄 requirements.txt
    📄 trade_report.html
    📄 回测简单日志.txt
    📄 提取日志.py
    📄 资金变化图.png
    📂 autoTrade/
        📄 __init__.py
        📄 asgi.py
        📄 settings.py
        📄 urls.py
        📄 wsgi.py
    📂 common/
        📄 __init__.py
        📄 admin.py
        📄 apps.py
        📄 tests.py
        📄 views.py
        📂 models/
            📄 __init__.py
            📄 corporate_action.py
            📄 daily_factor_values.py
            📄 daily_quotes.py
            📄 daily_trading_plan.py
            📄 factor_definitions.py
            📄 positions.py
            📄 stock_info.py
            📄 strategy_parameters.py
            📄 system_log.py
            📄 trade_log.py
    📂 data_manager/
        📄 __init__.py
        📄 admin.py
        📄 apps.py
        📄 models.py
        📄 tests.py
        📄 urls.py
        📄 views.py
        📂 management/
            📂 commands/
                📄 full_update_stocks.py
        📂 service/
            📄 corporate_action_service.py
            📄 stock_service.py
    📂 logs/
        📄 django.log
    📂 selection_manager/
        📄 __init__.py
        📄 admin.py
        📄 apps.py
        📄 models.py
        📄 tests.py
        📄 urls.py
        📄 views.py
        📂 service/
            📄 selection_service.py
    📂 trade_manager/
        📄 __init__.py
        📄 admin.py
        📄 apps.py
        📄 models.py
        📄 tests.py
        📄 urls.py
        📄 views.py
        📂 service/
            📄 before_fix_service.py
            📄 decision_order_service.py
            📄 monitor_exit_service.py
            📄 simulate_trade.py
            📄 simulate_trade_handler.py
            📄 trade_handler.py

========================

======= Python文件内容 =======

####manage.py####
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'autoTrade.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()

####文件结束####

####提取日志.py####
import re
import html
import matplotlib.pyplot as plt
from collections import defaultdict
import os

# ==============================================================================
# 配置区域
# ==============================================================================
LOG_FILE_PATH = '回测简单日志.txt'
PLOT_OUTPUT_PATH = '资金变化图.png'
HTML_REPORT_PATH = '交易变化.html'


# ==============================================================================
# 1. 日志解析
# ==============================================================================
def parse_log_file(file_path):
    """
    解析日志文件，提取绘图和报告所需的数据。
    """
    # 用于存储每日资产
    asset_dates = []
    asset_values = []
    
    # 用于存储每日的日志块
    daily_logs = []
    
    # 用于计算每支股票的盈亏
    # 结构: {'sz.002364': {'spent': 1000, 'received': 1100, 'dividends': 10, 'name': '中恒电气'}}
    stock_profits = defaultdict(lambda: {'spent': 0, 'received': 0, 'dividends': 0, 'name': ''})

    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            current_day_block = None
            for line in f:
                line = line.strip()
                if not line:
                    continue

                # 匹配新的一天
                day_match = re.search(r"模拟日: ([\d-]+)", line)
                if day_match:
                    if current_day_block:
                        daily_logs.append(current_day_block)
                    date_str = day_match.group(1)
                    current_day_block = {'date': date_str, 'logs': [line]}
                    continue
                
                if not current_day_block:
                    continue

                current_day_block['logs'].append(line)

                # 匹配总资产
                asset_match = re.search(r"总资产: ([\d.]+)", line)
                if asset_match:
                    asset_dates.append(current_day_block['date'])
                    asset_values.append(float(asset_match.group(1)))

                # 匹配买入操作
                buy_match = re.search(r"买入 (.+?)\((.+?)\).*?花费: ([\d.]+)", line)
                if buy_match:
                    name, code, cost = buy_match.groups()
                    stock_profits[code]['spent'] += float(cost)
                    if not stock_profits[code]['name']: # 首次记录股票名称
                        stock_profits[code]['name'] = name

                # 匹配卖出操作
                sell_match = re.search(r"卖出 (.+?) .*?收入: ([\d.]+)", line)
                if sell_match:
                    code, income = sell_match.groups()
                    stock_profits[code]['received'] += float(income)

                # 匹配分红事件
                dividend_match = re.search(r"持仓ID \d+ \((.+?)\) 获得分红 ([\d.]+)", line)
                if dividend_match:
                    code, dividend = dividend_match.groups()
                    stock_profits[code]['dividends'] += float(dividend)


            if current_day_block: # 添加最后一天的数据
                daily_logs.append(current_day_block)

    except FileNotFoundError:
        print(f"错误: 日志文件 '{file_path}' 未找到。")
        return None, None, None, None
    
    return asset_dates, asset_values, daily_logs, stock_profits

# ==============================================================================
# 2. 生成资金曲线图
# ==============================================================================
def generate_asset_plot(dates, assets, output_path):
    """
    使用matplotlib生成资金曲线图并保存。
    """
    if not dates or not assets:
        print("没有足够的资产数据来生成图表。")
        return

    print("正在生成资金变化图...")
    
    # 设置中文字体，以防乱码
    plt.rcParams['font.sans-serif'] = ['SimHei', 'Microsoft YaHei']
    plt.rcParams['axes.unicode_minus'] = False

    # 创建一个较大尺寸的图形
    fig, ax = plt.subplots(figsize=(18, 9))

    ax.plot(dates, assets, marker='.', linestyle='-', color='b')

    # 设置图表标题和标签
    ax.set_title('策略回测资金曲线', fontsize=20)
    ax.set_xlabel('模拟日期', fontsize=14)
    ax.set_ylabel('总资产 (元)', fontsize=14)
    ax.grid(True, linestyle='--', alpha=0.6)

    # 自动调整x轴标签以避免重叠
    fig.autofmt_xdate(rotation=45)
    
    # 格式化y轴为货币格式
    ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: format(int(x), ',')))

    # 确保布局紧凑，所有元素都可见
    plt.tight_layout()

    # 保存图表
    plt.savefig(output_path, dpi=150)
    plt.close()
    print(f"资金变化图已成功保存到: {output_path}")

# ==============================================================================
# 3. 生成HTML报告
# ==============================================================================
def generate_html_report(daily_logs, stock_profits, output_path):
    """
    生成包含高亮日志和盈亏汇总的HTML报告。
    """
    if not daily_logs or not stock_profits:
        print("没有足够的数据来生成HTML报告。")
        return
        
    print("正在生成HTML报告...")

    # --- 计算并排序股票盈亏 ---
    profit_summary = []
    for code, data in stock_profits.items():
        total_profit = data['received'] + data['dividends'] - data['spent']
        profit_summary.append({
            'code': code,
            'name': data['name'] or '未知名称',
            'profit': total_profit
        })
    
    # 从大到小排序
    sorted_profits = sorted(profit_summary, key=lambda x: x['profit'], reverse=True)

    # --- 构建HTML内容 ---
    html_content = """
    <!DOCTYPE html>
    <html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
        <title>回测交易日志报告</title>
        <style>
            body { font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif; line-height: 1.6; margin: 20px; background-color: #f4f4f4; color: #333; }
            h1, h2 { color: #0056b3; border-bottom: 2px solid #0056b3; padding-bottom: 10px; }
            .container { max-width: 1200px; margin: auto; background: #fff; padding: 20px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
            .summary-table { width: 100%; border-collapse: collapse; margin-bottom: 30px; }
            .summary-table th, .summary-table td { border: 1px solid #ddd; padding: 12px; text-align: left; }
            .summary-table th { background-color: #007bff; color: white; }
            .summary-table tr:nth-child(even) { background-color: #f2f2f2; }
            .profit { color: #d9534f; } /* 红色 */
            .loss { color: #5cb85c; } /* 绿色 */
            .day-block { border: 1px solid #ccc; border-radius: 5px; margin-bottom: 20px; padding: 15px; background-color: #fafafa; }
            .day-block h3 { margin-top: 0; color: #555; }
            .log-entry { font-family: 'Courier New', Courier, monospace; white-space: pre-wrap; word-wrap: break-word; }
            .log-profit-sell { color: #d9534f; font-weight: bold; } /* 止盈卖出 - 红色 */
            .log-stop-loss { color: #5cb85c; font-weight: bold; } /* 止损卖出 - 绿色 */
        </style>
    </head>
    <body>
        <div class="container">
            <h1>回测交易日志报告</h1>
            
            <h2>各股盈亏汇总 (从高到低)</h2>
            <table class="summary-table">
                <thead>
                    <tr>
                        <th>排名</th>
                        <th>股票名称</th>
                        <th>股票代码</th>
                        <th>总盈亏 (元)</th>
                    </tr>
                </thead>
                <tbody>
    """

    # 填充盈亏汇总表格
    for i, item in enumerate(sorted_profits):
        profit_class = 'profit' if item['profit'] >= 0 else 'loss'
        html_content += f"""
                    <tr>
                        <td>{i + 1}</td>
                        <td>{html.escape(item['name'])}</td>
                        <td>{html.escape(item['code'])}</td>
                        <td class="{profit_class}">{item['profit']:.2f}</td>
                    </tr>
        """
    
    html_content += """
                </tbody>
            </table>

            <h2>详细日志记录</h2>
    """

    # 填充详细日志
    for day in daily_logs:
        html_content += f"""
            <div class="day-block">
                <h3>{html.escape(day['date'])}</h3>
                <div class="log-entry">
        """
        for log_line in day['logs']:
            escaped_line = html.escape(log_line)
            if '触发止盈' in log_line or '止盈卖出' in log_line:
                html_content += f'<span class="log-profit-sell">{escaped_line}</span>\n'
            elif '触发止损' in log_line or '止损卖出' in log_line:
                html_content += f'<span class="log-stop-loss">{escaped_line}</span>\n'
            else:
                html_content += f'{escaped_line}\n'
        html_content += """
                </div>
            </div>
        """

    html_content += """
        </div>
    </body>
    </html>
    """

    # 写入文件
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(html_content)
    print(f"HTML报告已成功保存到: {output_path}")

# ==============================================================================
# 主执行函数
# ==============================================================================
def main():
    """主函数，协调所有操作。"""
    print("开始处理回测日志...")
    symbol=['==================== 模拟日','触发','[回测] 卖出',' [回测] 买入','总资产: ','获得分红','风控价格']
    f=open('logs/django.log',"r",encoding="gbk")
    result=""
    for line in f.readlines():
        suc=False
        for each in symbol:
            if each in line:
                suc=True
                break
        if suc:
            result=result+line
    f.close()
    f=open(LOG_FILE_PATH,'w',encoding='utf-8')
    f.write(result)
    f.close()

    # 1. 解析日志
    asset_dates, asset_values, daily_logs, stock_profits = parse_log_file(LOG_FILE_PATH)

    if asset_dates is None: # 如果解析失败
        print("日志处理终止。")
        return

    # 2. 生成图表
    generate_asset_plot(asset_dates, asset_values, PLOT_OUTPUT_PATH)

    # 3. 生成HTML报告
    generate_html_report(daily_logs, stock_profits, HTML_REPORT_PATH)
    
    print("\n所有任务完成！")
    print(f" - 图表文件: {os.path.abspath(PLOT_OUTPUT_PATH)}")
    print(f" - 报告文件: {os.path.abspath(HTML_REPORT_PATH)}")


if __name__ == '__main__':
    main()
main()
####文件结束####

####遍历文件.py####
import os

# --- 配置 ---
# 要扫描的根目录，'.' 表示当前目录
ROOT_DIR = '.'
# 输出文件名
OUTPUT_FILE = 'result.txt'
# 要忽略的目录（使用集合以提高查找效率）
IGNORE_DIRS = {'.git', '__pycache__', 'venv', '.vscode', 'node_modules','migrations'}
# 要忽略的文件
IGNORE_FILES = {'.DS_Store', OUTPUT_FILE,'遍历文件.py'} # 确保不把输出文件本身包含进去

def generate_file_tree(root_dir, ignore_dirs, ignore_files):
    """生成项目文件树结构"""
    tree_lines = []
    for root, dirs, files in os.walk(root_dir, topdown=True):
        # 在遍历前，从dirs列表中移除要忽略的目录
        dirs[:] = [d for d in dirs if d not in ignore_dirs]
        
        # 计算当前深度，用于生成前缀
        level = root.replace(root_dir, '').count(os.sep)
        indent = ' ' * 4 * level
        
        # 添加目录名到树
        # os.path.basename(root) 用于获取当前目录名
        tree_lines.append(f"{indent}📂 {os.path.basename(root)}/")

        # 添加文件到树
        sub_indent = ' ' * 4 * (level + 1)
        for f in sorted(files): # 对文件进行排序
            if f not in ignore_files:
                tree_lines.append(f"{sub_indent}📄 {f}")
                
    return "\n".join(tree_lines)

def get_python_file_contents(root_dir, ignore_dirs):
    """获取所有.py文件的内容并格式化"""
    py_contents = []
    for root, dirs, files in os.walk(root_dir, topdown=True):
        # 同样，忽略指定目录
        dirs[:] = [d for d in dirs if d not in ignore_dirs]
        
        for file in sorted(files):
            if file.endswith('.py'):
                file_path = os.path.join(root, file)
                # 使用相对路径，让输出更清晰
                relative_path = os.path.relpath(file_path, root_dir)
                
                header = f"####{relative_path}####"
                footer = "####文件结束####"
                
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                    py_contents.append(f"{header}\n{content}\n{footer}\n")
                except Exception as e:
                    py_contents.append(f"{header}\n无法读取文件内容: {e}\n{footer}\n")
                    
    return "\n".join(py_contents)

def main():
    """主函数，执行所有操作"""
    print("开始生成项目文件树...")
    file_tree = generate_file_tree(ROOT_DIR, IGNORE_DIRS, IGNORE_FILES)
    
    print("开始读取所有.py文件内容...")
    python_contents = get_python_file_contents(ROOT_DIR, IGNORE_DIRS)
    
    print(f"正在将结果写入 {OUTPUT_FILE}...")
    
    # 将所有内容合并写入文件
    with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
        f.write("======= 项目文件树 =======\n\n")
        f.write(file_tree)
        f.write("\n\n========================\n\n")
        f.write("======= Python文件内容 =======\n\n")
        f.write(python_contents)
        
    print(f"✅ 成功！项目结构和代码已保存到 {OUTPUT_FILE}")

if __name__ == '__main__':
    main()

####文件结束####

####autoTrade\__init__.py####

####文件结束####

####autoTrade\asgi.py####
"""
ASGI config for autoTrade project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'autoTrade.settings')

application = get_asgi_application()

####文件结束####

####autoTrade\settings.py####
"""
Django settings for autoTrade project.

Generated by 'django-admin startproject' using Django 5.2.4.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""

from pathlib import Path
import os
# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-30$wdh0=83tt^5@ed_1y@magp52^70&j)n_14nlwms-hpanwp+'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'data_manager',
    'selection_manager',
    'trade_manager',
    'common'
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    #'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'autoTrade.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'autoTrade.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'mainDB.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'


LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,  # 不要禁用已存在的日志器，否则 Django 自带的日志会失效
    
    # 1. 定义日志格式
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
        'simple': {
            'format': '{levelname} {message}',
            'style': '{',
        },
    },
    
    # 2. 定义处理器 (日志去哪里)
    'handlers': {
        # 输出到控制台
        'console': {
            'level': 'DEBUG',  # 处理 DEBUG 及以上级别的日志
            'class': 'logging.StreamHandler',
            'formatter': 'verbose', # 使用 verbose 格式
        },
        # 输出到文件
        'file': {
            'level': 'INFO',  # 处理 INFO 及以上级别的日志
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': os.path.join(BASE_DIR, 'logs/django.log'), # 日志文件路径
            'maxBytes': 1024 * 1024 * 5,  # 5 MB
            'backupCount': 5, # 最多保留 5 个备份文件
            'formatter': 'verbose', # 使用 verbose 格式
        },
    },
    
    # 3. 定义记录器 (哪些日志需要处理)
    'loggers': {
        # Django 框架自身的日志
        'django': {
            'handlers': ['console', 'file'],
            'level': 'INFO',
            'propagate': True,
        },
        # 你自己应用的日志
        'data_manager': { # 这里使用你的 app 名称
            'handlers': ['console','file'],
            'level': 'DEBUG', # 在开发时设为 DEBUG，可以看到所有信息
            'propagate': False, # 不向上传递给 root logger
        },
        'selection_manager': { # 这里使用你的 app 名称
            'handlers': ['console','file'],
            'level': 'DEBUG', # 在开发时设为 DEBUG，可以看到所有信息
            'propagate': False, # 不向上传递给 root logger
        },
        'trade_manager': { # 这里使用你的 app 名称
            'handlers': ['console','file'],
            'level': 'DEBUG', # 在开发时设为 DEBUG，可以看到所有信息
            'propagate': False, # 不向上传递给 root logger
        },
        # 你可以为任何模块定义 logger
        'common': {
            'handlers': ['console', 'file'],
            'level': 'DEBUG',
            'propagate': False,
        }
    }
}
 
# 确保 logs 目录存在
LOGS_DIR = os.path.join(BASE_DIR, 'logs')
if not os.path.exists(LOGS_DIR):
    os.makedirs(LOGS_DIR)
####文件结束####

####autoTrade\urls.py####
"""
URL configuration for autoTrade project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path,include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('dataManager/', include('data_manager.urls')),
    path('selectionManager/', include('selection_manager.urls')),
    path('tradeManager/', include('trade_manager.urls'))
]

####文件结束####

####autoTrade\wsgi.py####
"""
WSGI config for autoTrade project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'autoTrade.settings')

application = get_wsgi_application()

####文件结束####

####common\__init__.py####

####文件结束####

####common\admin.py####
from django.contrib import admin

# Register your models here.

####文件结束####

####common\apps.py####
from django.apps import AppConfig


class CommonConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'common'

####文件结束####

####common\tests.py####
from django.test import TestCase

# Create your tests here.

####文件结束####

####common\views.py####
from django.shortcuts import render

# Create your views here.

####文件结束####

####common\models\__init__.py####
# my_strategy_app/__init__.py

from .stock_info import StockInfo
from .daily_quotes import DailyQuotes
from .factor_definitions import FactorDefinitions
from .daily_factor_values import DailyFactorValues
from .strategy_parameters import StrategyParameters
from .daily_trading_plan import DailyTradingPlan
from .positions import Position
from .trade_log import TradeLog
from .system_log import SystemLog
from .corporate_action import CorporateAction

__all__ = [
    'StockInfo',
    'DailyQuotes',
    'FactorDefinitions',
    'DailyFactorValues',
    'StrategyParameters',
    'DailyTradingPlan',
    'Position',
    'TradeLog',
    'SystemLog',
    'CorporateAction'
]

####文件结束####

####common\models\corporate_action.py####
from django.db import models

class CorporateAction(models.Model):
    """
    股权事件表 (tb_corporate_actions)
    
    说明: 存储所有影响股价非交易性变动的股权事件，是盘前校准模块和回测引擎的核心数据源。
    
    例子:
    10送5：event_type='bonus', shares_before=10, shares_after=15
    10转3：event_type='transfer', shares_before=10, shares_after=13
    10配3，配股价8元：event_type='rights', shares_before=10, shares_after=13, rights_issue_price=8
    1拆2：event_type='split', shares_before=1, shares_after=2 (理解为在1股基础上增加1股)
    10并1：event_type='split', shares_before=10, shares_after=1 (理解为在10股基础上减少9股)
    派1元：event_type='dividend', dividend_per_share=0.1
    """

    # 使用 Django 推荐的 TextChoices 来定义事件类型的枚举
    class EventType(models.TextChoices):
        DIVIDEND = 'dividend', '分红'
        BONUS = 'bonus', '送股'
        TRANSFER = 'transfer', '转股'
        RIGHTS = 'rights', '配股'
        SPLIT = 'split', '拆股/并股'

    # 字段定义
    event_id = models.BigAutoField(
        primary_key=True,
        help_text="事件唯一ID"
    )
    stock_code = models.CharField(
        max_length=10,
        null=False,
        blank=False,
        help_text="股票代码, 格式如 'sh.600000'"
    )
    ex_dividend_date = models.DateField(
        null=False,
        db_index=True,
        help_text="除权除息日 (策略判断的基准日期)，对于配股来说，实际为股权登记日而非除权日"
    )
    record_date = models.DateField(
        null=True,
        blank=True,
        help_text="股权登记日"
    )
    notice_date = models.DateField(
        null=True,
        blank=True,
        help_text="公告日期"
    )
    event_type = models.CharField(
        max_length=20,
        choices=EventType.choices,
        null=False,
        blank=False,
        help_text="事件类型。枚举: dividend(分红), bonus(送股), transfer(转股),rights(配股), split(拆股/并股)"
    )
    dividend_per_share = models.DecimalField(
        max_digits=10,
        decimal_places=4,
        null=True,
        blank=True,
        help_text="每股派息(税前, 元，分红专用)"
    )
    shares_before = models.DecimalField(
        max_digits=10,
        decimal_places=4,
        null=True,
        blank=True,
        help_text="基准股数 (如“10送5”，此值为10，送股/转股/拆股/并股专用)"
    )
    shares_after = models.DecimalField(
        max_digits=10,
        decimal_places=4,
        null=True,
        blank=True,
        help_text="变动股数 (如“10送5”，此值为15，送股/转股/拆股/并股专用)"
    )
    rights_issue_price = models.DecimalField(
        max_digits=10,
        decimal_places=2,
        null=True,
        blank=True,
        help_text="配股价格，配股专用"
    )
    created_at = models.DateTimeField(
        auto_now_add=True,
        null=False,
        help_text="记录创建时间"
    )

    class Meta:
        # 显式指定数据库中的表名
        db_table = 'tb_corporate_actions'
        # 在 Django Admin 中显示的名称
        verbose_name = '股权事件'
        verbose_name_plural = '股权事件'
        # 默认排序规则
        ordering = ['-ex_dividend_date', 'stock_code']

    def __str__(self):
        # 提供一个易于阅读的对象表示形式
        return f"{self.stock_code} on {self.ex_dividend_date}: {self.get_event_type_display()}"


####文件结束####

####common\models\daily_factor_values.py####
from django.db import models
from .stock_info import StockInfo
from .factor_definitions import FactorDefinitions

class DailyFactorValues(models.Model):
    """
    2.2. 每日因子值表 (tb_daily_factor_values)
    说明: (核心设计) 存储每只股票在每个交易日计算出的所有因子原始值和标准化分值。
    """
    stock_code = models.ForeignKey(
        StockInfo, 
        on_delete=models.CASCADE, 
        db_column='stock_code',
        help_text="股票代码"
    )
    trade_date = models.DateField(
        help_text="交易日期"
    )
    factor_code = models.ForeignKey(
        FactorDefinitions, 
        on_delete=models.CASCADE, 
        db_column='factor_code',
        help_text="因子代码"
    )
    raw_value = models.DecimalField(
        max_digits=20, 
        decimal_places=10, 
        help_text="因子计算出的原始值"
    )
    norm_score = models.DecimalField(
        max_digits=10, 
        decimal_places=4, 
        null=True, 
        blank=True,
        help_text="经过norm()函数标准化后的分值 (-100到100)"
    )

    def __str__(self):
        return f"{self.stock_code} - {self.factor_code} on {self.trade_date}"

    class Meta:
        db_table = 'tb_daily_factor_values'
        # 使用 unique_together 实现复合主键的唯一性约束
        unique_together = (('stock_code', 'trade_date', 'factor_code'),)
        verbose_name = '每日因子值'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\daily_quotes.py####
from django.db import models
from .stock_info import StockInfo

class DailyQuotes(models.Model):
    """
    1.2. 日线行情表 (tb_daily_quotes)
    说明: 存储从数据源获取的最原始的日线行情数据，是所有计算的基石。
    """
    stock_code = models.ForeignKey(
        StockInfo, 
        on_delete=models.CASCADE, 
        db_column='stock_code',
        help_text="股票代码"
    )
    trade_date = models.DateField(
        help_text="交易日期"
    )
    open = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="不复权开盘价"
    )
    high = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="不复权最高价"
    )
    low = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="不复权最低价"
    )
    close = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="不复权收盘价"
    )
    volume = models.BigIntegerField(
        help_text="成交量 (股)"
    )
    turnover = models.DecimalField(
        max_digits=20, 
        decimal_places=2, 
        help_text="成交额 (元)"
    )
    adjust_factor = models.DecimalField(
        max_digits=20, 
        decimal_places=10, 
        help_text="截至当日的后复权因子"
    )
    # (要求1) 计算列 hfq_close
    hfq_close = models.DecimalField(
        max_digits=20, 
        decimal_places=10, 
        editable=False,
        help_text="后复权收盘价，公式: close * adjust_factor"
    )

    def save(self, *args, **kwargs):
        # 在保存模型前计算 hfq_close 的值
        self.hfq_close = self.close * self.adjust_factor
        super().save(*args, **kwargs)

    def __str__(self):
        return f"{self.stock_code} on {self.trade_date}"

    class Meta:
        db_table = 'tb_daily_quotes'
        # 使用 unique_together 实现复合主键的唯一性约束
        unique_together = (('stock_code', 'trade_date'),)
        verbose_name = '日线行情'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\daily_trading_plan.py####
from django.db import models
from .stock_info import StockInfo

class DailyTradingPlan(models.Model):
    """
    3.1. 每日交易预案表 (tb_daily_trading_plan)
    说明: 存储 T-1 日终选股模块生成的“次日观察池”及相关交易预案。
    """
    class StatusChoices(models.TextChoices):
        PENDING = 'pending', '待执行'
        EXECUTED = 'executed', '已执行买入'
        CANCELLED = 'cancelled', '当日未满足条件作废'

    plan_date = models.DateField(
        help_text="预案执行日期 (T日)"
    )
    stock_code = models.ForeignKey(
        StockInfo, 
        on_delete=models.CASCADE, 
        db_column='stock_code',
        help_text="候选股票代码"
    )
    rank = models.IntegerField(
        help_text="综合得分排名 (1-10)"
    )
    final_score = models.DecimalField(
        max_digits=10, 
        decimal_places=4, 
        help_text="f(x)选股综合得分"
    )
    miop = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="最低可接受开盘价 (Minimum Acceptable Open Price)"
    )
    maop = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="最高可接受开盘价 (Maximum Acceptable Open Price)"
    )
    status = models.CharField(
        max_length=20, 
        choices=StatusChoices.choices, 
        default=StatusChoices.PENDING,
        help_text="预案状态。枚举: pending(待执行), executed(已执行买入), cancelled(当日未满足条件作废)"
    )

    def __str__(self):
        return f"Plan for {self.stock_code} on {self.plan_date} (Rank: {self.rank})"

    class Meta:
        db_table = 'tb_daily_trading_plan'
        # 使用 unique_together 实现复合主键的唯一性约束
        unique_together = (('plan_date', 'stock_code'),)
        verbose_name = '每日交易预案'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\factor_definitions.py####
from django.db import models

class FactorDefinitions(models.Model):
    """
    2.1. 因子定义表 (tb_factor_definitions)
    说明: (核心设计) 用于定义所有策略中使用的因子，实现因子的可插拔。新增因子只需在此表增加一条记录。
    """
    class DirectionChoices(models.TextChoices):
        POSITIVE = 'positive', '正向, 值越大越好'
        NEGATIVE = 'negative', '负向, 值越小越好'

    factor_code = models.CharField(
        max_length=50, 
        primary_key=True, 
        help_text="因子唯一英文代码, 如 'MA20_SLOPE'"
    )
    factor_name = models.CharField(
        max_length=100, 
        help_text="因子中文名称, 如 '20日均线斜率'"
    )
    description = models.TextField(
        blank=True, 
        null=True, 
        help_text="详细描述因子的计算逻辑和业务含义"
    )
    direction = models.CharField(
        max_length=10, 
        choices=DirectionChoices.choices,
        help_text="因子方向性。枚举: positive(正向, 值越大越好), negative(负向, 值越小越好)"
    )
    is_active = models.BooleanField(
        default=True, 
        help_text="是否启用该因子"
    )

    def __str__(self):
        return f"{self.factor_name} ({self.factor_code})"

    class Meta:
        db_table = 'tb_factor_definitions'
        verbose_name = '因子定义'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\positions.py####
from django.db import models
from .stock_info import StockInfo

class Position(models.Model):
    """
    3.2. 持仓信息表 (tb_positions)
    说明: 存储当前所有持仓的详细信息，是盘中监控模块的核心数据依据。
    """
    class StatusChoices(models.TextChoices):
        OPEN = 'open', '持仓中'
        CLOSED = 'closed', '已平仓'

    position_id = models.BigAutoField(
        primary_key=True, 
        help_text="持仓唯一ID"
    )
    stock_code = models.ForeignKey(
        StockInfo, 
        on_delete=models.PROTECT, # 保护，防止意外删除关联股票信息
        db_column='stock_code',
        help_text="股票代码"
    )
    entry_datetime = models.DateTimeField(
        help_text="建仓成交时间"
    )
    entry_price = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="实际成交均价 (AEP)"
    )
    quantity = models.BigIntegerField(
        help_text="持仓数量 (股)"
    )
    current_stop_loss = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="当前止损价"
    )
    current_take_profit = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="当前止盈价"
    )
    status = models.CharField(
        max_length=20, 
        choices=StatusChoices.choices, 
        default=StatusChoices.OPEN,
        help_text="持仓状态。枚举: open(持仓中), closed(已平仓)"
    )

    def __str__(self):
        return f"Position {self.position_id}: {self.quantity} of {self.stock_code}"

    class Meta:
        db_table = 'tb_positions'
        verbose_name = '持仓信息'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\stock_info.py####
from django.db import models
from django.utils import timezone

class StockInfo(models.Model):
    """
    1.1. 股票基础信息表 (tb_stock_info)
    说明: 存储所有A股股票的基本信息，如代码、名称、上市日期等，作为其他数据表的关联基础。
    """
    class StatusChoices(models.TextChoices):
        LISTING = 'listing', '上市'
        DELISTED = 'delisted', '退市'
        SUSPENDED = 'suspended', '停牌'

    stock_code = models.CharField(
        max_length=10, 
        primary_key=True, 
        help_text="股票代码, 格式如 'sh.600000'"
    )
    stock_name = models.CharField(
        max_length=50, 
        help_text="股票名称"
    )
    listing_date = models.DateField(
        help_text="上市日期, 用于剔除次新股"
    )
    status = models.CharField(
        max_length=20, 
        choices=StatusChoices.choices,
        help_text="股票状态。枚举: listing(上市), delisted(退市), suspended(停牌)"
    )
    created_at = models.DateTimeField(
        default=timezone.now, 
        editable=False,
        help_text="记录创建时间"
    )
    updated_at = models.DateTimeField(
        auto_now=True,
        help_text="记录更新时间"
    )

    def __str__(self):
        return f"{self.stock_name}({self.stock_code})"

    class Meta:
        db_table = 'tb_stock_info'
        verbose_name = '股票基础信息'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\strategy_parameters.py####
from django.db import models

class StrategyParameters(models.Model):
    """
    2.3. 策略参数表 (tb_strategy_parameters)
    说明: 存储所有策略中可优化的参数，如权重、系数等，方便回测与优化模块进行读取和修改。
    """
    param_name = models.CharField(
        max_length=50, 
        primary_key=True, 
        help_text="参数唯一英文名, 如 'w_trend', 'k_h1'"
    )
    param_value = models.DecimalField(
        max_digits=20, 
        decimal_places=10, 
        help_text="参数的数值"
    )
    group_name = models.CharField(
        max_length=50, 
        blank=True, 
        null=True, 
        help_text="参数所属分组, 如 'WEIGHTS', 'STOP_LOSS'"
    )
    description = models.TextField(
        blank=True, 
        null=True, 
        help_text="参数的详细说明"
    )

    def __str__(self):
        return f"{self.param_name} = {self.param_value}"

    class Meta:
        db_table = 'tb_strategy_parameters'
        verbose_name = '策略参数'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\system_log.py####
from django.db import models
from django.utils import timezone

class SystemLog(models.Model):
    """
    4.1. 系统日志表 (tb_system_log)
    说明: 记录系统运行过程中的关键信息、警告和错误，便于监控和调试。
    """
    class LogLevelChoices(models.TextChoices):
        INFO = 'INFO', 'INFO'
        WARNING = 'WARNING', 'WARNING'
        ERROR = 'ERROR', 'ERROR'
        CRITICAL = 'CRITICAL', 'CRITICAL'

    log_id = models.BigAutoField(
        primary_key=True, 
        help_text="日志唯一ID"
    )
    log_time = models.DateTimeField(
        default=timezone.now, 
        editable=False,
        help_text="日志记录时间"
    )
    log_level = models.CharField(
        max_length=10, 
        choices=LogLevelChoices.choices,
        help_text="日志级别。枚举: INFO, WARNING, ERROR, CRITICAL"
    )
    module_name = models.CharField(
        max_length=50, 
        blank=True, 
        null=True,
        help_text="产生日志的模块名, 如 '日终选股', '开盘决策'"
    )
    message = models.TextField(
        help_text="日志内容, 如 '无合适买点', '下单API请求失败'"
    )

    def __str__(self):
        return f"[{self.log_time.strftime('%Y-%m-%d %H:%M:%S')}] [{self.log_level}] {self.message[:80]}"

    class Meta:
        db_table = 'tb_system_log'
        verbose_name = '系统日志'
        verbose_name_plural = verbose_name

####文件结束####

####common\models\trade_log.py####
from django.db import models
from .stock_info import StockInfo

class TradeLog(models.Model):
    """
    3.3. 交易记录表 (tb_trade_log)
    说明: 记录每一次买入和卖出的详细信息，用于成本核算、业绩分析和问题排查。
    """
    class TradeTypeChoices(models.TextChoices):
        BUY = 'buy', '买入'
        SELL = 'sell', '卖出'

    class OrderTypeChoices(models.TextChoices):
        LIMIT = 'limit', '限价'
        MARKET = 'market', '市价'

    class ReasonChoices(models.TextChoices):
        ENTRY = 'entry', '策略入场'
        TAKE_PROFIT = 'take_profit', '止盈'
        STOP_LOSS = 'stop_loss', '止损'
        MANUAL = 'manual', '人工干预'

    class StatusChoices(models.TextChoices):
        FILLED = 'filled', '已成交'
        FAILED = 'failed', '失败'
        CANCELLED = 'cancelled', '已撤销'
        PENDING = 'pending','待执行'

    trade_id = models.BigAutoField(
        primary_key=True, 
        help_text="交易唯一ID"
    )
    # 注意：这里使用字符串 'positions.Position' 来避免循环导入问题
    # related_name='trade_logs' 允许从 Position 对象反向访问其所有交易记录
    position = models.ForeignKey(
        'Position', 
        on_delete=models.CASCADE, # 如果持仓被删除，关联的交易记录也应删除
        related_name='trade_logs',
        help_text="关联的持仓ID (买入时生成, 卖出时引用)"
    )
    stock_code = models.ForeignKey(
        StockInfo, 
        on_delete=models.PROTECT,
        db_column='stock_code',
        help_text="股票代码"
    )
    trade_datetime = models.DateTimeField(
        help_text="交易成交时间"
    )
    trade_type = models.CharField(
        max_length=10, 
        choices=TradeTypeChoices.choices,
        help_text="交易类型。枚举: buy(买入), sell(卖出)"
    )
    order_type = models.CharField(
        max_length=10, 
        choices=OrderTypeChoices.choices,
        help_text="订单类型。枚举: limit(限价), market(市价)"
    )
    price = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="成交均价"
    )
    quantity = models.BigIntegerField(
        help_text="成交数量"
    )
    commission = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        help_text="佣金"
    )
    stamp_duty = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        default=0,
        help_text="印花税 (仅卖出时有)"
    )
    reason = models.CharField(
        max_length=50, 
        choices=ReasonChoices.choices, 
        blank=True, 
        null=True,
        help_text="交易原因。枚举: entry(策略入场), take_profit(止盈), stop_loss(止损), manual(人工干预)"
    )
    status = models.CharField(
        max_length=20, 
        choices=StatusChoices.choices,
        help_text="订单状态。枚举: filled(已成交), failed(失败), cancelled(已撤销),pending(待执行)"
    )

    def __str__(self):
        return f"Trade {self.trade_id}: {self.trade_type.upper()} {self.quantity} of {self.stock_code}"

    class Meta:
        db_table = 'tb_trade_log'
        verbose_name = '交易记录'
        verbose_name_plural = verbose_name

####文件结束####

####data_manager\__init__.py####

####文件结束####

####data_manager\admin.py####
from django.contrib import admin

# Register your models here.

####文件结束####

####data_manager\apps.py####
from django.apps import AppConfig


class DataManagerConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'data_manager'

####文件结束####

####data_manager\models.py####
from django.db import models

# Create your models here.

####文件结束####

####data_manager\tests.py####
from django.test import TestCase

# Create your tests here.

####文件结束####

####data_manager\urls.py####
"""
URL configuration for autoTrade project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path,include
from . import views
urlpatterns = [
    path('test', views.test_get),
    path('updateLocalStock', views.update_local_a_shares),
    path('syncCorporateActions', views.sync_corporate_actions)
]

####文件结束####

####data_manager\views.py####
from django.http.response import JsonResponse
from django.shortcuts import render
from common.models import StockInfo
from data_manager.service.stock_service import StockService
from data_manager.service.corporate_action_service import CorporateActionService
from django.views.decorators.http import require_http_methods
import json
# Create your views here.
def test_get(request):
    result={}
    if request.method=='GET':
        result=  {'method':'get'}
    if request.method=='POST':
        result= {'methods':'post'}
    service=StockService()
    service.clear_all_data()
    service.update_local_a_shares(start_date="2025-01-01",end_date="2025-08-04")
    service.update_local_a_shares(start_date="2024-01-01",end_date="2024-12-31")
    service.update_local_a_shares(start_date="2023-01-01",end_date="2023-12-31")
    service.update_local_a_shares(start_date="2022-01-01",end_date="2022-12-31")
    service.update_local_a_shares(start_date="2021-01-01",end_date="2021-12-31")
    return JsonResponse(result)

@require_http_methods(["POST"])
def update_local_a_shares(request):
    body= json.loads(request.body)
    service=StockService()
    service.update_local_a_shares(stock_codes=body['stockCodes'],start_date=body['startDate'],end_date=body['endDate'])
    return JsonResponse({"result":"success"})

@require_http_methods(["POST"])
def sync_corporate_actions(request):
    body= json.loads(request.body)
    service=CorporateActionService()
    service.sync_corporate_actions(start_date=body['startDate'],end_date=body['endDate'])
    return JsonResponse({"result":"success"})

####文件结束####

####data_manager\management\commands\full_update_stocks.py####
# data_manager/management/commands/full_update_stocks.py

from django.core.management.base import BaseCommand
from data_manager.service.stock_service import StockService
import time

class Command(BaseCommand):
    help = '清空并重新获取过去五年的全部A股数据'

    def handle(self, *args, **options):
        total_start_time = time.time()
        self.stdout.write(self.style.SUCCESS('===== 开始执行全量数据更新任务 ====='))
        
        service = StockService()
        
        # 1. 清空所有旧数据
        self.stdout.write('正在清空所有历史数据...')
        #service.clear_all_data()
        self.stdout.write(self.style.SUCCESS('历史数据已清空。'))
        
        # 2. 按年份顺序获取数据
        #service.clear_all_data()
        service.update_local_a_shares(start_date="2022-01-01",end_date="2025-08-05")
        #service.update_local_a_shares(start_date="2024-01-01",end_date="2024-12-31")
        # service.update_local_a_shares(start_date="2023-01-01",end_date="2023-12-31")
        # service.update_local_a_shares(start_date="2022-01-01",end_date="2022-12-31")
        # service.update_local_a_shares(start_date="2021-01-01",end_date="2021-12-31")
        total_end_time = time.time()
        self.stdout.write(self.style.SUCCESS(f'\n===== 所有年份数据更新完毕！总耗时: {(total_end_time - total_start_time) / 3600:.2f} 小时 ====='))


####文件结束####

####data_manager\service\corporate_action_service.py####
import logging
import time
from datetime import datetime

import akshare
import pandas as pd
from django.db import transaction

# 导入您的 Django models
# 请根据您的项目结构调整以下导入路径
from common.models.corporate_action import CorporateAction
from common.models.stock_info import StockInfo

# 配置日志记录器
logger = logging.getLogger(__name__)
class CorporateActionService:
    def _fetch_and_save_split_events(self,stock_codes_filter: list, start_date: str, end_date: str):
        """
        预留的拆股/并股事件处理函数。
        """
        # logger.info(f"正在检查拆股/并股事件 (当前版本暂未实现)...")
        pass

    def sync_corporate_actions(self,start_date: str, end_date: str, stock_codes: list = None):
        """
        从 Akshare 高效同步指定日期范围和股票范围的股权事件数据，并存入数据库。
        """
        logger.info(f"开始同步股权事件，日期范围: {start_date} to {end_date}。")
        if stock_codes:
            logger.info(f"目标股票: {len(stock_codes)} 只。")
        else:
            logger.info("目标股票: 全部A股。")

        # 1. 任务开始前，一次性清理数据
        try:
            with transaction.atomic():
                qs = CorporateAction.objects.filter(
                    ex_dividend_date__gte=start_date,
                    ex_dividend_date__lte=end_date
                )
                if stock_codes:
                    qs = qs.filter(stock_code__in=stock_codes)
                
                deleted_count, _ = qs.delete()
                logger.info(f"数据清理完成。在 {start_date} 到 {end_date} 范围内共删除 {deleted_count} 条旧记录。")
        except Exception as e:
            logger.error(f"清理历史数据时发生严重错误，任务终止: {e}", exc_info=True)
            return

        all_stocks_map = {s.split('.')[-1]: s for s in StockInfo.objects.values_list('stock_code', flat=True)}
        ak_codes_filter = [c.split('.')[-1] for c in stock_codes] if stock_codes else None

        # 2. 处理分红、送股、转股 (stock_fhps_em)
        try:
            logger.info("开始处理分红、送股、转股事件...")
            fhps_dfs = []
            start_year = datetime.strptime(start_date, '%Y-%m-%d').year
            end_year = datetime.strptime(end_date, '%Y-%m-%d').year
            
            # ★★★★★ 优化点：使用更精确的年份范围，覆盖跨年预案 ★★★★★
            report_suffixes = ["0331", "0630", "0930", "1231"]
            for year in range(start_year - 1, end_year + 1):
                for suffix in report_suffixes:
                    report_date = f"{year}{suffix}"
                    logger.info(f"正在拉取报告期 {report_date} 的分红送配预案...")
                    try:
                        time.sleep(1)
                        fhps_df = akshare.stock_fhps_em(date=report_date)
                        if not fhps_df.empty:
                            fhps_dfs.append(fhps_df)
                    except Exception as e:
                        logger.warning(f"拉取报告期 {report_date} 数据失败或无数据: {e}")
            
            if fhps_dfs:
                # 使用 '代码' 和 '除权除息日' 作为联合主键去重，防止同一事件因在不同报告期披露而重复
                all_fhps_df = pd.concat(fhps_dfs, ignore_index=True).drop_duplicates(subset=['代码', '除权除息日'])
                
                all_fhps_df['除权除息日'] = pd.to_datetime(all_fhps_df['除权除息日'], errors='coerce')
                all_fhps_df.dropna(subset=['除权除息日'], inplace=True)
                
                mask = (all_fhps_df['除权除息日'] >= pd.to_datetime(start_date)) & (all_fhps_df['除权除息日'] <= pd.to_datetime(end_date))
                filtered_fhps_df = all_fhps_df[mask].copy()

                if ak_codes_filter:
                    filtered_fhps_df = filtered_fhps_df[filtered_fhps_df['代码'].isin(ak_codes_filter)]

                logger.info(f"共获取到 {len(filtered_fhps_df)} 条符合条件的分红送转记录，准备入库...")

                with transaction.atomic():
                    for _, row in filtered_fhps_df.iterrows():
                        ak_code = row['代码']
                        stock_code_prefixed = all_stocks_map.get(ak_code)
                        if not stock_code_prefixed:
                            continue

                        # 分红
                        if pd.notna(row['现金分红-现金分红比例']) and row['现金分红-现金分红比例'] > 0:
                            CorporateAction.objects.create(
                                stock_code=stock_code_prefixed,
                                ex_dividend_date=row['除权除息日'].date(),
                                record_date=pd.to_datetime(row['股权登记日'], errors='coerce').date() if pd.notna(row['股权登记日']) else None,
                                notice_date=pd.to_datetime(row['最新公告日期'], errors='coerce').date() if pd.notna(row['最新公告日期']) else None,
                                event_type=CorporateAction.EventType.DIVIDEND,
                                dividend_per_share=row['现金分红-现金分红比例'] / 10
                            )

                        # 送股
                        if pd.notna(row['送转股份-送转比例']) and row['送转股份-送转比例'] > 0:
                            CorporateAction.objects.create(
                                stock_code=stock_code_prefixed,
                                ex_dividend_date=row['除权除息日'].date(),
                                record_date=pd.to_datetime(row['股权登记日'], errors='coerce').date() if pd.notna(row['股权登记日']) else None,
                                notice_date=pd.to_datetime(row['最新公告日期'], errors='coerce').date() if pd.notna(row['最新公告日期']) else None,
                                event_type=CorporateAction.EventType.BONUS,
                                shares_before=10,
                                shares_after=10 + row['送转股份-送转比例']
                            )

                        # 转股
                        if pd.notna(row['送转股份-转股比例']) and row['送转股份-转股比例'] > 0:
                            CorporateAction.objects.create(
                                stock_code=stock_code_prefixed,
                                ex_dividend_date=row['除权除息日'].date(),
                                record_date=pd.to_datetime(row['股权登记日'], errors='coerce').date() if pd.notna(row['股权登记日']) else None,
                                notice_date=pd.to_datetime(row['最新公告日期'], errors='coerce').date() if pd.notna(row['最新公告日期']) else None,
                                event_type=CorporateAction.EventType.TRANSFER,
                                shares_before=10,
                                shares_after=10 + row['送转股份-转股比例']
                            )
            logger.info("分红、送股、转股事件处理完成。")
        except Exception as e:
            logger.error(f"处理分红送转数据时发生严重错误: {e}", exc_info=True)

        # 3. 处理配股 (stock_pg_em)
        try:
            logger.info("开始处理配股事件...")
            time.sleep(1)
            all_pg_df = akshare.stock_pg_em()
            
            # Akshare 返回的 '股权登记日' 可能包含无效日期，需要处理
            all_pg_df['股权登记日'] = pd.to_datetime(all_pg_df['股权登记日'], errors='coerce')
            all_pg_df.dropna(subset=['股权登记日'], inplace=True)
 
            mask = (all_pg_df['股权登记日'] >= pd.to_datetime(start_date)) & (all_pg_df['股权登记日'] <= pd.to_datetime(end_date))
            filtered_pg_df = all_pg_df[mask].copy()
 
            if ak_codes_filter:
                filtered_pg_df = filtered_pg_df[filtered_pg_df['股票代码'].isin(ak_codes_filter)]
            
            logger.info(f"共获取到 {len(filtered_pg_df)} 条符合条件的配股记录，准备入库...")
 
            with transaction.atomic():
                for _, row in filtered_pg_df.iterrows():
                    ak_code = row['股票代码']
                    stock_code_prefixed = all_stocks_map.get(ak_code)
                    if not stock_code_prefixed:
                        continue
 
                    # --- 修改开始 ---
                    # 从 '10配3.0' 这样的字符串中解析出配股比例数值
                    rights_ratio_val = 0
                    rights_ratio_str = row['配股比例']
                    
                    # 确保 '配股比例' 是一个有效的、可解析的字符串
                    if pd.notna(rights_ratio_str) and isinstance(rights_ratio_str, str) and '配' in rights_ratio_str:
                        try:
                            # 按 '配' 分割，取后面的部分，并转换为浮点数
                            ratio_str_part = rights_ratio_str.split('配')[1]
                            rights_ratio_val = float(ratio_str_part)
                        except (IndexError, ValueError) as e:
                            logger.warning(f"无法解析股票 {ak_code} 的配股比例 '{rights_ratio_str}'，已跳过。错误: {e}")
                            continue # 跳过此条记录
 
                    if rights_ratio_val > 0:
                        CorporateAction.objects.create(
                            stock_code=stock_code_prefixed,
                            # 注意：配股通常使用 '股权登记日' 作为关键日期，'除权日' 在此接口中可能不提供
                            ex_dividend_date=row['股权登记日'].date(), 
                            record_date=row['股权登记日'].date(),
                            notice_date=None, # akshare.stock_pg_em() 未提供公告日期
                            event_type=CorporateAction.EventType.RIGHTS,
                            shares_before=10, # 配股基准通常是10股
                            shares_after=10 + rights_ratio_val, # 使用解析后的数值
                            rights_issue_price=row['配股价']
                        )
                    # --- 修改结束 ---
 
            logger.info("配股事件处理完成。")
        except KeyError as e:
            # 捕获 '配股比例' 等字段不存在的错误
            logger.error(f"处理配股数据时发生字段缺失错误: {e}。请检查 Akshare 返回的数据列名是否已变更。", exc_info=True)
        except Exception as e:
            logger.error(f"处理配股数据时发生严重错误: {e}", exc_info=True)

        # 4. 调用预留的拆股/并股处理函数
        self._fetch_and_save_split_events(stock_codes, start_date, end_date)

        logger.info("所有股权事件同步任务已全部完成。")

####文件结束####

####data_manager\service\stock_service.py####
import logging
import datetime
from decimal import Decimal, ROUND_HALF_UP,InvalidOperation
import akshare as ak
import pandas as pd
from django.utils import timezone
from django.db import connection,transaction, DatabaseError

# 导入您的Django模型
from common.models.stock_info import StockInfo
from common.models.daily_quotes import DailyQuotes
from common.models.factor_definitions import FactorDefinitions
from common.models.daily_factor_values import DailyFactorValues
from common.models.strategy_parameters import StrategyParameters
from common.models.daily_trading_plan import DailyTradingPlan
from common.models.positions import Position
from common.models.trade_log import TradeLog
from common.models.system_log import SystemLog
from concurrent.futures import ThreadPoolExecutor, as_completed
import time

# 获取logger实例
logger = logging.getLogger(__name__)

# 定义模块常量，便于维护
MODULE_NAME = 'data_manager'

class StockService:
    """
    封装了与股票数据相关的服务，包括从akshare更新数据和从本地数据库查询数据。
  
    使用示例 (在Django views.py 或 management command中):
  
    from .services.stock_service import StockService
  
    def my_view(request):
        service = StockService()
      
        # 示例1: 更新所有A股今天的行情
        service.update_local_a_shares()
      
        # 示例2: 更新指定几只股票某时间段的行情
        codes = ['sh.600519', 'sz.000001']
        service.update_local_a_shares(stock_codes=codes, start_date='2023-01-01', end_date='2023-01-31')
      
        # 示例3: 查询指定股票的基础信息
        stock_infos = service.query_stock_info(stock_codes=codes)
      
        # 示例4: 查询所有股票今天的日线行情
        daily_quotes = service.query_daily_quotes()
    """

    def _log_and_save(self, message: str, level: str = SystemLog.LogLevelChoices.INFO):
        """
        一个辅助方法，用于同时向标准logger和数据库系统日志表写入日志。
        """
        log_map = {
            SystemLog.LogLevelChoices.INFO: logger.info,
            SystemLog.LogLevelChoices.WARNING: logger.warning,
            SystemLog.LogLevelChoices.ERROR: logger.error,
            SystemLog.LogLevelChoices.CRITICAL: logger.critical,
        }
      
        # 打印到标准日志
        log_function = log_map.get(level, logger.info)
        log_function(message)
      
        # 保存到数据库
        # try:
        #     SystemLog.objects.create(
        #         log_level=level,
        #         module_name=MODULE_NAME,
        #         message=message
        #     )
        # except Exception as e:
        #     logger.error(f"无法将日志写入数据库: {e}")

    def _save_quotes_df_to_db(self, quotes_df: pd.DataFrame):
        """
        辅助方法：将一个DataFrame的行情数据通过 update_or_create 批量存入数据库。
        此方法具有幂等性，适用于所有数据，无需区分历史和当日。
        """
        if quotes_df.empty:
            return
 
        # 数据清洗和预处理
        quotes_df.fillna(0, inplace=True)
        quotes_df = quotes_df[(quotes_df['开盘'] > 0) & (quotes_df['收盘'] > 0) & (quotes_df['最高'] > 0) & (quotes_df['最低'] > 0) & (quotes_df['成交量'] >= 0)]
        if quotes_df.empty:
            self._log_and_save("数据清洗后，当前批次无有效数据可存储。", level=SystemLog.LogLevelChoices.INFO)
            return
            
        quotes_df['日期'] = pd.to_datetime(quotes_df['日期']).dt.date
        
        hfq_precision = Decimal('0.0000000001')
        records_to_process = len(quotes_df)
    
        try:
            # 将整个批次的 update_or_create 操作放在一个事务中，以提高性能
            with transaction.atomic():
                for _, row in quotes_df.iterrows():
                    try:
                        close_dec = Decimal(str(row['收盘']))
                        factor_dec = Decimal(str(row['复权因子']))
                        hfq_close_dec = (close_dec * factor_dec).quantize(hfq_precision, rounding=ROUND_HALF_UP)
                        
                        # 对每一行数据都执行 update_or_create
                        DailyQuotes.objects.update_or_create(
                            stock_code_id=row['stock_code'], 
                            trade_date=row['日期'],
                            defaults={
                                'open': Decimal(str(row['开盘'])), 
                                'high': Decimal(str(row['最高'])),
                                'low': Decimal(str(row['最低'])), 
                                'close': close_dec,
                                'volume': int(row['成交量']), 
                                'turnover': Decimal(str(row['成交额'])),
                                'adjust_factor': factor_dec, 
                                'hfq_close': hfq_close_dec
                            }
                        )
                    except (InvalidOperation, TypeError) as conversion_error:
                        self._log_and_save(f"跳过一条数据转换失败的记录: {row['stock_code']} on {row['日期']}. Error: {conversion_error}", level=SystemLog.LogLevelChoices.WARNING)
                        continue
            
            self._log_and_save(f"通过 update_or_create 成功处理了 {records_to_process} 条日线数据。")
    
        except (DatabaseError, Exception) as e:
            self._log_and_save(f"数据批量入库阶段(update_or_create)发生严重错误: {e}", level=SystemLog.LogLevelChoices.ERROR)

    def update_local_a_shares(
        self, 
        stock_codes: list[str] = None, 
        start_date: str = None, 
        end_date: str = None
    ):

        """
        1. 更新本地A股信息 (最终版：高效、健壮)
        """
        self._log_and_save(f"开始执行A股数据更新任务...")
        target_codes=[]
        # --- Part 1: 更新股票基础信息 (tb_stock_info) ---
        try:
            self._log_and_save("正在从交易所官方数据源获取全量A股列表...")
            
            # 1. 通过高效、可靠的接口一次性获取所有A股信息
            # 上海主板A股
            sh_main_df = ak.stock_info_sh_name_code(symbol="主板A股").copy()
            # 上海科创板
            sh_star_df = ak.stock_info_sh_name_code(symbol="科创板").copy()
            # 深圳A股
            sz_a_df = ak.stock_info_sz_name_code(symbol="A股列表").copy()
 
            # 2. 数据预处理和合并
            # 统一列名
            sh_main_df.rename(columns={'证券简称': 'stock_name', '上市日期': 'listing_date', '证券代码': 'code'}, inplace=True)
            sh_star_df.rename(columns={'证券简称': 'stock_name', '上市日期': 'listing_date', '证券代码': 'code'}, inplace=True)
            sz_a_df.rename(columns={'A股简称': 'stock_name', 'A股上市日期': 'listing_date', 'A股代码': 'code'}, inplace=True)
 
            # 添加市场前缀
            sh_main_df['code'] = 'sh.' + sh_main_df['code']
            sh_star_df['code'] = 'sh.' + sh_star_df['code']
            sz_a_df['code'] = 'sz.' + sz_a_df['code']
 
            # 合并为一个DataFrame
            all_stocks_df = pd.concat([
                sh_main_df[['code', 'stock_name', 'listing_date']],
                sh_star_df[['code', 'stock_name', 'listing_date']],
                sz_a_df[['code', 'stock_name', 'listing_date']]
            ], ignore_index=True)
 
            # 转换日期格式
            all_stocks_df['listing_date'] = pd.to_datetime(all_stocks_df['listing_date']).dt.date
            
            self._log_and_save(f"成功获取 {len(all_stocks_df)} 条A股基础信息。")
 
            # 3. 高效的批量入库操作
            with transaction.atomic():
                existing_stocks = StockInfo.objects.in_bulk(field_name='stock_code')
                
                to_create = []
                to_update = []
 
                for _, row in all_stocks_df.iterrows():
                    code = row['code']
                    stock_obj = existing_stocks.get(code)
                    
                    if not stock_obj:
                        # 如果股票不存在，则准备新建
                        to_create.append(
                            StockInfo(
                                stock_code=code,
                                stock_name=row['stock_name'],
                                listing_date=row['listing_date'],
                                status=StockInfo.StatusChoices.LISTING
                            )
                        )
                    elif stock_obj.stock_name != row['stock_name']:
                        # 如果股票存在但名称有变，则准备更新
                        stock_obj.stock_name = row['stock_name']
                        to_update.append(stock_obj)
 
                # 批量创建
                if to_create:
                    StockInfo.objects.bulk_create(to_create, batch_size=500)
                    self._log_and_save(f"批量新增 {len(to_create)} 条股票基础信息。")
                
                # 批量更新
                if to_update:
                    StockInfo.objects.bulk_update(to_update, ['stock_name'], batch_size=500)
                    self._log_and_save(f"批量更新 {len(to_update)} 条股票基础信息。")
 
            # 如果未指定 stock_codes，则使用获取到的所有代码进行下一步
            if not stock_codes or len(stock_codes)==0:
                stock_codes = all_stocks_df['code'].tolist()
            else:
                # 如果指定了，则只处理指定的代码
                stock_codes = [code for code in stock_codes if code in all_stocks_df['code'].values]
            target_codes = stock_codes if stock_codes else all_stocks_df['code'].tolist()
        except Exception as e:
            self._log_and_save(f"更新股票基础信息时发生严重错误: {e}", level=SystemLog.LogLevelChoices.ERROR)
            return

        # --- Part 2: 更新日线行情 (串行获取、内存汇总、批量入库) ---
        self._log_and_save(f"开始为 {len(target_codes)} 只股票串行获取日线行情...")
        today_str = datetime.date.today().strftime('%Y%m%d')
        start_date_str = datetime.datetime.strptime(start_date, '%Y-%m-%d').strftime('%Y%m%d') if start_date else today_str
        end_date_str = datetime.datetime.strptime(end_date, '%Y-%m-%d').strftime('%Y%m%d') if end_date else today_str
        # 定义批处理参数
        batch_size = 50  # 每批处理50只股票，可以根据你的机器内存调整
        batch_quotes_list = []
        # 改为串行循环
        for i, code in enumerate(target_codes):
            ak_code = code.split('.')[1]
            logger.info(f"进度: [{i+1}/{len(target_codes)}] 正在获取 {code}...")
            try:
                df_normal = ak.stock_zh_a_hist(symbol=ak_code, period="daily", start_date=start_date_str, end_date=end_date_str, adjust="")
                time.sleep(1.6) # 增加礼貌性延时，降低被封风险
                df_hfq = ak.stock_zh_a_hist(symbol=ak_code, period="daily", start_date=start_date_str, end_date=end_date_str, adjust="hfq")
                
                if df_normal.empty or df_hfq.empty:
                    continue
 
                df = pd.merge(df_normal, df_hfq[['日期', '收盘']], on='日期', suffixes=('', '_hfq'))
                df['复权因子'] = df.apply(lambda row: row['收盘_hfq'] / row['收盘'] if row['收盘'] and row['收盘'] != 0 else 0, axis=1)
                df['stock_code'] = code
                batch_quotes_list.append(df)
                
                time.sleep(1.4) # 增加礼貌性延时，降低被封风险
 
            except Exception as e:
                self._log_and_save(f"获取 {code} 日线行情失败: {e}", level=SystemLog.LogLevelChoices.WARNING)
                continue
 
        # 检查是否达到批处理大小，或者已经是最后一只股票
            if (i + 1) % batch_size == 0 or (i + 1) == len(target_codes):
                if not batch_quotes_list:
                    continue # 如果这个批次是空的，就跳过

                self._log_and_save(f"处理批次 {i//batch_size + 1}，包含 {len(batch_quotes_list)} 只股票...")
                
                # 1. 合并当前批次的数据
                batch_master_df = pd.concat(batch_quotes_list, ignore_index=True)
                
                # 2. 将这个批次的数据存入数据库
                self._save_quotes_df_to_db(batch_master_df)
                
                # 3. 清空批次列表，释放内存，为下一批做准备
                batch_quotes_list = []
                self._log_and_save(f"批次 {i//batch_size + 1} 处理完毕，内存已释放。")
 
        self._log_and_save("A股数据更新任务全部执行完毕。")

    def query_stock_info(self, stock_codes: list[str] = None) -> dict[str, StockInfo]:
        """
        2. 查询本地A股基础信息
        直接查询 tb_stock_info。
        """
        queryset = StockInfo.objects.all()
        if stock_codes:
            queryset = queryset.filter(stock_code__in=stock_codes)
      
        return {stock.stock_code: stock for stock in queryset}

    def query_daily_quotes(
        self, 
        stock_codes: list[str] = None, 
        start_date: str = None, 
        end_date: str = None
    ) -> dict[str, list[DailyQuotes]]:
        """
        3. 查询本地A股交易信息
        直接查询 tb_daily_quotes。
        """
        # 设置默认日期为今天
        today = datetime.date.today()
        start_date = start_date or today.strftime('%Y-%m-%d')
        end_date = end_date or today.strftime('%Y-%m-%d')

        # 使用 select_related 优化查询，一次性获取关联的 StockInfo 对象
        # 使用 order_by 确保数据按股票和日期排序，便于后续分组
        queryset = DailyQuotes.objects.select_related('stock_code').filter(
            trade_date__gte=start_date,
            trade_date__lte=end_date
        ).order_by('stock_code', 'trade_date')

        if stock_codes:
            queryset = queryset.filter(stock_code__in=stock_codes)
      
        # 构建输出字典
        result = {}
        for quote in queryset:
            # 使用 stock_code_id 避免再次访问数据库
            # setdefault 是构建这种分组字典的优雅方式
            result.setdefault(quote.stock_code_id, []).append(quote)
          
        return result

    #清空所有数据
    def clear_all_data(self):
        with connection.cursor() as cursor:
            cursor.execute(f"DELETE FROM tb_daily_factor_values;")
            cursor.execute(f"DELETE FROM tb_daily_quotes;")
            cursor.execute(f"DELETE FROM tb_daily_trading_plan;")
            cursor.execute(f"DELETE FROM tb_factor_definitions;")
            cursor.execute(f"DELETE FROM tb_positions;")
            cursor.execute(f"DELETE FROM tb_stock_info;")
            cursor.execute(f"DELETE FROM tb_strategy_parameters;")
            cursor.execute(f"DELETE FROM tb_system_log;")
            cursor.execute(f"DELETE FROM tb_trade_log;")
####文件结束####

####selection_manager\__init__.py####

####文件结束####

####selection_manager\admin.py####
from django.contrib import admin

# Register your models here.

####文件结束####

####selection_manager\apps.py####
from django.apps import AppConfig


class SelectionManagerConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'selection_manager'

####文件结束####

####selection_manager\models.py####
from django.db import models

# Create your models here.

####文件结束####

####selection_manager\tests.py####
from django.test import TestCase

# Create your tests here.

####文件结束####

####selection_manager\urls.py####
"""
URL configuration for autoTrade project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path,include
from . import views
urlpatterns = [
    path('initSelectionStratage', views.init_strategy),
    path('runSelection',views.run_selection)
]

####文件结束####

####selection_manager\views.py####
from datetime import date,datetime
from django.shortcuts import render
from django.http.response import JsonResponse
from selection_manager.service.selection_service import SelectionService
import json
from django.views.decorators.http import require_http_methods
# Create your views here.
@require_http_methods(["GET"])
def init_strategy(request):
    SelectionService.initialize_strategy()
    result={}
    return JsonResponse(result)
@require_http_methods(["POST"])
def run_selection(request):
    if request.method=='POST':
        body= json.loads(request.body)
        selection_date=datetime.strptime(body['date'], "%Y-%m-%d").date()
        service=SelectionService(selection_date,mode=body['mode'])
        service.run_selection()
        return JsonResponse({
            'type':selection_date,
            'data':json.loads(request.body)
        })
    

####文件结束####

####selection_manager\service\selection_service.py####
# selection_manager/service/selection_service.py

import logging
from datetime import date, timedelta
from decimal import Decimal

import numpy as np
import pandas as pd
import pandas_ta as ta
from scipy.stats import linregress

from django.db import transaction
from django.utils import timezone

from common.models.stock_info import StockInfo
from common.models.daily_quotes import DailyQuotes
from common.models.system_log import SystemLog
from common.models.factor_definitions import FactorDefinitions
from common.models.daily_factor_values import DailyFactorValues
from common.models.strategy_parameters import StrategyParameters
from common.models.daily_trading_plan import DailyTradingPlan



# region: 全局配置
MODULE_NAME = '日终选股与预案生成'
logger = logging.getLogger(MODULE_NAME)
# endregion


class SelectionService:
    """
    T-1日收盘后运行的选股与预案生成服务。
    
    执行流程:
    1. 加载策略参数。
    2. 对全市场股票进行初步筛选。
    3. 加载所需时间窗口内的所有行情数据，构建面板数据(Panel Data)。
    4. 计算所有因子原始值。
    5. 对因子值进行标准化处理。
    6. 计算综合得分并排序。
    7. 为Top N股票生成交易预案（MIOP/MAOP）。
    8. 将所有结果持久化到数据库。
    """

    def __init__(self, trade_date: date, mode: str = 'realtime'):
        """
        初始化选股服务。

        :param trade_date: T-1日，即执行计算的当天日期。
        :param mode: 运行模式, 'realtime' 或 'backtest'。
        """
        if mode not in ['realtime', 'backtest']:
            raise ValueError("模式(mode)必须是 'realtime' 或 'backtest'")

        self.trade_date = trade_date
        self.mode = mode
        self.params = {}
        self.factor_defs = {}
        
        # 用于存储面板数据
        self.panel_open = None
        self.panel_high = None
        self.panel_low = None
        self.panel_close = None
        self.panel_volume = None
        self.panel_turnover = None
        self.panel_hfq_close = None

        logger.debug(f"--- SelectionService 初始化 ---")
        logger.debug(f"交易日期 (T-1): {self.trade_date}")
        logger.debug(f"运行模式: {self.mode}")

    # region: --- 1. 主流程与入口方法 ---

    @staticmethod
    def initialize_strategy():
        """
        初始化策略所需的因子定义和参数到数据库。
        这是一个幂等操作，可以重复运行。
        """
        logger.debug("开始初始化策略：铺底因子定义和策略参数...")

        # 1. 定义所有因子
        factors_to_define = [
            {'factor_code': 'MA20_SLOPE', 'factor_name': '20日均线斜率', 'direction': 'positive', 'description': 'x1: 过去20个交易日MA20值的线性回归斜率'},
            {'factor_code': 'MA_ALIGNMENT', 'factor_name': '均线排列评分', 'direction': 'positive', 'description': 'x2: 收盘价/MA5/MA10/MA20多头排列评分(0-3)'},
            {'factor_code': 'ADX_TREND', 'factor_name': 'ADX趋势强度', 'direction': 'positive', 'description': 'x3: ADX > 25 且 +DI > -DI 时的ADX值'},
            {'factor_code': 'ROC10', 'factor_name': '10日价格变化率', 'direction': 'positive', 'description': 'x4: (Close_t / Close_t-10) - 1'},
            {'factor_code': 'VOL_BREAKOUT', 'factor_name': '成交量突破', 'direction': 'positive', 'description': 'x5: 最近5日均量 / 最近60日均量'},
            {'factor_code': 'NEW_HIGH_MOMENTUM', 'factor_name': '新高动能', 'direction': 'positive', 'description': 'x6: 当前收盘价 / 过去60日最高价'},
            {'factor_code': 'VOLATILITY20', 'factor_name': '20日波动率', 'direction': 'negative', 'description': 'x7: 最近20日复权收益率标准差'},
            {'factor_code': 'LIQUIDITY20', 'factor_name': '20日流动性', 'direction': 'positive', 'description': 'x8: 最近20日日均成交额'},
        ]
        with transaction.atomic():
            for factor_data in factors_to_define:
                FactorDefinitions.objects.update_or_create(
                    factor_code=factor_data['factor_code'],
                    defaults=factor_data
                )
        logger.debug(f"成功初始化/更新 {len(factors_to_define)} 个因子定义。")

        # 2. 定义所有参数 (权重、系数、计算周期)
        # !!! 要求4: 给我留一个字典当口子，后面我想好了值再填进去 !!!
        # 这里就是那个口子，您可以随时修改这些默认值
        parameters_to_define = {
            # 维度权重 (和必须为1)
            'w_trend': {'value': Decimal('0.4'), 'group': 'WEIGHTS', 'desc': '趋势维度权重'},
            'w_momentum': {'value': Decimal('0.4'), 'group': 'WEIGHTS', 'desc': '动能维度权重'},
            'w_quality': {'value': Decimal('0.2'), 'group': 'WEIGHTS', 'desc': '质量/风控维度权重'},
            # 因子权重
            'k1': {'value': Decimal('0.4'), 'group': 'TREND_FACTORS', 'desc': 'x1: MA20斜率权重'},
            'k2': {'value': Decimal('0.3'), 'group': 'TREND_FACTORS', 'desc': 'x2: 均线排列权重'},
            'k3': {'value': Decimal('0.3'), 'group': 'TREND_FACTORS', 'desc': 'x3: ADX趋势强度权重'},
            'k4': {'value': Decimal('0.4'), 'group': 'MOMENTUM_FACTORS', 'desc': 'x4: ROC10权重'},
            'k5': {'value': Decimal('0.3'), 'group': 'MOMENTUM_FACTORS', 'desc': 'x5: 成交量突破权重'},
            'k6': {'value': Decimal('0.3'), 'group': 'MOMENTUM_FACTORS', 'desc': 'x6: 新高动能权重'},
            'k7': {'value': Decimal('0.5'), 'group': 'QUALITY_FACTORS', 'desc': 'x7: 波动率权重'},
            'k8': {'value': Decimal('0.5'), 'group': 'QUALITY_FACTORS', 'desc': 'x8: 流动性权重'},
            # 交易预案参数
            'k_drop': {'value': Decimal('0.3'), 'group': 'PLAN_PARAMS', 'desc': 'MIOP低开容忍系数'},
            'k_gap': {'value': Decimal('0.5'), 'group': 'PLAN_PARAMS', 'desc': 'MAOP高开容忍系数'},
            # 计算周期参数
            'lookback_new_stock': {'value': Decimal('60'), 'group': 'LOOKBACKS', 'desc': '次新股定义天数'},
            'lookback_liquidity': {'value': Decimal('20'), 'group': 'LOOKBACKS', 'desc': '流动性计算周期'},
            'lookback_ma_slow': {'value': Decimal('60'), 'group': 'LOOKBACKS', 'desc': '慢速均线周期(如成交量)'},
            'lookback_ma_fast': {'value': Decimal('5'), 'group': 'LOOKBACKS', 'desc': '快速均线周期(如成交量)'},
            'lookback_ma20': {'value': Decimal('20'), 'group': 'LOOKBACKS', 'desc': 'MA20周期'},
            'lookback_ma10': {'value': Decimal('10'), 'group': 'LOOKBACKS', 'desc': 'MA10周期'},
            'lookback_ma5': {'value': Decimal('5'), 'group': 'LOOKBACKS', 'desc': 'MA5周期'},
            'lookback_roc': {'value': Decimal('10'), 'group': 'LOOKBACKS', 'desc': 'ROC计算周期'},
            'lookback_new_high': {'value': Decimal('60'), 'group': 'LOOKBACKS', 'desc': '新高动能计算周期'},
            'lookback_volatility': {'value': Decimal('20'), 'group': 'LOOKBACKS', 'desc': '波动率计算周期'},
            'lookback_atr': {'value': Decimal('14'), 'group': 'LOOKBACKS', 'desc': 'ATR计算周期'},
            'lookback_adx': {'value': Decimal('14'), 'group': 'LOOKBACKS', 'desc': 'ADX计算周期'},
            # 其他参数
            'param_min_liquidity': {'value': Decimal('100000000'), 'group': 'FILTERS', 'desc': '最低日均成交额(元)'},
            'param_top_n': {'value': Decimal('10'), 'group': 'SELECTION', 'desc': '最终选取股票数量'},
            'param_adx_threshold': {'value': Decimal('25'), 'group': 'THRESHOLDS', 'desc': 'ADX趋势形成阈值'},
        }
        with transaction.atomic():
            for name, data in parameters_to_define.items():
                StrategyParameters.objects.update_or_create(
                    param_name=name,
                    defaults={
                        'param_value': data['value'],
                        'group_name': data['group'],
                        'description': data['desc']
                    }
                )
        logger.debug(f"成功初始化/更新 {len(parameters_to_define)} 个策略参数。")
        logger.debug("策略初始化完成。")

    def run_selection(self):
        """
        一键启动全流程的入口方法。
        """
        # 关闭 pandas-ta 的冗余日志
        ta.Imports["verbose"] = False
        self._log_to_db('INFO', f"选股流程启动。模式: {self.mode}, 日期: {self.trade_date}")
        try:
            # 步骤 1: 加载所有配置参数
            self._load_parameters_and_defs()

            # 步骤 2: 初步筛选股票池
            initial_stock_pool = self._initial_screening()
            if not initial_stock_pool:
                logger.warning("初步筛选后无符合条件的股票，流程终止。")
                self._log_to_db('WARNING', "初步筛选后无符合条件的股票，流程终止。")
                return

            # 步骤 3: 加载行情数据并构建面板
            self._load_market_data(initial_stock_pool)

            # 步骤 4: 计算所有因子原始值
            raw_factors_df = self._calculate_all_factors()

            # 步骤 5: 标准化因子
            norm_scores_df = self._standardize_factors(raw_factors_df)

            # 步骤 6: 计算综合得分
            final_scores = self._calculate_composite_score(norm_scores_df)
            
            # 步骤 7: 生成交易预案
            trading_plan = self._generate_trading_plan(final_scores)
            if trading_plan.empty:
                logger.warning("最终未生成任何交易预案。")
                self._log_to_db('WARNING', "最终未生成任何交易预案。")
                return

            # 步骤 8: 保存所有结果到数据库
            self._save_results(raw_factors_df, norm_scores_df, trading_plan)

            # 模式特定逻辑的口子
            if self.mode == 'backtest':
                logger.debug("回测模式特定逻辑处理... (当前无)")
            elif self.mode == 'realtime':
                logger.debug("实时模式特定逻辑处理... (当前无)")

            success_msg = f"选股流程成功完成。生成 {len(trading_plan)} 条交易预案。"
            logger.info(success_msg)
            self._log_to_db('INFO', success_msg)

        except Exception as e:
            error_msg = f"选股流程发生严重错误: {e}"
            logger.critical(error_msg, exc_info=True)
            self._log_to_db('CRITICAL', error_msg)
            # 如果在事务中，需要确保事务回滚，但Django的请求/响应周期或事务装饰器通常会处理这个
            raise

    # endregion

    # region: --- 2. 内部辅助方法 ---

    def _log_to_db(self, level, message):
        """辅助方法：将日志写入数据库"""
        SystemLog.objects.create(
            log_level=level,
            module_name=MODULE_NAME,
            message=message
        )

    def _load_parameters_and_defs(self):
        """从数据库加载所有策略参数和因子定义到内存"""
        logger.debug("加载策略参数和因子定义...")
        
        # 加载参数
        params_qs = StrategyParameters.objects.all()
        # --- 修改点在这里 ---
        # 在加载时，直接将 Decimal 转换为 float，用于后续的科学计算
        # 对于需要整数的参数，单独处理
        self.params = {}
        for p in params_qs:
            if p.param_name.startswith('lookback_') or p.param_name in ['param_top_n', 'param_adx_threshold']:
                self.params[p.param_name] = int(p.param_value)
            else:
                self.params[p.param_name] = float(p.param_value)
        
        # 加载因子定义
        defs_qs = FactorDefinitions.objects.filter(is_active=True)
        self.factor_defs = {f.factor_code: {'direction': f.direction} for f in defs_qs}
        
        logger.debug(f"加载了 {len(self.params)} 个参数和 {len(self.factor_defs)} 个启用的因子定义。")

    def _get_market_trade_dates(self, lookback_period: int) -> list[date]:
        """获取截至T-1日的N个市场交易日历"""
        trade_dates = list(
            DailyQuotes.objects
            .filter(trade_date__lte=self.trade_date)
            .values_list('trade_date', flat=True)
            .distinct()
            .order_by('-trade_date')[:lookback_period]
        )
        trade_dates.reverse()
        return trade_dates

    def _initial_screening(self) -> list[str]:
        """执行初步筛选，返回符合条件的股票代码列表"""
        logger.debug("开始执行初步筛选...")
        
        # 1. 剔除ST股
        all_stocks = StockInfo.objects.filter(status=StockInfo.StatusChoices.LISTING)
        non_st_stocks = all_stocks.exclude(stock_name__startswith='ST').exclude(stock_name__startswith='*ST')
        
        # 2. 剔除次新股
        min_listing_date = self.trade_date - timedelta(days=self.params['lookback_new_stock'])
        non_new_stocks = non_st_stocks.filter(listing_date__lt=min_listing_date)
        
        stock_pool_codes = list(non_new_stocks.values_list('stock_code', flat=True))
        logger.info(f"剔除ST和次新股后，剩余 {len(stock_pool_codes)} 只股票。")

        # 3. 剔除低流动性股
        lookback_days = self.params['lookback_liquidity']
        start_date = self.trade_date - timedelta(days=lookback_days * 2) 
        
        quotes = DailyQuotes.objects.filter(
            stock_code_id__in=stock_pool_codes,
            trade_date__lte=self.trade_date,
            trade_date__gte=start_date
        ).values('stock_code_id', 'trade_date', 'turnover')

        if not quotes:
            logger.warning("在流动性筛选期间未找到任何行情数据。")
            return []

        quotes_df = pd.DataFrame.from_records(quotes)
        
        # 获取最近 lookback_days 个交易日
        recent_trade_dates = sorted(quotes_df['trade_date'].unique())[-lookback_days:]
        quotes_df = quotes_df[quotes_df['trade_date'].isin(recent_trade_dates)]

        avg_turnover = quotes_df.groupby('stock_code_id')['turnover'].mean()
        liquid_stocks = avg_turnover[avg_turnover >= self.params['param_min_liquidity']]
        
        final_stock_pool = list(liquid_stocks.index)
        logger.info(f"剔除低流动性股后，最终剩余 {len(final_stock_pool)} 只股票进入精选池。")
        
        return final_stock_pool

    def _load_market_data(self, stock_pool: list[str]):
        """加载所有需要的数据并构建面板"""
        # 确定最长的回溯期
        max_lookback = max(
            self.params['lookback_ma_slow'],
            self.params['lookback_new_high'],
            self.params['lookback_adx'] + 50 # ADX需要更长的数据来稳定
        )
        logger.debug(f"确定最大数据回溯期为 {max_lookback} 个交易日。")

        trade_dates = self._get_market_trade_dates(max_lookback)
        if not trade_dates:
            raise ValueError("无法获取市场交易日历，数据库可能为空。")
        
        logger.debug(f"正在加载 {len(stock_pool)} 只股票在 {len(trade_dates)} 个交易日内的行情数据...")
        
        quotes_qs = DailyQuotes.objects.filter(
            stock_code_id__in=stock_pool,
            trade_date__in=trade_dates
        ).values('trade_date', 'stock_code_id', 'open', 'high', 'low', 'close', 'volume', 'turnover', 'hfq_close')
        
        if not quotes_qs:
            raise ValueError("在指定日期范围内未找到任何股票的行情数据。")

        df = pd.DataFrame.from_records(quotes_qs)
        df['trade_date'] = pd.to_datetime(df['trade_date'])
        
        # 构建面板数据，停牌的股票会自动填充NaN
        logger.debug("正在构建面板数据(Panel Data)...")
        # 1. 从原始DataFrame中确定所有面板的“理想形状”
        # 这是最全的日期和股票列表，是我们的“真理之源”
        master_index_raw = df['trade_date'].unique()
        master_columns_raw = df['stock_code_id'].unique()
        master_index = np.sort(master_index_raw)
        master_columns = np.sort(master_columns_raw)
        
        
        
        logger.debug(f"已确定基准形状: {len(master_index)} 个日期 x {len(master_columns)} 只股票。")
 
        # 2. 使用 set_index + unstack 高效地创建各个面板
        # 这一步创建的面板可能形状不一，因为个别股票在某些天可能没有某个值
        base_df = df.set_index(['trade_date', 'stock_code_id'])
        
        panel_open_raw = base_df['open'].unstack()
        panel_high_raw = base_df['high'].unstack()
        panel_low_raw = base_df['low'].unstack()
        panel_close_raw = base_df['close'].unstack()
        panel_volume_raw = base_df['volume'].unstack()
        panel_turnover_raw = base_df['turnover'].unstack()
        panel_hfq_close_raw = base_df['hfq_close'].unstack()
 
        # 3. 将所有原始面板 reindex 到我们预先定义的“理想形状”
        # 这样可以确保所有面板的维度完全一致，缺失值会被正确地填充为NaN
        self.panel_open = panel_open_raw.reindex(index=master_index, columns=master_columns)
        self.panel_high = panel_high_raw.reindex(index=master_index, columns=master_columns)
        self.panel_low = panel_low_raw.reindex(index=master_index, columns=master_columns)
        self.panel_close = panel_close_raw.reindex(index=master_index, columns=master_columns)
        self.panel_volume = panel_volume_raw.reindex(index=master_index, columns=master_columns)
        self.panel_turnover = panel_turnover_raw.reindex(index=master_index, columns=master_columns)
        self.panel_hfq_close = panel_hfq_close_raw.reindex(index=master_index, columns=master_columns)
        self.panel_open = self.panel_open.astype(float)
        self.panel_high = self.panel_high.astype(float)
        self.panel_low = self.panel_low.astype(float)
        self.panel_close = self.panel_close.astype(float)
        self.panel_volume = self.panel_volume.astype(float)
        self.panel_turnover = self.panel_turnover.astype(float)
        self.panel_hfq_close = self.panel_hfq_close.astype(float)
        logger.debug("面板数据构建完成。")

    # endregion

    # region: --- 3. 因子计算 (模块化) ---

    def _calculate_all_factors(self) -> pd.DataFrame:
        """
        调度所有因子计算方法，并将结果合并到一个DataFrame中。
        返回的DataFrame: index=stock_code, columns=factor_codes
        """
        logger.debug("开始计算所有因子...")
        
        factor_calculators = {
            'MA20_SLOPE': self._calc_factor_x1_ma20_slope,
            'MA_ALIGNMENT': self._calc_factor_x2_ma_alignment,
            'ADX_TREND': self._calc_factor_x3_adx_trend,
            'ROC10': self._calc_factor_x4_roc,
            'VOL_BREAKOUT': self._calc_factor_x5_vol_breakout,
            'NEW_HIGH_MOMENTUM': self._calc_factor_x6_new_high_momentum,
            'VOLATILITY20': self._calc_factor_x7_volatility,
            'LIQUIDITY20': self._calc_factor_x8_liquidity,
        }
        
        all_factors = {}
        for code, func in factor_calculators.items():
            if code in self.factor_defs:
                logger.debug(f"  - 计算因子: {code}")
                # 每个因子计算方法返回一个以stock_code为索引的Series
                all_factors[code] = func()
        
        # 合并所有因子Series为一个DataFrame
        raw_factors_df = pd.DataFrame(all_factors)
        
        # 剔除任何一个因子值为NaN的股票
        original_count = len(raw_factors_df)
        raw_factors_df.dropna(inplace=True)
        final_count = len(raw_factors_df)
        logger.info(f"因子计算完成。因数据不足(NaN)剔除了 {original_count - final_count} 只股票。剩余 {final_count} 只。")
        
        return raw_factors_df

    # --- 每个因子的独立计算方法 ---
    # 传参: 无 (通过self访问面板数据和参数)
    # 返回: pd.Series (index=stock_code, value=因子原始值)

    def _calc_factor_x1_ma20_slope(self) -> pd.Series:
        ma_period = self.params['lookback_ma20']
        panel_close_float = self.panel_hfq_close.astype(float)
        ma20 = panel_close_float.apply(
            lambda col: ta.sma(close=col, length=ma_period)
        )
        
        # 对每只股票，取最后ma_period个MA值进行线性回归
        def get_slope(series):
            y = series.dropna()
            if len(y) < 2:
                return np.nan
            y_values = y.values
            x_values = np.arange(len(y_values))
            # 增加一个额外的健壮性检查，防止y_values中所有值都相同导致回归失败
            if np.all(y_values == y_values[0]):
                return 0.0 # 如果所有值都一样，斜率为0
            slope, _, _, _, _ = linregress(x_values, y_values)
            return slope

        # 只取最后ma_period行数据进行计算以提高效率
        slopes = ma20.iloc[-ma_period:].apply(get_slope, axis=0)
        return slopes

    def _calc_factor_x2_ma_alignment(self) -> pd.Series:
        ma5 = self.panel_hfq_close.apply(
            lambda col: ta.sma(close=col, length=self.params['lookback_ma5'])
        )
        ma10 = self.panel_hfq_close.apply(
            lambda col: ta.sma(close=col, length=self.params['lookback_ma10'])
        )
        ma20 = self.panel_hfq_close.apply(
            lambda col: ta.sma(close=col, length=self.params['lookback_ma20'])
        )
        
        last_close = self.panel_hfq_close.iloc[-1]
        last_ma5 = ma5.iloc[-1]
        last_ma10 = ma10.iloc[-1]
        last_ma20 = ma20.iloc[-1]
        
        score = (
            (last_close > last_ma5).astype(int) +
            (last_ma5 > last_ma10).astype(int) +
            (last_ma10 > last_ma20).astype(int)
        )
        return score

    def _calc_factor_x3_adx_trend(self) -> pd.Series:
        # 强制转换数据类型为 float
        high = self.panel_high.astype(float)
        low = self.panel_low.astype(float)
        close = self.panel_close.astype(float)
        
        adx_period = self.params['lookback_adx']
        threshold = self.params['param_adx_threshold']
 
        # 定义一个函数，用于对单只股票（一个Series）计算ADX
        def get_adx_trend(stock_code):
            # 从面板中提取单只股票的数据
            stock_high = high[stock_code].dropna()
            stock_low = low[stock_code].dropna()
            stock_close = close[stock_code].dropna()
 
            # 确保数据对齐
            common_index = stock_high.index.intersection(stock_low.index).intersection(stock_close.index)
            if len(common_index) < adx_period * 2: # ADX需要更长的数据来初始化
                return np.nan
 
            stock_high = stock_high.loc[common_index]
            stock_low = stock_low.loc[common_index]
            stock_close = stock_close.loc[common_index]
 
            # 使用 pandas_ta 计算单只股票的ADX
            adx_result = ta.adx(high=stock_high, low=stock_low, close=stock_close, length=adx_period)
 
            # 检查结果是否有效
            if adx_result is None or adx_result.empty:
                return np.nan
 
            last_row = adx_result.iloc[-1]
            last_adx = last_row.get(f'ADX_{adx_period}')
            last_dmp = last_row.get(f'DMP_{adx_period}')
            last_dmn = last_row.get(f'DMN_{adx_period}')
 
            if pd.isna(last_adx) or pd.isna(last_dmp) or pd.isna(last_dmn):
                return np.nan
 
            if last_adx > threshold and last_dmp > last_dmn:
                return last_adx
            else:
                return 0.0
 
        # 对面板中的每一只股票应用该函数
        results = {stock_code: get_adx_trend(stock_code) for stock_code in self.panel_close.columns}
        
        return pd.Series(results)

    def _calc_factor_x4_roc(self) -> pd.Series:
        roc_panel = self.panel_hfq_close.apply(
        lambda col: ta.roc(close=col, length=self.params['lookback_roc'])
        )
        return roc_panel.iloc[-1]

    def _calc_factor_x5_vol_breakout(self) -> pd.Series:
        vol5 = self.panel_volume.rolling(window=self.params['lookback_ma_fast']).mean()
        vol60 = self.panel_volume.rolling(window=self.params['lookback_ma_slow']).mean()
        ratio = vol5.iloc[-1] / vol60.iloc[-1]
        return ratio.replace([np.inf, -np.inf], np.nan) # 处理分母为0的情况

    def _calc_factor_x6_new_high_momentum(self) -> pd.Series:
        high60 = self.panel_hfq_close.rolling(window=self.params['lookback_new_high']).max()
        ratio = self.panel_hfq_close.iloc[-1] / high60.iloc[-1]
        return ratio

    def _calc_factor_x7_volatility(self) -> pd.Series:
        returns = self.panel_hfq_close.pct_change(fill_method=None)
        volatility = returns.rolling(window=self.params['lookback_volatility']).std()
        return volatility.iloc[-1]

    def _calc_factor_x8_liquidity(self) -> pd.Series:
        liquidity = self.panel_turnover.rolling(window=self.params['lookback_liquidity']).mean()
        return liquidity.iloc[-1]

    # endregion

    # region: --- 4. 评分、预案生成与保存 ---

    def _standardize_factors(self, raw_factors_df: pd.DataFrame) -> pd.DataFrame:
        """
        对原始因子值进行标准化处理 (norm函数)。
        """
        logger.debug("开始对因子值进行标准化...")
        norm_scores_df = pd.DataFrame(index=raw_factors_df.index)
        
        for factor_code, series in raw_factors_df.items():
            direction = self.factor_defs[factor_code]['direction']
            
            p1 = series.quantile(0.01)
            p99 = series.quantile(0.99)
            
            
            epsilon = 1e-9  # 定义一个极小值
            if (p99 - p1) < epsilon:
                norm_scores_df[factor_code] = 0
                continue
            
            # Winsorization (缩尾处理)
            x_prime = series.clip(p1, p99)
            
            # 线性映射
            if direction == 'positive':
                score = ((x_prime - p1) / (p99 - p1)) * 200 - 100
            else: # negative
                score = ((p99 - x_prime) / (p99 - p1)) * 200 - 100
            
            norm_scores_df[factor_code] = score
            
        logger.debug("因子标准化完成。")
        return norm_scores_df

    def _calculate_composite_score(self, norm_scores_df: pd.DataFrame) -> pd.Series:
        """
        计算f(x)综合得分。
        """
        logger.debug("开始计算综合得分 f(x)...")
        
        # 趋势维度
        score_trend = (
            norm_scores_df['MA20_SLOPE'] * self.params['k1'] +
            norm_scores_df['MA_ALIGNMENT'] * self.params['k2'] +
            norm_scores_df['ADX_TREND'] * self.params['k3']
        )
        
        # 动能维度
        score_momentum = (
            norm_scores_df['ROC10'] * self.params['k4'] +
            norm_scores_df['VOL_BREAKOUT'] * self.params['k5'] +
            norm_scores_df['NEW_HIGH_MOMENTUM'] * self.params['k6']
        )
        
        # 质量/风控维度
        score_quality = (
            norm_scores_df['VOLATILITY20'] * self.params['k7'] +
            norm_scores_df['LIQUIDITY20'] * self.params['k8']
        )
        
        # 总分
        final_score = (
            score_trend * self.params['w_trend'] +
            score_momentum * self.params['w_momentum'] +
            score_quality * self.params['w_quality']
        )
        
        logger.debug("综合得分计算完成。")
        return final_score.sort_values(ascending=False)

    def _generate_trading_plan(self, final_scores: pd.Series) -> pd.DataFrame:
        top_n = self.params['param_top_n']
        top_stocks = final_scores.head(top_n)
        
        logger.debug(f"开始为Top {top_n} 股票生成交易预案...")
        
        if top_stocks.empty:
            return pd.DataFrame()
 
        top_stock_codes = top_stocks.index.tolist()
        
        # --- 修改点在这里：需要把完整的ATR计算逻辑加回来 ---
        atr_period = self.params['lookback_atr']
        last_atr_values = {}
        for code in top_stock_codes:
            # 提取单只股票数据并计算ATR
            stock_high = self.panel_high[code].astype(float).dropna()
            stock_low = self.panel_low[code].astype(float).dropna()
            stock_close = self.panel_close[code].astype(float).dropna()
            
            common_index = stock_high.index.intersection(stock_low.index).intersection(stock_close.index)
            if len(common_index) < atr_period:
                last_atr_values[code] = np.nan
                continue
 
            atr_result = ta.atr(
                high=stock_high.loc[common_index],
                low=stock_low.loc[common_index],
                close=stock_close.loc[common_index],
                length=atr_period
            )
            if atr_result is not None and not atr_result.empty:
                last_atr_values[code] = atr_result.iloc[-1]
            else:
                last_atr_values[code] = np.nan
        # --- ATR计算逻辑结束 ---
 
        last_atr = pd.Series(last_atr_values)
        
        # 1. 获取所有需要的数据，并确保它们是Series，且索引为stock_code
        last_close = self.panel_close.iloc[-1]
 
        # 2. 以 top_stocks 为基准，重新索引（reindex）所有数据
        aligned_scores = top_stocks
        aligned_close = last_close.reindex(top_stock_codes)
        aligned_atr = last_atr.reindex(top_stock_codes)
 
        # 3. 在对齐后的数据上进行计算
        k_drop = self.params['k_drop']
        k_gap = self.params['k_gap']
        
        miop = aligned_close * (1 - k_drop * (aligned_atr / aligned_close))
        maop = aligned_close * (1 + k_gap * (aligned_atr / aligned_close))
 
        # 4. 组装预案
        plan_df = pd.DataFrame({
            'stock_code': top_stock_codes,
            'rank': range(1, len(top_stock_codes) + 1),
            'final_score': aligned_scores.values,
            'miop': miop.values,
            'maop': maop.values
        })
 
        # 5. (可选但推荐) 剔除因为数据不足无法生成预案的行
        plan_df.dropna(subset=['miop', 'maop'], inplace=True)
        
        logger.debug("交易预案生成完成。")
        return plan_df

    @transaction.atomic
    def _save_results(self, raw_factors_df, norm_scores_df, trading_plan_df):
        """
        将所有计算结果原子性地保存到数据库。
        """
        logger.debug("开始将结果保存到数据库...")
        
        # 1. 保存每日因子值
        logger.debug(f"  - 正在准备 {len(raw_factors_df) * len(raw_factors_df.columns)} 条因子值数据...")
        factor_values_to_create = []
        for stock_code, row in raw_factors_df.iterrows():
            for factor_code, raw_value in row.items():
                norm_score = norm_scores_df.loc[stock_code, factor_code]
                factor_values_to_create.append(
                    DailyFactorValues(
                        stock_code_id=stock_code,
                        trade_date=self.trade_date,
                        factor_code_id=factor_code,
                        raw_value=Decimal(str(raw_value)),
                        norm_score=Decimal(str(norm_score))
                    )
                )
        DailyFactorValues.objects.bulk_create(factor_values_to_create, ignore_conflicts=True)
        logger.debug(f"  - 成功保存因子值。")

        # 2. 保存每日交易预案
        plan_date = self.trade_date + timedelta(days=1)
        logger.debug(f"  - 正在为 {plan_date} 保存 {len(trading_plan_df)} 条交易预案...")
        
        # 先删除当天的旧预案，以防重复运行
        DailyTradingPlan.objects.filter(plan_date=plan_date).delete()
        
        plans_to_create = []
        for _, row in trading_plan_df.iterrows():
            plans_to_create.append(
                DailyTradingPlan(
                    plan_date=plan_date,
                    stock_code_id=row['stock_code'],
                    rank=row['rank'],
                    final_score=Decimal(str(row['final_score'])),
                    miop=Decimal(str(row['miop'])).quantize(Decimal('0.01')),
                    maop=Decimal(str(row['maop'])).quantize(Decimal('0.01')),
                    status=DailyTradingPlan.StatusChoices.PENDING
                )
            )
        DailyTradingPlan.objects.bulk_create(plans_to_create)
        logger.debug(f"  - 成功保存交易预案。")

        # 3. 将最终选股结果记录到系统日志
        log_message = f"T-1日({self.trade_date})选股完成, T日({plan_date})预案如下:\n"
        log_message += trading_plan_df.to_string(index=False)
        self._log_to_db('INFO', log_message)
        
        logger.debug("所有结果已成功保存到数据库。")

    # endregion


# region: --- 示例用法 ---
# 如何在项目中使用这个服务

def setup_django_env():
    """
    独立脚本运行时，需要配置Django环境。
    在Django项目内部（如management command）调用时，则不需要此函数。
    """
    import os
    import django
    # 替换 'your_project.settings' 为你的项目设置文件
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'your_project.settings')
    django.setup()

if __name__ == '__main__':
    # --- 这是一个演示如何调用服务的示例 ---
    # 1. 首先需要设置Django环境
    # setup_django_env() # 如果是独立脚本，取消此行注释

    # 2. (可选) 第一次运行时，初始化策略定义
    print("="*50)
    print("步骤 1: 初始化策略 (如果需要)")
    SelectionService.initialize_strategy()
    print("="*50)

    # 3. 运行选股流程 (以回测模式为例)
    print("\n" + "="*50)
    print("步骤 2: 运行选股流程")
    # 假设我们想为 2023-10-26 (T日) 生成预案，那么T-1日就是 2023-10-25
    # 注意：请确保你的数据库中有 2023-10-25 及之前足够多的数据
    target_trade_date = date(2023, 10, 25) 
    
    try:
        service = SelectionService(trade_date=target_trade_date, mode='backtest')
        service.run_selection()
    except Exception as e:
        print(f"\n在为日期 {target_trade_date} 运行选股时发生错误: {e}")
    
    print("="*50)
    print("示例运行结束。")

# endregion

####文件结束####

####trade_manager\__init__.py####

####文件结束####

####trade_manager\admin.py####
from django.contrib import admin

# Register your models here.

####文件结束####

####trade_manager\apps.py####
from django.apps import AppConfig


class TradeManagerConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'trade_manager'

####文件结束####

####trade_manager\models.py####
from django.db import models

# Create your models here.

####文件结束####

####trade_manager\tests.py####
from django.test import TestCase

# Create your tests here.

####文件结束####

####trade_manager\urls.py####
"""
URL configuration for autoTrade project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.2/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path,include
from . import views
urlpatterns = [
    path('beforeFixRun', views.before_fix_run),
    path('initParam',views.initialize_strategy_parameters),
    path('simulateTrade', views.simulate_trade)
]

####文件结束####

####trade_manager\views.py####
from datetime import date,datetime
from django.shortcuts import render
from django.http.response import JsonResponse
from trade_manager.service.before_fix_service import BeforeFixService
from trade_manager.service.decision_order_service import DecisionOrderService
from trade_manager.service.simulate_trade import SimulateTradeService
import json
from django.views.decorators.http import require_http_methods
# Create your views here.
@require_http_methods(["POST"])
def before_fix_run(request):
    if request.method=='POST':
        body= json.loads(request.body)
        selection_date=datetime.strptime(body['date'], "%Y-%m-%d").date()
        service=BeforeFixService(selection_date)
        service.run()
        return JsonResponse({
            'result':'成功'
        })
@require_http_methods(["GET"])
def initialize_strategy_parameters(request):
    if request.method=='GET':
        DecisionOrderService.initialize_strategy_parameters()
        return JsonResponse({
            'result':'成功'
        })

@require_http_methods(["POST"])
def simulate_trade(request):
    if request.method=='POST':
        body= json.loads(request.body)
        start_date=body['startDate']
        end_date=body['endDate']
        service=SimulateTradeService()
        result=service.run_backtest(start_date=start_date,end_date=end_date)
        return JsonResponse(result)
####文件结束####

####trade_manager\service\before_fix_service.py####
# trade_manager/service/before_fix_service.py

import logging
from datetime import date, timedelta, datetime
from decimal import Decimal, ROUND_HALF_UP
from django.utils import timezone
from django.db import transaction
from django.db.models import Q

# 导入项目内的模型
from common.models import (
    CorporateAction,
    DailyTradingPlan,
    Position,
    DailyQuotes,
    SystemLog
)

# 配置日志记录器
logger = logging.getLogger(__name__)


class BeforeFixService:
    """
    T日开盘前校准与预案修正服务。

    职责:
    1. 检查当天是否已成功执行过，防止重复运行。
    2. 获取T日的除权除息事件。
    3. 计算受影响股票的价格调整比率。
    4. 根据比率修正“每日交易预案”中的MIOP和MAOP。
    5. 根据比率修正“持仓信息”中的止盈止损价。
    6. 对近期发生配股的股票进行特殊风险处理。
    """
    MODULE_NAME = '盘前校准与预案修正'
    # 可配置参数
    MAX_PLAN_LOOKBACK_DAYS = 14  # 查找交易预案的最大回溯天数
    RIGHTS_ISSUE_LOOKBACK_DAYS = 30 # 配股事件特殊处理的回溯交易日数

    def __init__(self, execution_date: date = None):
        """
        初始化服务。
        :param execution_date: T日，即执行校准的日期。如果为None，则默认为当天。
        """
        self.t_day = execution_date if execution_date else date.today()
        self.t_minus_1_day = None
        self.adjustment_ratios = {} # 存储 {stock_code: ratio}
        logger.debug(f"[{self.MODULE_NAME}] 服务初始化，目标T日: {self.t_day}")

    def _log_to_db(self, level: str, message: str):
        """辅助方法：将日志写入数据库"""
        try:
            SystemLog.objects.create(
                log_level=level,
                module_name=self.MODULE_NAME,
                message=message
            )
        except Exception as e:
            logger.error(f"无法将日志写入数据库: {e}")

    def _is_trading_day(self, check_date: date) -> bool:
        """检查指定日期是否为交易日"""
        is_trade_day = DailyQuotes.objects.filter(trade_date=check_date).exists()
        logger.info(f"检查日期 {check_date} 是否为交易日: {'是' if is_trade_day else '否'}")
        return is_trade_day

    def _get_last_trading_day(self, from_date: date) -> date | None:
        """获取指定日期之前的最后一个交易日"""
        last_day = DailyQuotes.objects.filter(
            trade_date__lt=from_date
        ).order_by('-trade_date').values_list('trade_date', flat=True).first()
        
        if last_day:
            logger.info(f"{from_date} 的前一个交易日 (T-1) 是: {last_day}")
        else:
            logger.warning(f"无法找到 {from_date} 的前一个交易日。")
        return last_day

    def _find_latest_pending_plan_date(self) -> date | None:
        """从T日开始向前回溯，查找最新的一个包含待执行预案的日期"""
        for i in range(self.MAX_PLAN_LOOKBACK_DAYS):
            check_date = self.t_day - timedelta(days=i)
            if DailyTradingPlan.objects.filter(
                plan_date=check_date,
                status=DailyTradingPlan.StatusChoices.PENDING
            ).exists():
                logger.info(f"找到待执行的交易预案，预案日期为: {check_date}")
                return check_date
        logger.warning(f"在过去 {self.MAX_PLAN_LOOKBACK_DAYS} 天内未找到任何待执行的交易预案。")
        return None

    def _calculate_adjusted_price(self, t_minus_1_close: Decimal, events: list[CorporateAction]) -> Decimal:
        """
        核心算法：根据事件列表计算除权除息参考价。
        处理顺序：1.除息 -> 2.送/转股 -> 3.配股
        """
        adjusted_price = t_minus_1_close
        
        # 按事件类型优先级排序
        event_priority = {
            CorporateAction.EventType.DIVIDEND: 1,
            CorporateAction.EventType.BONUS: 2,
            CorporateAction.EventType.TRANSFER: 2,
            CorporateAction.EventType.SPLIT: 2,
            CorporateAction.EventType.RIGHTS: 3,
        }
        sorted_events = sorted(events, key=lambda e: event_priority.get(e.event_type, 99))

        for event in sorted_events:
            # 1. 现金分红 (除息)
            if event.event_type == CorporateAction.EventType.DIVIDEND and event.dividend_per_share:
                adjusted_price -= event.dividend_per_share
            
            # 2. 送股/转增股/并股/拆股 (除权)
            elif event.event_type in [CorporateAction.EventType.BONUS, CorporateAction.EventType.TRANSFER, CorporateAction.EventType.SPLIT]:
                if event.shares_before and event.shares_after and event.shares_after > 0:
                    adjusted_price = adjusted_price * (event.shares_before / event.shares_after)

            # 3. 配股 (除权) - 注意：按需求，此计算结果不用于常规校准，但逻辑保留
            elif event.event_type == CorporateAction.EventType.RIGHTS:
                if event.shares_before and event.shares_after and event.rights_issue_price is not None and event.shares_after > 0:
                    adjusted_price = (event.shares_before * adjusted_price + (event.shares_after - event.shares_before) * event.rights_issue_price) / event.shares_after
        
        return adjusted_price

    @transaction.atomic
    def run(self):
        """执行盘前校准与修正的主流程"""

        self.t_minus_1_day = self._get_last_trading_day(self.t_day)
        if not self.t_minus_1_day:
            logger.error(f"无法确定T-1日，任务终止。")
            return

        # a. 获取T日所有除权除息信息
        events_on_t_day = CorporateAction.objects.filter(ex_dividend_date=self.t_day)
        if not events_on_t_day.exists():
            logger.debug(f"T日 ({self.t_day}) 无除权除息事件，无需校准。")
            return

        # 按股票代码分组事件
        events_by_stock = {}
        for event in events_on_t_day:
            events_by_stock.setdefault(event.stock_code, []).append(event)
        
        affected_codes = list(events_by_stock.keys())
        logger.info(f"T日共有 {len(affected_codes)} 只股票发生股权事件。")

        # 获取这些股票在T-1日的收盘价
        quotes_qs = DailyQuotes.objects.filter(
            trade_date=self.t_minus_1_day,
            stock_code_id__in=affected_codes
        )
        # 使用字典推导式构建我们需要的映射关系
        quotes_t_minus_1 = {quote.stock_code_id: quote for quote in quotes_qs}

        # b. 计算价格调整比率
        for stock_code, events in events_by_stock.items():
            if stock_code not in quotes_t_minus_1:
                logger.warning(f"股票 {stock_code} 在T-1日({self.t_minus_1_day})无行情数据（可能停牌），跳过校准。")
                continue
            
            close_t_minus_1 = quotes_t_minus_1[stock_code].close
            if close_t_minus_1 <= 0:
                logger.warning(f"股票 {stock_code} 在T-1日收盘价为0或负数，不合理，跳过校准。")
                continue

            adjusted_close = self._calculate_adjusted_price(close_t_minus_1, events)
            ratio = adjusted_close / close_t_minus_1
            self.adjustment_ratios[stock_code] = ratio
            logger.info(f"股票 {stock_code}: T-1收盘价={close_t_minus_1}, 校准后价格={adjusted_close:.2f}, 调整比率={ratio:.6f}")

        # c. 修正交易预案
        self._process_trading_plans()

        # d. 修正持仓风控
        self._process_positions()

        # e. 配股事件特殊处理
        self._handle_rights_issue_special_case()

        logger.info(f"[{self.MODULE_NAME}] 任务成功完成。共处理 {len(self.adjustment_ratios)} 只股票的常规校准。")

    def _process_trading_plans(self):
        """修正交易预案中的MIOP和MAOP"""
        plan_date_to_fix = self._find_latest_pending_plan_date()
        if not plan_date_to_fix:
            return

        plans_to_fix = DailyTradingPlan.objects.filter(
            plan_date=plan_date_to_fix,
            status=DailyTradingPlan.StatusChoices.PENDING,
            stock_code__in=self.adjustment_ratios.keys()
        )

        plans_to_update = []
        for plan in plans_to_fix:
            ratio = self.adjustment_ratios[plan.stock_code_id]
            original_miop = plan.miop
            original_maop = plan.maop
            
            plan.miop = (original_miop * Decimal(str(ratio))).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            plan.maop = (original_maop * Decimal(str(ratio))).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            
            plans_to_update.append(plan)
            logger.info(f"交易预案修正: {plan.stock_code}, MIOP: {original_miop}->{plan.miop}, MAOP: {original_maop}->{plan.maop}")

        if plans_to_update:
            DailyTradingPlan.objects.bulk_update(plans_to_update, ['miop', 'maop'])
            logger.info(f"成功批量更新 {len(plans_to_update)} 条交易预案。")

    def _process_positions(self):
        """修正持仓中的止盈止损价"""
        positions_to_fix = Position.objects.filter(
            status=Position.StatusChoices.OPEN,
            stock_code__in=self.adjustment_ratios.keys()
        )

        positions_to_update = []
        for pos in positions_to_fix:
            ratio = self.adjustment_ratios[pos.stock_code_id]
            original_sl = pos.current_stop_loss
            original_tp = pos.current_take_profit

            pos.current_stop_loss = (original_sl * Decimal(str(ratio))).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            pos.current_take_profit = (original_tp * Decimal(str(ratio))).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
            
            positions_to_update.append(pos)
            logger.info(f"持仓风控修正: {pos.stock_code}, 止损: {original_sl}->{pos.current_stop_loss}, 止盈: {original_tp}->{pos.current_take_profit}")

        if positions_to_update:
            Position.objects.bulk_update(positions_to_update, ['current_stop_loss', 'current_take_profit'])
            logger.info(f"成功批量更新 {len(positions_to_update)} 条持仓记录。")

    def _handle_rights_issue_special_case(self):
        """处理30个交易日内有配股事件的股票"""
        # 1. 获取过去30个交易日的日期列表
        recent_trading_days = list(
            DailyQuotes.objects.filter(trade_date__lte=self.t_day)
            .order_by('-trade_date')
            .values_list('trade_date', flat=True)[:self.RIGHTS_ISSUE_LOOKBACK_DAYS]
        )
        if not recent_trading_days:
            logger.warning("无法获取最近交易日列表，跳过配股特殊处理。")
            return

        # 2. 查找在此期间发生配股的股票
        rights_issue_stocks = list(
            CorporateAction.objects.filter(
                event_type=CorporateAction.EventType.RIGHTS,
                ex_dividend_date__in=recent_trading_days
            ).values_list('stock_code', flat=True).distinct()
        )
        if not rights_issue_stocks:
            logger.info("近期无配股事件，无需特殊处理。")
            return
        
        logger.warning(f"检测到 {len(rights_issue_stocks)} 只股票近期有配股事件: {rights_issue_stocks}，将进行风险剔除。")

        # 3. 处理交易预案
        plan_date_to_fix = self._find_latest_pending_plan_date()
        if plan_date_to_fix:
            plans_to_void = DailyTradingPlan.objects.filter(
                plan_date=plan_date_to_fix,
                status=DailyTradingPlan.StatusChoices.PENDING,
                stock_code__in=rights_issue_stocks
            )
            plans_to_update = []
            for plan in plans_to_void:
                plan.miop = Decimal('99999.00')
                plan.maop = Decimal('0.00')
                plans_to_update.append(plan)
            
            if plans_to_update:
                DailyTradingPlan.objects.bulk_update(plans_to_update, ['miop', 'maop'])
                logger.info(f"配股风险处理：将 {len(plans_to_update)} 条交易预案的MIOP/MAOP置为无效。")

        # 4. 处理持仓
        positions_to_void = Position.objects.filter(
            status=Position.StatusChoices.OPEN,
            stock_code__in=rights_issue_stocks
        )
        positions_to_update = []
        for pos in positions_to_void:
            pos.current_take_profit = Decimal('0.00')
            pos.current_stop_loss = Decimal('99999.00')
            positions_to_update.append(pos)
        
        if positions_to_update:
            Position.objects.bulk_update(positions_to_update, ['current_take_profit', 'current_stop_loss'])
            logger.info(f"配股风险处理：将 {len(positions_to_update)} 条持仓的止盈/止损置为紧急退出状态。")


# --- 如何在项目中使用这个服务 ---
# 你可以在一个Django Management Command或者定时任务中调用它
#
# from trade_manager.service.before_fix_service import BeforeFixService
#
# def run_daily_premarket_fix():
#     # 默认使用当天日期
#     service = BeforeFixService()
#     service.run()
#
# def run_backtest_premarket_fix(some_date):
#     # 传入指定日期进行回测
#     service = BeforeFixService(execution_date=some_date)
#     service.run()


####文件结束####

####trade_manager\service\decision_order_service.py####
# trade_manager/service/decision_order_service.py

import logging
from datetime import date, timedelta
from decimal import Decimal, ROUND_HALF_UP
import pandas as pd
import pandas_ta as ta

from django.db import transaction
from django.utils import timezone

from common.models import (
    DailyTradingPlan,
    Position,
    TradeLog,
    StrategyParameters,
    DailyQuotes,
    SystemLog
)
from .trade_handler import ITradeHandler

# 配置日志记录器
logger = logging.getLogger(__name__)

class DecisionOrderService:
    """
    开盘决策与下单模块。

    该服务负责在T日开盘后的黄金时间内，根据预案、实际开盘价和账户状态，
    做出最终的买入决策，并执行下单。同时，它也提供了在订单成交后计算
    止盈止损区间的功能。
    """
    MODULE_NAME = '开盘决策与下单'

    def __init__(self, handler: ITradeHandler, execution_date: date = None):
        """
        初始化服务。

        :param handler: 一个实现了 ITradeHandler 接口的实例，用于与交易环境交互。
        :param execution_date: T日，即执行决策的日期。如果为None，则默认为当天。
                               此参数为回测模块提供了设置模拟日期的入口。
        """
        if not isinstance(handler, ITradeHandler):
            raise TypeError("传入的 handler 必须是 ITradeHandler 的一个实例。")
        
        self.handler = handler
        self.execution_date = execution_date if execution_date else date.today()
        self.params = self._load_strategy_parameters()
        
        logger.debug(f"[{self.MODULE_NAME}] 服务初始化。执行T日: {self.execution_date}")
        logger.debug(f"策略参数加载成功: {self.params}")

    def _log_to_db(self, level: str, message: str):
        """辅助方法：将日志写入数据库"""
        SystemLog.objects.create(
            log_level=level,
            module_name=self.MODULE_NAME,
            message=message
        )

    def _load_strategy_parameters(self) -> dict:
        """从数据库加载所有策略参数到内存"""
        params = {}
        # 定义需要加载的参数及其默认值，以防数据库中没有
        required_params = {
            'MAX_POSITIONS': 2,
            'MAX_CAPITAL_PER_POSITION': 25000.00,
            'k_slip': 0.002,
            'Base_Target': 0.07,
            'k_g1': 1.5,
            'Max_Target': 0.20,
            'k_h1': 2.0,
            'k_h2': 3.0,
            'Max_Loss_Percent': 0.08,
            'lookback_atr': 14,
            'lookback_adx': 14,
            'lookback_ma20': 20,
            'param_adx_threshold': 25
        }
        
        db_params = {p.param_name: p.param_value for p in StrategyParameters.objects.all()}
        
        for key, default_value in required_params.items():
            # 优先使用数据库中的值，否则使用默认值
            value = db_params.get(key, Decimal(str(default_value)))
            # 将需要整数的参数转换为int
            if key in ['MAX_POSITIONS', 'lookback_atr', 'lookback_adx', 'lookback_ma20', 'param_adx_threshold']:
                params[key] = int(value)
            else:
                params[key] = Decimal(str(value))
        return params

    # --- 暴露给外部调度的核心函数 ---

    def adjust_trading_plan_daily(self):
        """
        函数一：执行每日交易预案再调整。
        根据实际开盘价与剩余仓位进行二次筛选，关闭不会被选择的交易预案。
        """
        logger.debug(f"开始执行 {self.execution_date} 的交易预案二次筛选...")
        
        plans_today = DailyTradingPlan.objects.filter(
            plan_date=self.execution_date,
            status=DailyTradingPlan.StatusChoices.PENDING
        ).order_by('rank')

        if not plans_today.exists():
            msg = f"在 {self.execution_date} 没有找到待执行的交易预案。"
            logger.warning(msg)
            self._log_to_db('WARNING', msg)
            return

        plans_to_cancel = []
        for plan in plans_today:
            try:
                open_price = self.handler.get_opening_price(plan.stock_code)
                if open_price <= 0:
                    logger.warning(f"股票 {plan.stock_code} 开盘价为0或无效，视为不符合条件。")
                    plan.status = DailyTradingPlan.StatusChoices.CANCELLED
                    plans_to_cancel.append(plan)
                    continue

                if not (plan.miop <= open_price <= plan.maop):
                    msg = (f"预案 {plan.stock_code} (Rank:{plan.rank}) 开盘价 {open_price} "
                           f"不在区间 [{plan.miop}, {plan.maop}] 内，已作废。")
                    logger.debug(msg)
                    plan.status = DailyTradingPlan.StatusChoices.CANCELLED
                    plans_to_cancel.append(plan)

            except Exception as e:
                msg = f"获取 {plan.stock_code} 开盘价时发生错误: {e}，该预案作废。"
                logger.error(msg)
                self._log_to_db('ERROR', msg)
                plan.status = DailyTradingPlan.StatusChoices.CANCELLED
                plans_to_cancel.append(plan)

        if plans_to_cancel:
            with transaction.atomic():
                DailyTradingPlan.objects.bulk_update(plans_to_cancel, ['status'])
            logger.info(f"成功作废 {len(plans_to_cancel)} 条不符合开盘条件的交易预案。")
        else:
            logger.info("所有待执行预案均符合开盘价条件。")

    def execute_orders(self):
        """
        函数二：进行下单。
        读取预案表，选择最优标的，计算仓位和价格，并调用处理器执行下单。
        """
        logger.info(f"开始执行 {self.execution_date} 的下单流程...")

        # 1. 检查剩余仓位
        open_positions_count = Position.objects.filter(status=Position.StatusChoices.OPEN).count()
        remaining_slots = self.params['MAX_POSITIONS'] - open_positions_count

        if remaining_slots <= 0:
            msg = f"当前持仓数 {open_positions_count} 已达上限 {self.params['MAX_POSITIONS']}，今日不进行买入操作。"
            logger.warning(msg)
            self._log_to_db('WARNING', msg)
            return

        #2. 获取所有待处理的候选标的
        candidates = DailyTradingPlan.objects.filter(
            plan_date=self.execution_date,
            status=DailyTradingPlan.StatusChoices.PENDING
        ).order_by('rank')
 
        if not candidates.exists():
            msg = f"在 {self.execution_date} 无符合条件的买入标的。"
            logger.info(msg)
            self._log_to_db('INFO', msg)
            return

        # 3. 遍历所有候选标的，直到成功买入一个
        for candidate in candidates:
            try:
                stock_code = candidate.stock_code
                open_price = self.handler.get_opening_price(stock_code)
                
                # 计算下单限价
                k_slip = self.params['k_slip']
                limit_price = (open_price * (Decimal('1.0') + k_slip)).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
 
                # 计算本次交易可用资金
                available_balance = self.handler.get_available_balance()
                capital_per_slot = available_balance / Decimal(remaining_slots)
                nominal_principal = min(capital_per_slot, self.params['MAX_CAPITAL_PER_POSITION'])
 
                # 计算购入股数
                if limit_price <= 0:
                    logger.warning(f"标的 {stock_code}: 计算出的下单限价无效（{limit_price}），跳过。")
                    continue # 尝试下一个候选
 
                shares_to_buy = int(nominal_principal / limit_price)
                quantity = (shares_to_buy // 100) * 100 # 向下取整到100的倍数
 
                if quantity < 100:
                    msg = (f"标的 {stock_code}: 计算出的名义本金 {nominal_principal:.2f} 不足以购买一手（100股），"
                           f"所需金额约为 {limit_price * 100:.2f}。放弃本次交易。")
                    logger.warning(msg)
                    self._log_to_db('WARNING', msg)
                    continue # 资金不足，尝试下一个候选
 
                # 4. 执行下单
                msg = (f"确定唯一买入标的: {stock_code} (Rank:{candidate.rank})。 "
                       f"计划以限价 {limit_price} 买入 {quantity} 股。")
                logger.info(msg)
                self._log_to_db('INFO', msg)
                
                self.handler.place_buy_order(stock_code, limit_price, quantity)
                
                # 标记预案为已执行
                candidate.status = DailyTradingPlan.StatusChoices.EXECUTED
                candidate.save()
 
                # 成功买入后，立即退出函数，外层循环会决定是否继续买入下一个仓位
                return
 
            except Exception as e:
                msg = f"处理候选股 {candidate.stock_code} 时发生严重错误: {e}"
                logger.error(msg, exc_info=True)
                self._log_to_db('CRITICAL', msg)
                continue # 发生异常，继续尝试下一个候选
 
        # 如果循环正常结束，说明所有候选股都无法买入
        logger.info(f"已尝试所有 {len(candidates)} 个候选标的，均未成功买入。")

    def calculate_stop_profit_loss(self, trade_id: int):
        """
        函数三：止盈止损区间计算 (修正版)。
        在订单成交后，为新持仓计算并更新初始的止盈止损价。
 
        :param trade_id: 已成交的买入交易在 tb_trade_log 中的唯一ID。
        """
        logger.info(f"开始为 trade_id={trade_id} 计算止盈止损区间...")
        try:
            with transaction.atomic():
                # 1. 获取交易和持仓信息
                trade_log = TradeLog.objects.select_for_update().get(
                    trade_id=trade_id,
                    trade_type=TradeLog.TradeTypeChoices.BUY,
                    status=TradeLog.StatusChoices.FILLED
                )
                position = Position.objects.select_for_update().get(pk=trade_log.position_id)
 
                if position.current_stop_loss > 0:
                    logger.warning(f"Position ID {position.position_id} 似乎已计算过止盈止损，将跳过。")
                    return
 
                stock_code = trade_log.stock_code_id
                aep = trade_log.price
                buy_date = trade_log.trade_datetime.date()
                
                # 2. 获取计算所需行情数据 (避免未来函数)
                lookback_days = self.params['lookback_adx'] + 50
                start_date_for_calc = buy_date - timedelta(days=lookback_days * 2)
                end_date_for_calc = buy_date - timedelta(days=1)
 
                quotes_qs = DailyQuotes.objects.filter(
                    stock_code_id=stock_code,
                    trade_date__gte=start_date_for_calc,
                    trade_date__lte=end_date_for_calc
                ).order_by('trade_date')
 
                if len(quotes_qs) < max(self.params['lookback_atr'], self.params['lookback_adx'], self.params['lookback_ma20']):
                    raise ValueError(f"股票 {stock_code} 在 {end_date_for_calc} 前的历史数据不足，无法计算指标。")
 
                df = pd.DataFrame.from_records(quotes_qs.values('high', 'low', 'close'))
                df = df.astype(float)
 
                # 3. 计算所有必需指标
                atr_series = ta.atr(df['high'], df['low'], df['close'], length=self.params['lookback_atr'])
                atr_14_buy = Decimal(str(atr_series.iloc[-1]))
 
                ma20_series = ta.sma(df['close'], length=self.params['lookback_ma20'])
                ma20_buy = Decimal(str(ma20_series.iloc[-1]))
 
                adx_df = ta.adx(df['high'], df['low'], df['close'], length=self.params['lookback_adx'])
                adx_14_buy = Decimal(str(adx_df[f'ADX_{self.params["lookback_adx"]}'].iloc[-1]))
 
                # 4. 计算止盈价 g(y) - 逻辑不变
                profit_margin = min(
                    self.params['Base_Target'] + self.params['k_g1'] * (atr_14_buy / aep),
                    self.params['Max_Target']
                )
                take_profit_price = aep * (Decimal('1.0') + profit_margin)
 
                # 5. 计算止损价 h(z) - 严格按照需求文档逻辑
                # 5.1 根据ADX判断市场状态，选择z_final
                adx_threshold = self.params['param_adx_threshold']
                if adx_14_buy > adx_threshold:
                    # 趋势状态，使用较窄的ATR乘数
                    z_final = aep - self.params['k_h1'] * atr_14_buy
                else:
                    # 震荡状态，使用较宽的ATR乘数
                    z_final = aep - self.params['k_h2'] * atr_14_buy
 
                # 5.2 计算其他止损线
                z2_technical = ma20_buy
                z3_max_loss = aep * (Decimal('1.0') - self.params['Max_Loss_Percent'])
                
                # 5.3 取最严格的止损位（价格最高者）
                stop_loss_price = max(z_final, z2_technical, z3_max_loss)
                
                logger.info(f"[{stock_code}] 止损线比较: 趋势位={z_final:.2f}, 技术位={z2_technical:.2f}, 底线={z3_max_loss:.2f}")
 
                # 6. 更新持仓信息表
                position.current_take_profit = take_profit_price.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
                position.current_stop_loss = stop_loss_price.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
                position.save(update_fields=['current_take_profit', 'current_stop_loss'])
 
                msg = (f"成功计算并更新 Position ID {position.position_id} ({stock_code}) 的风控价格: "
                       f"购入价={aep}, 止盈价={position.current_take_profit}, 止盈率={((Decimal('1.0') + profit_margin)*100):.2f}%, 止损价={position.current_stop_loss}, 止损率={((position.current_stop_loss/aep)*100):.2f}%")
                logger.info(msg)
                self._log_to_db('INFO', msg)
 
        except TradeLog.DoesNotExist:
            logger.error(f"Trade ID {trade_id} 不存在或不满足计算条件（非买入/未成交）。")
        except Position.DoesNotExist:
            logger.error(f"与 Trade ID {trade_id} 关联的 Position 不存在。")
        except Exception as e:
            msg = f"为 Trade ID {trade_id} 计算止盈止损时发生严重错误: {e}"

    # --- 工具函数 ---

    @staticmethod
    def initialize_strategy_parameters():
        """
        工具函数：初始化本模块所需的策略参数到数据库。
        这是一个幂等操作，可以安全地重复运行。
        """
        logger.info("开始初始化[开盘决策与下单模块]的策略参数...")

        params_to_define = {
            # 仓位管理
            'MAX_POSITIONS': {'value': '2', 'group': 'POSITION_MGMT', 'desc': '最大可具备的总仓位数'},
            'MAX_CAPITAL_PER_POSITION': {'value': '25000.00', 'group': 'POSITION_MGMT', 'desc': '每仓最大投入资金数(元)'},
            # 下单参数
            'k_slip': {'value': '0.002', 'group': 'ORDER_EXEC', 'desc': '下单滑点系数, 用于计算限价单价格'},
            # 止盈参数 g(y)
            'Base_Target': {'value': '0.07', 'group': 'TAKE_PROFIT', 'desc': '基础止盈目标百分比'},
            'k_g1': {'value': '1.5', 'group': 'TAKE_PROFIT', 'desc': 'ATR溢价乘数, 用于动态调整止盈目标'},
            'Max_Target': {'value': '0.20', 'group': 'TAKE_PROFIT', 'desc': '最大止盈目标百分比上限'},
            # 止损参数 h(z)
            'k_h1': {'value': '2.0', 'group': 'STOP_LOSS', 'desc': '趋势市ATR止损乘数 (盘中动态使用)'},
            'k_h2': {'value': '3.0', 'group': 'STOP_LOSS', 'desc': '震荡市ATR止损乘数 (用于计算初始止损)'},
            'Max_Loss_Percent': {'value': '0.08', 'group': 'STOP_LOSS', 'desc': '最大回撤容忍度(绝对亏损百分比上限)'},
            # 指标周期
            'lookback_atr': {'value': '14', 'group': 'INDICATORS', 'desc': 'ATR计算周期'},
            'lookback_adx': {'value': '14', 'group': 'INDICATORS', 'desc': 'ADX计算周期'},
            'lookback_ma20': {'value': '20', 'group': 'INDICATORS', 'desc': 'MA20计算周期'},
        }

        with transaction.atomic():
            for name, data in params_to_define.items():
                StrategyParameters.objects.update_or_create(
                    param_name=name,
                    defaults={
                        'param_value': Decimal(data['value']),
                        'group_name': data['group'],
                        'description': data['desc']
                    }
                )
        
        logger.info(f"成功初始化/更新 {len(params_to_define)} 个策略参数。")


####文件结束####

####trade_manager\service\monitor_exit_service.py####
# trade_manager/service/monitor_exit_service.py

import logging
from datetime import date
from django.utils import timezone
from decimal import Decimal

# 导入项目内的模型和接口
from common.models import Position, TradeLog
from .trade_handler import ITradeHandler

persistent_logger = logging.getLogger(__name__)


class MonitorExitService:
    """
    3.5 - 盘中持仓监控与退出模块

    该服务负责在交易时段内，以固定频率轮询，监控所有非当日建仓的持仓。
    当持仓股票的实时价格触及预设的止盈或止损线时，调用交易处理器执行卖出操作。
    """
    MODULE_NAME = '盘中持仓监控与退出'

    def __init__(self, handler: ITradeHandler,execution_date: date = None):
        """
        初始化监控服务。

        :param handler: 一个实现了 ITradeHandler 接口的实例，用于与交易环境交互。
        """
        if not isinstance(handler, ITradeHandler):
            raise TypeError("传入的 handler 必须是 ITradeHandler 的一个实例。")
        
        self.handler = handler
        self.execution_date = execution_date if execution_date else timezone.now().date()
        # 使用特定的logger进行高频、非持久化的日志记录
        self.logger = persistent_logger

    def monitor_and_exit_positions(self):
        """
        执行一次完整的持仓监控与退出检查。
        此函数应由一个定时调度器在交易时段内（09:30:01 - 14:57:00）
        以设定的频率反复调用。
        """
        self.logger.debug(f"[{self.MODULE_NAME}] 任务开始...")

        # 1. 从持仓信息表读取出entry_datetime建仓成交时间不为今天的持仓信息
        today = timezone.now().date()
        positions_to_monitor = Position.objects.filter(
            status=Position.StatusChoices.OPEN
        ).exclude(
            entry_datetime__date=self.execution_date
        )

        if not positions_to_monitor.exists():
            self.logger.debug("当前无需要监控的隔夜持仓。")
            return

        # 2. 循环调用处理器判断是否达到了止盈止损状态
        for position in positions_to_monitor:
            try:
                # 获取实时价格
                current_price = self.handler.get_realtime_price(position.stock_code)

                if current_price is None or current_price <= 0:
                    self.logger.debug(f"无法获取 {position.stock_code} 的有效实时价格，跳过本次检查。")
                    continue
                
                self.logger.debug(
                    f"监控: {position.stock_code}, "
                    f"当前价: {current_price}, "
                    f"止损价: {position.current_stop_loss}, "
                    f"止盈价: {position.current_take_profit}"
                )

                # 检查是否触发止损
                if current_price <= position.current_stop_loss:
                    msg = (f"触发止损条件! 股票: {position.stock_code}, "
                           f"当前价: {current_price} <= 止损价: {position.current_stop_loss}。准备执行卖出。")
                    persistent_logger.info(msg) # 这是一个重要事件，使用可持久化的logger
                    self.handler.sell_stock_by_market_price(position, TradeLog.ReasonChoices.STOP_LOSS)
                    # 卖出后，此持仓在下一次循环中将不再被查询到，无需从当前循环中移除

                # 检查是否触发止盈
                elif current_price >= position.current_take_profit:
                    msg = (f"触发止盈条件! 股票: {position.stock_code}, "
                           f"当前价: {current_price} >= 止盈价: {position.current_take_profit}。准备执行卖出。")
                    persistent_logger.info(msg) # 这是一个重要事件，使用可持久化的logger
                    self.handler.sell_stock_by_market_price(position, TradeLog.ReasonChoices.TAKE_PROFIT)

            except Exception as e:
                # 根据要求，卖出失败等异常只在控制台打印错误日志，等待下一次循环
                self.logger.error(
                    f"处理持仓 {position.position_id} ({position.stock_code}) 时发生错误: {e}",
                    exc_info=False # 在高频场景下，可以关闭traceback以保持日志简洁
                )
                continue
        
        self.logger.debug(f"[{self.MODULE_NAME}] 任务结束。")


####文件结束####

####trade_manager\service\simulate_trade.py####
# trade_manager/service/simulate_trade.py

import logging
import shutil
import os
from datetime import date, timedelta
from decimal import Decimal, ROUND_HALF_UP
import numpy as np
import pandas as pd
import time
from django.conf import settings
from django.db import connections, transaction
import sqlite3
from common.models import (
    DailyFactorValues, DailyTradingPlan, Position, TradeLog, SystemLog,
    StrategyParameters, DailyQuotes, CorporateAction
)
from selection_manager.service.selection_service import SelectionService
from trade_manager.service.before_fix_service import BeforeFixService
from trade_manager.service.decision_order_service import DecisionOrderService
from trade_manager.service.monitor_exit_service import MonitorExitService
from .simulate_trade_handler import SimulateTradeHandler

logger = logging.getLogger(__name__)

class SimulateTradeService:
    """
    回测实施服务。
    """
    COMMISSION_RATE = Decimal('0.0002854')
    MIN_COMMISSION = Decimal('5')
    STAMP_DUTY_RATE = Decimal('0.001')
    SELL_SLIPPAGE_RATE = Decimal('0.002')
    ANNUAL_RISK_FREE_RATE = Decimal('0.015')
    TRADING_DAYS_PER_YEAR = 252

    def __init__(self):
        self.start_date: date = None
        self.end_date: date = None
        self.current_date: date = None
        self.initial_capital = Decimal('0.0')
        self.cash_balance = Decimal('0.0')
        self.portfolio_history = []
        self.last_buy_trade_id = None
        self.original_db_config = None
    def _load_db_to_memory(self, source_db_path: str):
        """
        【优化版】使用 SQLite Backup API 高效地将磁盘数据库加载到内存。
        """
        logger.info(f"开始将数据从 {source_db_path} 加载到内存 (使用 Backup API)...")
        start_time = time.time()
        
        # 1. 创建一个到源文件数据库的直接连接 (只读)
        try:
            source_conn = sqlite3.connect(f'file:{source_db_path}?mode=ro', uri=True)
        except sqlite3.OperationalError as e:
            logger.error(f"无法以只读模式打开源数据库 {source_db_path}: {e}")
            raise
 
        # 2. 获取到Django管理的内存数据库的底层连接
        mem_conn = connections['default'].connection
 
        try:
            # 3. 【核心优化】使用 backup 方法
            #    它会以最有效的方式（通常是按数据页）将源数据库内容复制到目标数据库
            source_conn.backup(mem_conn)
            
            duration = time.time() - start_time
            logger.info(f"数据成功加载到内存数据库，耗时: {duration:.2f} 秒。")
 
        except Exception as e:
            logger.error(f"使用 Backup API 加载数据到内存时发生错误: {e}")
            raise
        finally:
            # 4. 关闭连接
            source_conn.close()
            # mem_conn 不需要我们手动关闭，Django会管理它
 


    # def _setup_environment(self):
    #     logger.info("--- 1. 准备回测环境 ---")
        
    #     base_dir = settings.BASE_DIR
    #     source_db = os.path.join(base_dir, 'mainDB.sqlite3')
    #     temp_db = os.path.join(base_dir, 'temp.sqlite3')
        
    #     if os.path.exists(temp_db):
    #         os.remove(temp_db)
    #     shutil.copy2(source_db, temp_db)
    #     logger.info(f"数据库已从 {source_db} 复制到 {temp_db}")

    #     connections.close_all()
    #     # 关键修复：保存原始配置，以便恢复
    #     self.original_db_config = settings.DATABASES['default'].copy()
    #     settings.DATABASES['default']['NAME'] = temp_db
    #     logger.info(f"已将 'default' 数据库连接重定向到 {temp_db}")

    #     tables_to_clear = [
    #         DailyFactorValues, DailyTradingPlan, Position,
    #         TradeLog, SystemLog
    #     ]
    #     with transaction.atomic():
    #         for model in tables_to_clear:
    #             model.objects.all().delete()
    #             logger.info(f"已清空表: {model._meta.db_table}")

    #     params = {p.param_name: p.param_value for p in StrategyParameters.objects.all()}
    #     max_positions = int(params.get('MAX_POSITIONS', Decimal('5')))
    #     max_capital_per_pos = params.get('MAX_CAPITAL_PER_POSITION', Decimal('10000'))
    #     self.initial_capital = Decimal(max_positions) * max_capital_per_pos
    #     self.cash_balance = self.initial_capital
    #     logger.info(f"初始资金已设定为: {self.initial_capital:.2f}")

    # def _cleanup_environment(self):
    #     """在回测结束后恢复原始数据库配置"""
    #     if self.original_db_config:
    #         connections.close_all()
    #         settings.DATABASES['default'] = self.original_db_config
    #         logger.info("已恢复 'default' 数据库连接到原始配置。")
    def _setup_environment(self):
        """
        修正版：调整了操作顺序，先加载数据，再执行ORM操作。
        """
        logger.info("--- 1. 准备回测环境 (内存模式) ---")
        
        base_dir = settings.BASE_DIR
        source_db = os.path.join(base_dir, 'mainDB.sqlite3')
        
        # 1. 关闭所有现有连接
        connections.close_all()
        
        # 2. 保存原始配置，并将 'default' 数据库重定向到内存
        self.original_db_config = settings.DATABASES['default'].copy()
        settings.DATABASES['default']['NAME'] = ':memory:'
        logger.info("已将 'default' 数据库连接重定向到 :memory:")
 
        # 3. 确保Django建立到新内存数据库的连接
        #    这一步至关重要，它会创建一个空的内存数据库实例
        connections['default'].ensure_connection()
        
        # 4. 【核心修正】立即将磁盘数据加载到内存数据库中
        #    此时，内存数据库从空变成了 mainDB.sqlite3 的一个完整克隆
        self._load_db_to_memory(source_db)
 
        # 5. 【顺序调整】现在内存数据库是完整的了，可以安全地执行任何Django ORM操作
        
        # 清空回测过程中会产生数据的表
        tables_to_clear = [
            DailyFactorValues, DailyTradingPlan, Position,
            TradeLog, SystemLog
        ]
        # 使用 transaction.atomic() 来保证操作的原子性
        with transaction.atomic():
            for model in tables_to_clear:
                # 现在 model.objects.all() 可以正常工作了
                model.objects.all().delete()
                logger.info(f"已清空表: {model._meta.db_table}")
 
        # 读取策略参数
        # 现在 StrategyParameters.objects.all() 也可以正常工作了
        params = {p.param_name: p.param_value for p in StrategyParameters.objects.all()}
        max_positions = int(params.get('MAX_POSITIONS', Decimal('5')))
        max_capital_per_pos = params.get('MAX_CAPITAL_PER_POSITION', Decimal('10000'))
        self.initial_capital = Decimal(max_positions) * max_capital_per_pos
        self.cash_balance = self.initial_capital
        logger.info(f"初始资金已设定为: {self.initial_capital:.2f}")
 
    def _cleanup_environment(self):
        """在回测结束后恢复原始数据库配置"""
        if self.original_db_config:
            connections.close_all()
            settings.DATABASES['default'] = self.original_db_config
            # 内存数据库的连接关闭后，其内容会自动销毁，无需手动删除文件
            logger.info("已恢复 'default' 数据库连接到原始配置，内存数据库已释放。")
    def _get_trading_days(self) -> list[date]:
        dates = DailyQuotes.objects.filter(
            trade_date__gte=self.start_date,
            trade_date__lte=self.end_date
        ).values_list('trade_date', flat=True).distinct().order_by('trade_date')
        return list(dates)

    def _calculate_daily_portfolio_value(self):
        open_positions = Position.objects.filter(status=Position.StatusChoices.OPEN)
        market_value = Decimal('0.0')
        for pos in open_positions:
            try:
                quote = DailyQuotes.objects.get(
                    stock_code_id=pos.stock_code_id,
                    trade_date=self.current_date
                )
                market_value += quote.close * pos.quantity
            except DailyQuotes.DoesNotExist:
                market_value += pos.entry_price * pos.quantity
        
        total_value = self.cash_balance + market_value
        self.portfolio_history.append({
            'date': self.current_date,
            'total_value': total_value
        })
        logger.info(f"--- 日终结算 ({self.current_date}) ---")
        logger.info(f"现金: {self.cash_balance:.2f}, 持仓市值: {market_value:.2f}, 总资产: {total_value:.2f}")

    def _calculate_performance_metrics(self) -> dict:
        logger.info("--- 4. 计算回测性能指标 ---")
        if not self.portfolio_history:
            return {}

        df = pd.DataFrame(self.portfolio_history)
        df['total_value'] = df['total_value'].astype(float)
        df['daily_return'] = df['total_value'].pct_change().fillna(0)
        
        final_value = float(df['total_value'].iloc[-1])
        total_return_amount = final_value - float(self.initial_capital)
        total_return_rate = (final_value / float(self.initial_capital)) - 1

        mean_daily_return = df['daily_return'].mean()
        std_daily_return = df['daily_return'].std()
        
        if std_daily_return == 0 or np.isnan(std_daily_return):
            sharpe_ratio = 0.0
        else:
            daily_risk_free_rate = (1 + self.ANNUAL_RISK_FREE_RATE) ** Decimal(1/self.TRADING_DAYS_PER_YEAR) - 1
            sharpe_ratio = (mean_daily_return - float(daily_risk_free_rate)) / std_daily_return
            sharpe_ratio *= np.sqrt(self.TRADING_DAYS_PER_YEAR)

        result = {
            'total_return_amount': round(total_return_amount, 2),
            'total_return_rate': round(total_return_rate, 4),
            'sharpe_ratio': round(float(sharpe_ratio), 4)
        }
        logger.info(f"回测结果: {result}")
        return result

    def run_backtest(self, start_date: str, end_date: str) -> dict:
        try:
            self.start_date = date.fromisoformat(start_date)
            self.end_date = date.fromisoformat(end_date)

            self._setup_environment()

            handler = SimulateTradeHandler(self)
            
            trading_days = self._get_trading_days()
            if not trading_days:
                logger.error("在指定日期范围内未找到任何交易日，回测终止。")
                return {}

            baseline_date = trading_days[0] - timedelta(days=1)
            self.portfolio_history.append({'date': baseline_date, 'total_value': self.initial_capital})

            logger.info(f"--- 2. 开始日度回测循环 ({len(trading_days)}天) ---")
            for i, current_day in enumerate(trading_days):
                self.current_date = current_day
                logger.info(f"\n{'='*20} 模拟日: {self.current_date} ({i+1}/{len(trading_days)}) {'='*20}")

                prev_trading_day = trading_days[i-1] if i > 0 else None
                if prev_trading_day:
                    logger.info(f"-> [T-1 选股] 基于 {prev_trading_day} 的数据...")
                    selection_service = SelectionService(trade_date=prev_trading_day, mode='backtest')
                    selection_service.run_selection()

                logger.info("-> [T日 盘前校准] ...")
                before_fix_service = BeforeFixService(execution_date=self.current_date)
                before_fix_service.run()
                
                dividend_events = CorporateAction.objects.filter(
                    ex_dividend_date=self.current_date, event_type=CorporateAction.EventType.DIVIDEND
                )
                # 按股票代码分组，提高效率
                events_by_stock = {}
                for event in dividend_events:
                    events_by_stock.setdefault(event.stock_code, []).append(event)

                if events_by_stock:
                    # 获取所有可能受影响的持仓
                    open_positions_for_dividend = Position.objects.filter(
                        stock_code_id__in=events_by_stock.keys(),
                        status=Position.StatusChoices.OPEN
                    )
                    
                    for pos in open_positions_for_dividend:
                        # 找到该股票对应的所有分红事件（通常只有一个）
                        stock_events = events_by_stock.get(pos.stock_code_id, [])
                        for event in stock_events:
                            dividend_amount = event.dividend_per_share * pos.quantity
                            self.cash_balance += dividend_amount
                            logger.info(f"除息事件: 持仓ID {pos.position_id} ({pos.stock_code_id}) 获得分红 {dividend_amount:.2f}，现金余额更新为 {self.cash_balance:.2f}")



                logger.info("-> [T日 开盘决策与买入] ...")
                decision_order_service = DecisionOrderService(handler=handler, execution_date=self.current_date)
                decision_order_service.adjust_trading_plan_daily()
                
                while True:
                    open_positions_count = Position.objects.filter(status=Position.StatusChoices.OPEN).count()
                    max_pos = int(StrategyParameters.objects.get(param_name='MAX_POSITIONS').param_value)
                    if open_positions_count >= max_pos:
                        break
                    
                    self.last_buy_trade_id = None
                    decision_order_service.execute_orders()
                    
                    if self.last_buy_trade_id:
                        decision_order_service.calculate_stop_profit_loss(self.last_buy_trade_id)
                    else:
                        break

                # 关键修复：在循环内实例化 MonitorExitService 并传入日期
                monitor_exit_service = MonitorExitService(handler=handler, execution_date=self.current_date)

                logger.info("-> [T日 盘中监控] 模拟价格跌至最低点...")
                handler.current_price_node = 'LOW'
                monitor_exit_service.monitor_and_exit_positions()

                logger.info("-> [T日 盘中监控] 模拟价格涨至最高点...")
                handler.current_price_node = 'HIGH'
                monitor_exit_service.monitor_and_exit_positions()

                self._calculate_daily_portfolio_value()

            logger.info("--- 3. 回测循环结束 ---")
            return self._calculate_performance_metrics()
        
        finally:
            # 确保无论成功还是失败，都清理环境
            self._cleanup_environment()

####文件结束####

####trade_manager\service\simulate_trade_handler.py####
# trade_manager/service/simulate_trade_handler.py

import logging
from datetime import time
from decimal import Decimal, ROUND_HALF_UP

from django.db import transaction
from django.utils import timezone

from .trade_handler import ITradeHandler
from common.models import Position, TradeLog, DailyQuotes

from typing import TYPE_CHECKING, Literal
if TYPE_CHECKING:
    from .simulate_trade import SimulateTradeService

logger = logging.getLogger(__name__)

class SimulateTradeHandler(ITradeHandler):
    """
    模拟交易处理器 (SimulateTradeHandler)。
    """

    def __init__(self, service: 'SimulateTradeService'):
        self.service = service
        self.current_price_node: Literal['OPEN', 'LOW', 'HIGH', 'CLOSE'] = 'CLOSE'

    def get_opening_price(self, stock_code: str) -> Decimal:
        try:
            quote = DailyQuotes.objects.get(
                stock_code_id=stock_code,
                trade_date=self.service.current_date
            )
            return quote.open
        except DailyQuotes.DoesNotExist:
            logger.warning(f"[回测] 无法在 {self.service.current_date} 找到 {stock_code} 的行情数据，返回0。")
            return Decimal('0.00')

    def get_realtime_price(self, stock_code: str) -> Decimal | None:
        try:
            quote = DailyQuotes.objects.get(
                stock_code_id=stock_code,
                trade_date=self.service.current_date
            )
            if self.current_price_node == 'LOW':
                return quote.low
            elif self.current_price_node == 'HIGH':
                return quote.high
            else:
                logger.warning(f"[回测] 在非法的价格节点 {self.current_price_node} 调用了 get_realtime_price。")
                return quote.close
        except DailyQuotes.DoesNotExist:
            logger.warning(f"[回测] 无法在 {self.service.current_date} 找到 {stock_code} 的行情数据，返回 None。")
            return None

    def get_available_balance(self) -> Decimal:
        return self.service.cash_balance

    @transaction.atomic
    def place_buy_order(self, stock_code: str, price: Decimal, quantity: int) -> None:
        amount = price * quantity
        commission = max(amount * self.service.COMMISSION_RATE, self.service.MIN_COMMISSION)
        total_cost = amount + commission

        if self.service.cash_balance < total_cost:
            msg = f"[回测] 资金不足！尝试买入 {stock_code} 需 {total_cost:.2f}，但现金仅剩 {self.service.cash_balance:.2f}。"
            logger.error(msg)
            raise ValueError(msg)

        self.service.cash_balance -= total_cost
        logger.info(f"[回测] 买入 {stock_code} {quantity}股 @{price:.2f}, "
                    f"花费: {amount:.2f}, 佣金: {commission:.2f}, "
                    f"现金余额: {self.service.cash_balance:.2f}")

        # 细节优化：使用更真实的开盘时间
        entry_time = time(9, 30, 1)
        entry_datetime = timezone.make_aware(
            timezone.datetime.combine(self.service.current_date, entry_time)
        )

        new_position = Position.objects.create(
            stock_code=stock_code,
            entry_datetime=entry_datetime,
            entry_price=price,
            quantity=quantity,
            current_stop_loss=Decimal('0.00'),
            current_take_profit=Decimal('0.00'),
            status=Position.StatusChoices.OPEN
        )

        trade_log = TradeLog.objects.create(
            position=new_position,
            stock_code=stock_code,
            trade_datetime=entry_datetime,
            trade_type=TradeLog.TradeTypeChoices.BUY,
            order_type=TradeLog.OrderTypeChoices.LIMIT,
            price=price,
            quantity=quantity,
            commission=commission,
            stamp_duty=Decimal('0.00'),
            reason=TradeLog.ReasonChoices.ENTRY,
            status=TradeLog.StatusChoices.FILLED
        )
        
        self.service.last_buy_trade_id = trade_log.trade_id

    @transaction.atomic
    def sell_stock_by_market_price(self, position: Position, reason: str) -> None:
        if reason == TradeLog.ReasonChoices.STOP_LOSS:
            trigger_price = position.current_stop_loss
        elif reason == TradeLog.ReasonChoices.TAKE_PROFIT:
            trigger_price = position.current_take_profit
        else:
            trigger_price = self.get_opening_price(position.stock_code_id)

        sell_price = trigger_price * (Decimal('1.0') - self.service.SELL_SLIPPAGE_RATE)
        sell_price = sell_price.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)

        amount = sell_price * position.quantity
        commission = max(amount * self.service.COMMISSION_RATE, self.service.MIN_COMMISSION)
        stamp_duty = amount * self.service.STAMP_DUTY_RATE
        net_income = amount - commission - stamp_duty

        self.service.cash_balance += net_income
        logger.info(f"[回测] 卖出 {position.stock_code_id} {position.quantity}股 @{sell_price:.2f} (触发价: {trigger_price:.2f}), "
                    f"收入: {amount:.2f}, 佣金: {commission:.2f}, 印花税: {stamp_duty:.2f}, "
                    f"现金余额: {self.service.cash_balance:.2f}")

        position.status = Position.StatusChoices.CLOSED
        position.save()

        # 细节优化：使用更真实的卖出时间，例如下午2:57
        sell_time = time(14, 57, 0)
        sell_datetime = timezone.make_aware(
            timezone.datetime.combine(self.service.current_date, sell_time)
        )

        TradeLog.objects.create(
            position=position,
            stock_code_id=position.stock_code_id,
            trade_datetime=sell_datetime,
            trade_type=TradeLog.TradeTypeChoices.SELL,
            order_type=TradeLog.OrderTypeChoices.MARKET,
            price=sell_price,
            quantity=position.quantity,
            commission=commission,
            stamp_duty=stamp_duty,
            reason=reason,
            status=TradeLog.StatusChoices.FILLED
        )

####文件结束####

####trade_manager\service\trade_handler.py####
# trade_manager/service/trade_handler.py

from abc import ABC, abstractmethod
from decimal import Decimal
from django.db import transaction
from django.utils import timezone
# 为了类型提示，我们可以从 common.models 导入 Position 和 TradeLog
# 注意：为了避免循环导入，通常在实现类中进行实际导入，这里仅为类型提示
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from common.models import Position, TradeLog



class ITradeHandler(ABC):
    """
    交易处理器抽象基类 (Abstract Base Class)。

    该接口定义了开盘决策与下单模块所需的所有外部交互行为。
    通过依赖此抽象接口而非具体实现，`DecisionOrderService` 可以与不同的
    交易环境（如真实交易接口、回测引擎）解耦。

    - 对于真实交易，实现类将通过API与券商服务器交互。
    - 对于回测，实现类将模拟这些交互，例如从历史数据中读取开盘价、
      模拟订单成交、并管理一个虚拟账户的余额。
    """

    @abstractmethod
    def get_opening_price(self, stock_code: str) -> Decimal:
        """
        获取指定股票在执行日的实际开盘价。

        :param stock_code: 股票代码，格式与 tb_stock_info 表一致 (如 'sh.600000')。
        :return: 当日的开盘价。如果无法获取（例如停牌），应引发异常或返回一个可识别的错误值（如Decimal('0.00')）。
        """
        pass

    @abstractmethod
    def place_buy_order(self, stock_code: str, price: Decimal, quantity: int) -> None:
        """
        提交一个买入订单。

        此方法的实现者负责处理与交易系统的所有交互。根据需求，此方法
        在执行时，需要完成以下数据库操作：
        1. 在 `tb_positions` 表中插入一条新的持仓记录，其中所有非空字段
           （如 current_stop_loss, current_take_profit）可使用哨兵值（如-1）填充，
           等待后续的止盈止损计算任务来更新。
        2. 在 `tb_trade_log` 表中插入一条对应的交易记录，初始状态应为
           'pending'。

        :param stock_code: 股票代码。
        :param price: 预期的买入限价。
        :param quantity: 计划买入的股数（必须是100的整数倍）。
        :return: 无返回值。
        """
        pass

    @abstractmethod
    def get_available_balance(self) -> Decimal:
        """
        查询当前账户的可用资金余额。

        :return: 可用于交易的现金余额。
        """
        pass

    
    @abstractmethod
    def get_realtime_price(self, stock_code: str) -> Decimal | None:
        """
        获取一只股票的实时价格。
 
        :param stock_code: 股票代码，格式如 'sh.600000'。
        :return: 该股票此时此刻的市场价 (Decimal类型)。如果获取失败（如网络问题、股票停牌），
                 应返回 None，以便调用方进行错误处理。
        """
        pass
 
    @abstractmethod
    def sell_stock_by_market_price(self, position: 'Position', reason: str) -> None:
        """
        以市价单全量卖出指定的持仓。
 
        此方法的具体实现需要完成一个原子性的操作流程：
        1. 调用交易API，以市价单卖出 `position.quantity` 数量的 `position.stock_code`。
        2. **在API调用成功返回成交回报后**，执行以下数据库操作：
           a. **更新持仓表 (tb_positions)**: 将传入的 `position` 对象的状态更新为 'closed'。
              `position.status = Position.StatusChoices.CLOSED`
              `position.save()`
           b. **插入交易记录 (tb_trade_log)**: 创建一条新的卖出记录。
              - `position`: 关联到此持仓。
              - `stock_code`: 股票代码。
              - `trade_datetime`: 交易的实际成交时间。
              - `trade_type`: 'sell'。
              - `order_type`: 'market'。
              - `quantity`: 实际成交数量。
              - `price`: 实际的成交均价。从成交回报中获取。如果无法立即获取，
                                            则使用 -1 作为占位符，等待后续任务回补。
              - `commission`, `stamp_duty`: 从成交回报中获取。如果无法立即获取，
                                            则使用 -1 作为占位符，等待后续任务回补。
              - `reason`: 使用传入的 `reason` 参数 ('take_profit' 或 'stop_loss')。
              - `status`: 'filled' (已成交)。
        3. 整个数据库更新过程应该被包裹在一个事务中 (`transaction.atomic`)，确保数据一致性。
 
        :param position: 要卖出的持仓对象 (common.models.positions.Position)。
                         该对象包含了持仓ID、股票代码、持仓数量等所有必要信息。
        :param reason: 卖出原因的字符串，如 'take_profit' 或 'stop_loss'。
                       这个值将用于填充交易记录表的 `reason` 字段。
        :return: 无返回值。如果执行失败（如API调用失败、股票跌停无法卖出），
                 应在方法内部处理异常（如记录日志），并向上层调用者（MonitorExitService）
                 抛出异常或通过其他方式通知失败，以便上层决定是否重试。
        """
        pass
####文件结束####
